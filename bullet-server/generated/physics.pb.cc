// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: physics.proto

#include "physics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace physics {
PROTOBUF_CONSTEXPR Vector3::Vector3(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector3DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector3DefaultTypeInternal() {}
  union {
    Vector3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector3DefaultTypeInternal _Vector3_default_instance_;
PROTOBUF_CONSTEXPR Quaternion::Quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;
PROTOBUF_CONSTEXPR ShapeDescriptor::ShapeDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.shape_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ShapeDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeDescriptorDefaultTypeInternal() {}
  union {
    ShapeDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeDescriptorDefaultTypeInternal _ShapeDescriptor_default_instance_;
PROTOBUF_CONSTEXPR SphereData::SphereData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.mass_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SphereDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SphereDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SphereDataDefaultTypeInternal() {}
  union {
    SphereData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SphereDataDefaultTypeInternal _SphereData_default_instance_;
PROTOBUF_CONSTEXPR BoxData::BoxData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.mass_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoxDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxDataDefaultTypeInternal() {}
  union {
    BoxData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxDataDefaultTypeInternal _BoxData_default_instance_;
PROTOBUF_CONSTEXPR TerrainData::TerrainData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.heightmap_)*/{}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.scale_x_)*/0
  , /*decltype(_impl_.scale_y_)*/0
  , /*decltype(_impl_.scale_z_)*/0
  , /*decltype(_impl_.min_height_)*/0
  , /*decltype(_impl_.max_height_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TerrainDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TerrainDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TerrainDataDefaultTypeInternal() {}
  union {
    TerrainData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TerrainDataDefaultTypeInternal _TerrainData_default_instance_;
PROTOBUF_CONSTEXPR CreateObjectRequest::CreateObjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.shape_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateObjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateObjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateObjectRequestDefaultTypeInternal() {}
  union {
    CreateObjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateObjectRequestDefaultTypeInternal _CreateObjectRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateObjectResponse::CreateObjectResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateObjectResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateObjectResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateObjectResponseDefaultTypeInternal() {}
  union {
    CreateObjectResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateObjectResponseDefaultTypeInternal _CreateObjectResponse_default_instance_;
PROTOBUF_CONSTEXPR ApplyImpulseRequest::ApplyImpulseRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.impulse_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplyImpulseRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyImpulseRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyImpulseRequestDefaultTypeInternal() {}
  union {
    ApplyImpulseRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyImpulseRequestDefaultTypeInternal _ApplyImpulseRequest_default_instance_;
PROTOBUF_CONSTEXPR ApplyImpulseResponse::ApplyImpulseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplyImpulseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyImpulseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyImpulseResponseDefaultTypeInternal() {}
  union {
    ApplyImpulseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyImpulseResponseDefaultTypeInternal _ApplyImpulseResponse_default_instance_;
PROTOBUF_CONSTEXPR ApplyTorqueRequest::ApplyTorqueRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.torque_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplyTorqueRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyTorqueRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyTorqueRequestDefaultTypeInternal() {}
  union {
    ApplyTorqueRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyTorqueRequestDefaultTypeInternal _ApplyTorqueRequest_default_instance_;
PROTOBUF_CONSTEXPR ApplyTorqueResponse::ApplyTorqueResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplyTorqueResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyTorqueResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyTorqueResponseDefaultTypeInternal() {}
  union {
    ApplyTorqueResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyTorqueResponseDefaultTypeInternal _ApplyTorqueResponse_default_instance_;
PROTOBUF_CONSTEXPR GetObjectStateRequest::GetObjectStateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetObjectStateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetObjectStateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetObjectStateRequestDefaultTypeInternal() {}
  union {
    GetObjectStateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetObjectStateRequestDefaultTypeInternal _GetObjectStateRequest_default_instance_;
PROTOBUF_CONSTEXPR ObjectState::ObjectState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.linear_velocity_)*/nullptr
  , /*decltype(_impl_.angular_velocity_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObjectStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectStateDefaultTypeInternal() {}
  union {
    ObjectState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectStateDefaultTypeInternal _ObjectState_default_instance_;
PROTOBUF_CONSTEXPR GetObjectStateResponse::GetObjectStateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetObjectStateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetObjectStateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetObjectStateResponseDefaultTypeInternal() {}
  union {
    GetObjectStateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetObjectStateResponseDefaultTypeInternal _GetObjectStateResponse_default_instance_;
PROTOBUF_CONSTEXPR UpdateObjectMassRequest::UpdateObjectMassRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mass_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateObjectMassRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateObjectMassRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateObjectMassRequestDefaultTypeInternal() {}
  union {
    UpdateObjectMassRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateObjectMassRequestDefaultTypeInternal _UpdateObjectMassRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateObjectMassResponse::UpdateObjectMassResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateObjectMassResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateObjectMassResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateObjectMassResponseDefaultTypeInternal() {}
  union {
    UpdateObjectMassResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateObjectMassResponseDefaultTypeInternal _UpdateObjectMassResponse_default_instance_;
PROTOBUF_CONSTEXPR PhysicsConfig::PhysicsConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_impulse_)*/0
  , /*decltype(_impl_.max_impulse_)*/0
  , /*decltype(_impl_.distance_multiplier_)*/0
  , /*decltype(_impl_.impulse_multiplier_)*/0
  , /*decltype(_impl_.player_mass_)*/0
  , /*decltype(_impl_.default_box_mass_)*/0
  , /*decltype(_impl_.restitution_)*/0
  , /*decltype(_impl_.friction_)*/0
  , /*decltype(_impl_.gravity_x_)*/0
  , /*decltype(_impl_.gravity_y_)*/0
  , /*decltype(_impl_.gravity_z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhysicsConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhysicsConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhysicsConfigDefaultTypeInternal() {}
  union {
    PhysicsConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhysicsConfigDefaultTypeInternal _PhysicsConfig_default_instance_;
PROTOBUF_CONSTEXPR SetPhysicsConfigRequest::SetPhysicsConfigRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.config_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetPhysicsConfigRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetPhysicsConfigRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetPhysicsConfigRequestDefaultTypeInternal() {}
  union {
    SetPhysicsConfigRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetPhysicsConfigRequestDefaultTypeInternal _SetPhysicsConfigRequest_default_instance_;
PROTOBUF_CONSTEXPR SetPhysicsConfigResponse::SetPhysicsConfigResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetPhysicsConfigResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetPhysicsConfigResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetPhysicsConfigResponseDefaultTypeInternal() {}
  union {
    SetPhysicsConfigResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetPhysicsConfigResponseDefaultTypeInternal _SetPhysicsConfigResponse_default_instance_;
}  // namespace physics
static ::_pb::Metadata file_level_metadata_physics_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_physics_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_physics_2eproto = nullptr;

const uint32_t TableStruct_physics_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::Vector3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::Vector3, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::physics::Vector3, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::physics::Vector3, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::Quaternion, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::physics::Quaternion, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::physics::Quaternion, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::physics::Quaternion, _impl_.w_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ShapeDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::physics::ShapeDescriptor, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ShapeDescriptor, _impl_.type_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::physics::ShapeDescriptor, _impl_.shape_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::SphereData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::SphereData, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::physics::SphereData, _impl_.mass_),
  PROTOBUF_FIELD_OFFSET(::physics::SphereData, _impl_.color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _impl_.mass_),
  PROTOBUF_FIELD_OFFSET(::physics::BoxData, _impl_.color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.heightmap_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.scale_x_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.scale_y_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.scale_z_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.min_height_),
  PROTOBUF_FIELD_OFFSET(::physics::TerrainData, _impl_.max_height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectRequest, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectRequest, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectRequest, _impl_.shape_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::CreateObjectResponse, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyImpulseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyImpulseRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::physics::ApplyImpulseRequest, _impl_.impulse_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyImpulseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyImpulseResponse, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyTorqueRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyTorqueRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::physics::ApplyTorqueRequest, _impl_.torque_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyTorqueResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ApplyTorqueResponse, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::GetObjectStateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::GetObjectStateRequest, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::ObjectState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::ObjectState, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::physics::ObjectState, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::physics::ObjectState, _impl_.linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::physics::ObjectState, _impl_.angular_velocity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::GetObjectStateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::GetObjectStateResponse, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::physics::GetObjectStateResponse, _impl_.state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::UpdateObjectMassRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::UpdateObjectMassRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::physics::UpdateObjectMassRequest, _impl_.mass_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::UpdateObjectMassResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::UpdateObjectMassResponse, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.base_impulse_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.max_impulse_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.distance_multiplier_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.impulse_multiplier_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.player_mass_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.default_box_mass_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.restitution_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.friction_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.gravity_x_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.gravity_y_),
  PROTOBUF_FIELD_OFFSET(::physics::PhysicsConfig, _impl_.gravity_z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::SetPhysicsConfigRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::SetPhysicsConfigRequest, _impl_.config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::physics::SetPhysicsConfigResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::physics::SetPhysicsConfigResponse, _impl_.status_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::physics::Vector3)},
  { 9, -1, -1, sizeof(::physics::Quaternion)},
  { 19, -1, -1, sizeof(::physics::ShapeDescriptor)},
  { 30, -1, -1, sizeof(::physics::SphereData)},
  { 39, -1, -1, sizeof(::physics::BoxData)},
  { 50, -1, -1, sizeof(::physics::TerrainData)},
  { 64, -1, -1, sizeof(::physics::CreateObjectRequest)},
  { 74, -1, -1, sizeof(::physics::CreateObjectResponse)},
  { 81, -1, -1, sizeof(::physics::ApplyImpulseRequest)},
  { 89, -1, -1, sizeof(::physics::ApplyImpulseResponse)},
  { 96, -1, -1, sizeof(::physics::ApplyTorqueRequest)},
  { 104, -1, -1, sizeof(::physics::ApplyTorqueResponse)},
  { 111, -1, -1, sizeof(::physics::GetObjectStateRequest)},
  { 118, -1, -1, sizeof(::physics::ObjectState)},
  { 128, -1, -1, sizeof(::physics::GetObjectStateResponse)},
  { 136, -1, -1, sizeof(::physics::UpdateObjectMassRequest)},
  { 144, -1, -1, sizeof(::physics::UpdateObjectMassResponse)},
  { 151, -1, -1, sizeof(::physics::PhysicsConfig)},
  { 168, -1, -1, sizeof(::physics::SetPhysicsConfigRequest)},
  { 175, -1, -1, sizeof(::physics::SetPhysicsConfigResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::physics::_Vector3_default_instance_._instance,
  &::physics::_Quaternion_default_instance_._instance,
  &::physics::_ShapeDescriptor_default_instance_._instance,
  &::physics::_SphereData_default_instance_._instance,
  &::physics::_BoxData_default_instance_._instance,
  &::physics::_TerrainData_default_instance_._instance,
  &::physics::_CreateObjectRequest_default_instance_._instance,
  &::physics::_CreateObjectResponse_default_instance_._instance,
  &::physics::_ApplyImpulseRequest_default_instance_._instance,
  &::physics::_ApplyImpulseResponse_default_instance_._instance,
  &::physics::_ApplyTorqueRequest_default_instance_._instance,
  &::physics::_ApplyTorqueResponse_default_instance_._instance,
  &::physics::_GetObjectStateRequest_default_instance_._instance,
  &::physics::_ObjectState_default_instance_._instance,
  &::physics::_GetObjectStateResponse_default_instance_._instance,
  &::physics::_UpdateObjectMassRequest_default_instance_._instance,
  &::physics::_UpdateObjectMassResponse_default_instance_._instance,
  &::physics::_PhysicsConfig_default_instance_._instance,
  &::physics::_SetPhysicsConfigRequest_default_instance_._instance,
  &::physics::_SetPhysicsConfigResponse_default_instance_._instance,
};

const char descriptor_table_protodef_physics_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rphysics.proto\022\007physics\"*\n\007Vector3\022\t\n\001x"
  "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"8\n\nQuaterni"
  "on\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\t\n\001w"
  "\030\004 \001(\002\"\371\001\n\017ShapeDescriptor\0220\n\004type\030\001 \001(\016"
  "2\".physics.ShapeDescriptor.ShapeType\022%\n\006"
  "sphere\030\n \001(\0132\023.physics.SphereDataH\000\022\037\n\003b"
  "ox\030\013 \001(\0132\020.physics.BoxDataH\000\022\'\n\007terrain\030"
  "\014 \001(\0132\024.physics.TerrainDataH\000\":\n\tShapeTy"
  "pe\022\013\n\007UNKNOWN\020\000\022\n\n\006SPHERE\020\001\022\007\n\003BOX\020\002\022\013\n\007"
  "TERRAIN\020\003B\007\n\005shape\"9\n\nSphereData\022\016\n\006radi"
  "us\030\001 \001(\002\022\014\n\004mass\030\002 \001(\002\022\r\n\005color\030\003 \001(\t\"T\n"
  "\007BoxData\022\r\n\005width\030\001 \001(\002\022\016\n\006height\030\002 \001(\002\022"
  "\r\n\005depth\030\003 \001(\002\022\014\n\004mass\030\004 \001(\002\022\r\n\005color\030\005 "
  "\001(\t\"\231\001\n\013TerrainData\022\r\n\005width\030\001 \001(\005\022\r\n\005de"
  "pth\030\002 \001(\005\022\021\n\theightmap\030\003 \003(\002\022\017\n\007scale_x\030"
  "\004 \001(\002\022\017\n\007scale_y\030\005 \001(\002\022\017\n\007scale_z\030\006 \001(\002\022"
  "\022\n\nmin_height\030\007 \001(\002\022\022\n\nmax_height\030\010 \001(\002\""
  "\225\001\n\023CreateObjectRequest\022\n\n\002id\030\001 \001(\t\022\"\n\010p"
  "osition\030\002 \001(\0132\020.physics.Vector3\022%\n\010rotat"
  "ion\030\003 \001(\0132\023.physics.Quaternion\022\'\n\005shape\030"
  "\004 \001(\0132\030.physics.ShapeDescriptor\"&\n\024Creat"
  "eObjectResponse\022\016\n\006status\030\001 \001(\t\"D\n\023Apply"
  "ImpulseRequest\022\n\n\002id\030\001 \001(\t\022!\n\007impulse\030\002 "
  "\001(\0132\020.physics.Vector3\"&\n\024ApplyImpulseRes"
  "ponse\022\016\n\006status\030\001 \001(\t\"B\n\022ApplyTorqueRequ"
  "est\022\n\n\002id\030\001 \001(\t\022 \n\006torque\030\002 \001(\0132\020.physic"
  "s.Vector3\"%\n\023ApplyTorqueResponse\022\016\n\006stat"
  "us\030\001 \001(\t\"#\n\025GetObjectStateRequest\022\n\n\002id\030"
  "\001 \001(\t\"\257\001\n\013ObjectState\022\"\n\010position\030\001 \001(\0132"
  "\020.physics.Vector3\022%\n\010rotation\030\002 \001(\0132\023.ph"
  "ysics.Quaternion\022)\n\017linear_velocity\030\003 \001("
  "\0132\020.physics.Vector3\022*\n\020angular_velocity\030"
  "\004 \001(\0132\020.physics.Vector3\"M\n\026GetObjectStat"
  "eResponse\022\016\n\006status\030\001 \001(\t\022#\n\005state\030\002 \001(\013"
  "2\024.physics.ObjectState\"3\n\027UpdateObjectMa"
  "ssRequest\022\n\n\002id\030\001 \001(\t\022\014\n\004mass\030\002 \001(\002\"*\n\030U"
  "pdateObjectMassResponse\022\016\n\006status\030\001 \001(\t\""
  "\202\002\n\rPhysicsConfig\022\024\n\014base_impulse\030\001 \001(\002\022"
  "\023\n\013max_impulse\030\002 \001(\002\022\033\n\023distance_multipl"
  "ier\030\003 \001(\002\022\032\n\022impulse_multiplier\030\004 \001(\002\022\023\n"
  "\013player_mass\030\005 \001(\002\022\030\n\020default_box_mass\030\006"
  " \001(\002\022\023\n\013restitution\030\007 \001(\002\022\020\n\010friction\030\010 "
  "\001(\002\022\021\n\tgravity_x\030\t \001(\002\022\021\n\tgravity_y\030\n \001("
  "\002\022\021\n\tgravity_z\030\013 \001(\002\"A\n\027SetPhysicsConfig"
  "Request\022&\n\006config\030\001 \001(\0132\026.physics.Physic"
  "sConfig\"*\n\030SetPhysicsConfigResponse\022\016\n\006s"
  "tatus\030\001 \001(\t2\362\003\n\007Physics\022K\n\014CreateObject\022"
  "\034.physics.CreateObjectRequest\032\035.physics."
  "CreateObjectResponse\022K\n\014ApplyImpulse\022\034.p"
  "hysics.ApplyImpulseRequest\032\035.physics.App"
  "lyImpulseResponse\022H\n\013ApplyTorque\022\033.physi"
  "cs.ApplyTorqueRequest\032\034.physics.ApplyTor"
  "queResponse\022Q\n\016GetObjectState\022\036.physics."
  "GetObjectStateRequest\032\037.physics.GetObjec"
  "tStateResponse\022W\n\020UpdateObjectMass\022 .phy"
  "sics.UpdateObjectMassRequest\032!.physics.U"
  "pdateObjectMassResponse\022W\n\020SetPhysicsCon"
  "fig\022 .physics.SetPhysicsConfigRequest\032!."
  "physics.SetPhysicsConfigResponseB,Z*x-ce"
  "lls/backend/internal/physics/generatedb\006"
  "proto3"
  ;
static ::_pbi::once_flag descriptor_table_physics_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_physics_2eproto = {
    false, false, 2406, descriptor_table_protodef_physics_2eproto,
    "physics.proto",
    &descriptor_table_physics_2eproto_once, nullptr, 0, 20,
    schemas, file_default_instances, TableStruct_physics_2eproto::offsets,
    file_level_metadata_physics_2eproto, file_level_enum_descriptors_physics_2eproto,
    file_level_service_descriptors_physics_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_physics_2eproto_getter() {
  return &descriptor_table_physics_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_physics_2eproto(&descriptor_table_physics_2eproto);
namespace physics {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeDescriptor_ShapeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_physics_2eproto);
  return file_level_enum_descriptors_physics_2eproto[0];
}
bool ShapeDescriptor_ShapeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::UNKNOWN;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::SPHERE;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::BOX;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::TERRAIN;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::ShapeType_MIN;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor::ShapeType_MAX;
constexpr int ShapeDescriptor::ShapeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Vector3::_Internal {
 public:
};

Vector3::Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.Vector3)
}
Vector3::Vector3(const Vector3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector3* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:physics.Vector3)
}

inline void Vector3::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector3::~Vector3() {
  // @@protoc_insertion_point(destructor:physics.Vector3)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector3::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.Vector3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.Vector3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.Vector3)
  return target;
}

size_t Vector3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.Vector3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3::GetClassData() const { return &_class_data_; }


void Vector3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector3*>(&to_msg);
  auto& from = static_cast<const Vector3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.Vector3)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3::CopyFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3::IsInitialized() const {
  return true;
}

void Vector3::InternalSwap(Vector3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3, _impl_.z_)
      + sizeof(Vector3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vector3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[0]);
}

// ===================================================================

class Quaternion::_Internal {
 public:
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Quaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:physics.Quaternion)
}

inline void Quaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:physics.Quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.Quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.Quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // float w = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.Quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // float w = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }


void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.Quaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)
      + sizeof(Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[1]);
}

// ===================================================================

class ShapeDescriptor::_Internal {
 public:
  static const ::physics::SphereData& sphere(const ShapeDescriptor* msg);
  static const ::physics::BoxData& box(const ShapeDescriptor* msg);
  static const ::physics::TerrainData& terrain(const ShapeDescriptor* msg);
};

const ::physics::SphereData&
ShapeDescriptor::_Internal::sphere(const ShapeDescriptor* msg) {
  return *msg->_impl_.shape_.sphere_;
}
const ::physics::BoxData&
ShapeDescriptor::_Internal::box(const ShapeDescriptor* msg) {
  return *msg->_impl_.shape_.box_;
}
const ::physics::TerrainData&
ShapeDescriptor::_Internal::terrain(const ShapeDescriptor* msg) {
  return *msg->_impl_.shape_.terrain_;
}
void ShapeDescriptor::set_allocated_sphere(::physics::SphereData* sphere) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape();
  if (sphere) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sphere);
    if (message_arena != submessage_arena) {
      sphere = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sphere, submessage_arena);
    }
    set_has_sphere();
    _impl_.shape_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_set_allocated:physics.ShapeDescriptor.sphere)
}
void ShapeDescriptor::set_allocated_box(::physics::BoxData* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape();
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    set_has_box();
    _impl_.shape_.box_ = box;
  }
  // @@protoc_insertion_point(field_set_allocated:physics.ShapeDescriptor.box)
}
void ShapeDescriptor::set_allocated_terrain(::physics::TerrainData* terrain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape();
  if (terrain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terrain);
    if (message_arena != submessage_arena) {
      terrain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain, submessage_arena);
    }
    set_has_terrain();
    _impl_.shape_.terrain_ = terrain;
  }
  // @@protoc_insertion_point(field_set_allocated:physics.ShapeDescriptor.terrain)
}
ShapeDescriptor::ShapeDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ShapeDescriptor)
}
ShapeDescriptor::ShapeDescriptor(const ShapeDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.shape_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_shape();
  switch (from.shape_case()) {
    case kSphere: {
      _this->_internal_mutable_sphere()->::physics::SphereData::MergeFrom(
          from._internal_sphere());
      break;
    }
    case kBox: {
      _this->_internal_mutable_box()->::physics::BoxData::MergeFrom(
          from._internal_box());
      break;
    }
    case kTerrain: {
      _this->_internal_mutable_terrain()->::physics::TerrainData::MergeFrom(
          from._internal_terrain());
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:physics.ShapeDescriptor)
}

inline void ShapeDescriptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , decltype(_impl_.shape_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_shape();
}

ShapeDescriptor::~ShapeDescriptor() {
  // @@protoc_insertion_point(destructor:physics.ShapeDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_shape()) {
    clear_shape();
  }
}

void ShapeDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeDescriptor::clear_shape() {
// @@protoc_insertion_point(one_of_clear_start:physics.ShapeDescriptor)
  switch (shape_case()) {
    case kSphere: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_.sphere_;
      }
      break;
    }
    case kBox: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_.box_;
      }
      break;
    }
    case kTerrain: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_.terrain_;
      }
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SHAPE_NOT_SET;
}


void ShapeDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ShapeDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  clear_shape();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .physics.ShapeDescriptor.ShapeType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::physics::ShapeDescriptor_ShapeType>(val));
        } else
          goto handle_unusual;
        continue;
      // .physics.SphereData sphere = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sphere(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.BoxData box = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.TerrainData terrain = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_terrain(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ShapeDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .physics.ShapeDescriptor.ShapeType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .physics.SphereData sphere = 10;
  if (_internal_has_sphere()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sphere(this),
        _Internal::sphere(this).GetCachedSize(), target, stream);
  }

  // .physics.BoxData box = 11;
  if (_internal_has_box()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::box(this),
        _Internal::box(this).GetCachedSize(), target, stream);
  }

  // .physics.TerrainData terrain = 12;
  if (_internal_has_terrain()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::terrain(this),
        _Internal::terrain(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ShapeDescriptor)
  return target;
}

size_t ShapeDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ShapeDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .physics.ShapeDescriptor.ShapeType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  switch (shape_case()) {
    // .physics.SphereData sphere = 10;
    case kSphere: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_.sphere_);
      break;
    }
    // .physics.BoxData box = 11;
    case kBox: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_.box_);
      break;
    }
    // .physics.TerrainData terrain = 12;
    case kTerrain: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_.terrain_);
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeDescriptor::GetClassData() const { return &_class_data_; }


void ShapeDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeDescriptor*>(&to_msg);
  auto& from = static_cast<const ShapeDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ShapeDescriptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  switch (from.shape_case()) {
    case kSphere: {
      _this->_internal_mutable_sphere()->::physics::SphereData::MergeFrom(
          from._internal_sphere());
      break;
    }
    case kBox: {
      _this->_internal_mutable_box()->::physics::BoxData::MergeFrom(
          from._internal_box());
      break;
    }
    case kTerrain: {
      _this->_internal_mutable_terrain()->::physics::TerrainData::MergeFrom(
          from._internal_terrain());
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeDescriptor::CopyFrom(const ShapeDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ShapeDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeDescriptor::IsInitialized() const {
  return true;
}

void ShapeDescriptor::InternalSwap(ShapeDescriptor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.shape_, other->_impl_.shape_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[2]);
}

// ===================================================================

class SphereData::_Internal {
 public:
};

SphereData::SphereData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.SphereData)
}
SphereData::SphereData(const SphereData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SphereData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.mass_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.radius_, &from._impl_.radius_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mass_) -
    reinterpret_cast<char*>(&_impl_.radius_)) + sizeof(_impl_.mass_));
  // @@protoc_insertion_point(copy_constructor:physics.SphereData)
}

inline void SphereData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.mass_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SphereData::~SphereData() {
  // @@protoc_insertion_point(destructor:physics.SphereData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SphereData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void SphereData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SphereData::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.SphereData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.radius_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mass_) -
      reinterpret_cast<char*>(&_impl_.radius_)) + sizeof(_impl_.mass_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SphereData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float radius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.SphereData.color"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SphereData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.SphereData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float radius = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_radius(), target);
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_mass(), target);
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.SphereData.color");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.SphereData)
  return target;
}

size_t SphereData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.SphereData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 3;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float radius = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 4;
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SphereData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SphereData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SphereData::GetClassData() const { return &_class_data_; }


void SphereData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SphereData*>(&to_msg);
  auto& from = static_cast<const SphereData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.SphereData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = from._internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    _this->_internal_set_mass(from._internal_mass());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SphereData::CopyFrom(const SphereData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.SphereData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SphereData::IsInitialized() const {
  return true;
}

void SphereData::InternalSwap(SphereData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SphereData, _impl_.mass_)
      + sizeof(SphereData::_impl_.mass_)
      - PROTOBUF_FIELD_OFFSET(SphereData, _impl_.radius_)>(
          reinterpret_cast<char*>(&_impl_.radius_),
          reinterpret_cast<char*>(&other->_impl_.radius_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SphereData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[3]);
}

// ===================================================================

class BoxData::_Internal {
 public:
};

BoxData::BoxData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.BoxData)
}
BoxData::BoxData(const BoxData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoxData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.mass_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mass_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.mass_));
  // @@protoc_insertion_point(copy_constructor:physics.BoxData)
}

inline void BoxData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.depth_){0}
    , decltype(_impl_.mass_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BoxData::~BoxData() {
  // @@protoc_insertion_point(destructor:physics.BoxData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoxData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void BoxData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoxData::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.BoxData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mass_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.mass_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoxData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float depth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.BoxData.color"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.BoxData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float width = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_width(), target);
  }

  // float height = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_height(), target);
  }

  // float depth = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_depth(), target);
  }

  // float mass = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_mass(), target);
  }

  // string color = 5;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.BoxData.color");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.BoxData)
  return target;
}

size_t BoxData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.BoxData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 5;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float width = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 4;
  }

  // float height = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 4;
  }

  // float depth = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    total_size += 1 + 4;
  }

  // float mass = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoxData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoxData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoxData::GetClassData() const { return &_class_data_; }


void BoxData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoxData*>(&to_msg);
  auto& from = static_cast<const BoxData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.BoxData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = from._internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = from._internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    _this->_internal_set_depth(from._internal_depth());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = from._internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    _this->_internal_set_mass(from._internal_mass());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoxData::CopyFrom(const BoxData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.BoxData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxData::IsInitialized() const {
  return true;
}

void BoxData::InternalSwap(BoxData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoxData, _impl_.mass_)
      + sizeof(BoxData::_impl_.mass_)
      - PROTOBUF_FIELD_OFFSET(BoxData, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BoxData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[4]);
}

// ===================================================================

class TerrainData::_Internal {
 public:
};

TerrainData::TerrainData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.TerrainData)
}
TerrainData::TerrainData(const TerrainData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TerrainData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.heightmap_){from._impl_.heightmap_}
    , decltype(_impl_.width_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.scale_x_){}
    , decltype(_impl_.scale_y_){}
    , decltype(_impl_.scale_z_){}
    , decltype(_impl_.min_height_){}
    , decltype(_impl_.max_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.max_height_));
  // @@protoc_insertion_point(copy_constructor:physics.TerrainData)
}

inline void TerrainData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.heightmap_){arena}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.depth_){0}
    , decltype(_impl_.scale_x_){0}
    , decltype(_impl_.scale_y_){0}
    , decltype(_impl_.scale_z_){0}
    , decltype(_impl_.min_height_){0}
    , decltype(_impl_.max_height_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TerrainData::~TerrainData() {
  // @@protoc_insertion_point(destructor:physics.TerrainData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TerrainData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heightmap_.~RepeatedField();
}

void TerrainData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TerrainData::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.TerrainData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.heightmap_.Clear();
  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_height_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.max_height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TerrainData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 depth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float heightmap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_heightmap(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_heightmap(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.scale_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.scale_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale_z = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.scale_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float min_height = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.min_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float max_height = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.max_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TerrainData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.TerrainData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // int32 depth = 2;
  if (this->_internal_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_depth(), target);
  }

  // repeated float heightmap = 3;
  if (this->_internal_heightmap_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_heightmap(), target);
  }

  // float scale_x = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_scale_x(), target);
  }

  // float scale_y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_scale_y(), target);
  }

  // float scale_z = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_z = this->_internal_scale_z();
  uint32_t raw_scale_z;
  memcpy(&raw_scale_z, &tmp_scale_z, sizeof(tmp_scale_z));
  if (raw_scale_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_scale_z(), target);
  }

  // float min_height = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_min_height = this->_internal_min_height();
  uint32_t raw_min_height;
  memcpy(&raw_min_height, &tmp_min_height, sizeof(tmp_min_height));
  if (raw_min_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_min_height(), target);
  }

  // float max_height = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_height = this->_internal_max_height();
  uint32_t raw_max_height;
  memcpy(&raw_max_height, &tmp_max_height, sizeof(tmp_max_height));
  if (raw_max_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_max_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.TerrainData)
  return target;
}

size_t TerrainData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.TerrainData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float heightmap = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_heightmap_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 depth = 2;
  if (this->_internal_depth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
  }

  // float scale_x = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = this->_internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    total_size += 1 + 4;
  }

  // float scale_y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = this->_internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    total_size += 1 + 4;
  }

  // float scale_z = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_z = this->_internal_scale_z();
  uint32_t raw_scale_z;
  memcpy(&raw_scale_z, &tmp_scale_z, sizeof(tmp_scale_z));
  if (raw_scale_z != 0) {
    total_size += 1 + 4;
  }

  // float min_height = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_min_height = this->_internal_min_height();
  uint32_t raw_min_height;
  memcpy(&raw_min_height, &tmp_min_height, sizeof(tmp_min_height));
  if (raw_min_height != 0) {
    total_size += 1 + 4;
  }

  // float max_height = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_height = this->_internal_max_height();
  uint32_t raw_max_height;
  memcpy(&raw_max_height, &tmp_max_height, sizeof(tmp_max_height));
  if (raw_max_height != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TerrainData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TerrainData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TerrainData::GetClassData() const { return &_class_data_; }


void TerrainData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TerrainData*>(&to_msg);
  auto& from = static_cast<const TerrainData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.TerrainData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.heightmap_.MergeFrom(from._impl_.heightmap_);
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_depth() != 0) {
    _this->_internal_set_depth(from._internal_depth());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_x = from._internal_scale_x();
  uint32_t raw_scale_x;
  memcpy(&raw_scale_x, &tmp_scale_x, sizeof(tmp_scale_x));
  if (raw_scale_x != 0) {
    _this->_internal_set_scale_x(from._internal_scale_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_y = from._internal_scale_y();
  uint32_t raw_scale_y;
  memcpy(&raw_scale_y, &tmp_scale_y, sizeof(tmp_scale_y));
  if (raw_scale_y != 0) {
    _this->_internal_set_scale_y(from._internal_scale_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale_z = from._internal_scale_z();
  uint32_t raw_scale_z;
  memcpy(&raw_scale_z, &tmp_scale_z, sizeof(tmp_scale_z));
  if (raw_scale_z != 0) {
    _this->_internal_set_scale_z(from._internal_scale_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_min_height = from._internal_min_height();
  uint32_t raw_min_height;
  memcpy(&raw_min_height, &tmp_min_height, sizeof(tmp_min_height));
  if (raw_min_height != 0) {
    _this->_internal_set_min_height(from._internal_min_height());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_height = from._internal_max_height();
  uint32_t raw_max_height;
  memcpy(&raw_max_height, &tmp_max_height, sizeof(tmp_max_height));
  if (raw_max_height != 0) {
    _this->_internal_set_max_height(from._internal_max_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TerrainData::CopyFrom(const TerrainData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.TerrainData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TerrainData::IsInitialized() const {
  return true;
}

void TerrainData::InternalSwap(TerrainData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.heightmap_.InternalSwap(&other->_impl_.heightmap_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TerrainData, _impl_.max_height_)
      + sizeof(TerrainData::_impl_.max_height_)
      - PROTOBUF_FIELD_OFFSET(TerrainData, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TerrainData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[5]);
}

// ===================================================================

class CreateObjectRequest::_Internal {
 public:
  static const ::physics::Vector3& position(const CreateObjectRequest* msg);
  static const ::physics::Quaternion& rotation(const CreateObjectRequest* msg);
  static const ::physics::ShapeDescriptor& shape(const CreateObjectRequest* msg);
};

const ::physics::Vector3&
CreateObjectRequest::_Internal::position(const CreateObjectRequest* msg) {
  return *msg->_impl_.position_;
}
const ::physics::Quaternion&
CreateObjectRequest::_Internal::rotation(const CreateObjectRequest* msg) {
  return *msg->_impl_.rotation_;
}
const ::physics::ShapeDescriptor&
CreateObjectRequest::_Internal::shape(const CreateObjectRequest* msg) {
  return *msg->_impl_.shape_;
}
CreateObjectRequest::CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.CreateObjectRequest)
}
CreateObjectRequest::CreateObjectRequest(const CreateObjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateObjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::physics::Vector3(*from._impl_.position_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::physics::Quaternion(*from._impl_.rotation_);
  }
  if (from._internal_has_shape()) {
    _this->_impl_.shape_ = new ::physics::ShapeDescriptor(*from._impl_.shape_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.CreateObjectRequest)
}

inline void CreateObjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateObjectRequest::~CreateObjectRequest() {
  // @@protoc_insertion_point(destructor:physics.CreateObjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateObjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.shape_;
}

void CreateObjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateObjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.CreateObjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.shape_ != nullptr) {
    delete _impl_.shape_;
  }
  _impl_.shape_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateObjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.CreateObjectRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // .physics.Vector3 position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.Quaternion rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.ShapeDescriptor shape = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateObjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.CreateObjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.CreateObjectRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // .physics.Vector3 position = 2;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .physics.Quaternion rotation = 3;
  if (this->_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // .physics.ShapeDescriptor shape = 4;
  if (this->_internal_has_shape()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::shape(this),
        _Internal::shape(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.CreateObjectRequest)
  return target;
}

size_t CreateObjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.CreateObjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // .physics.Vector3 position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .physics.Quaternion rotation = 3;
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  // .physics.ShapeDescriptor shape = 4;
  if (this->_internal_has_shape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateObjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateObjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateObjectRequest::GetClassData() const { return &_class_data_; }


void CreateObjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateObjectRequest*>(&to_msg);
  auto& from = static_cast<const CreateObjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.CreateObjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::physics::Vector3::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_rotation()) {
    _this->_internal_mutable_rotation()->::physics::Quaternion::MergeFrom(
        from._internal_rotation());
  }
  if (from._internal_has_shape()) {
    _this->_internal_mutable_shape()->::physics::ShapeDescriptor::MergeFrom(
        from._internal_shape());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateObjectRequest::CopyFrom(const CreateObjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.CreateObjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateObjectRequest::IsInitialized() const {
  return true;
}

void CreateObjectRequest::InternalSwap(CreateObjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateObjectRequest, _impl_.shape_)
      + sizeof(CreateObjectRequest::_impl_.shape_)
      - PROTOBUF_FIELD_OFFSET(CreateObjectRequest, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateObjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[6]);
}

// ===================================================================

class CreateObjectResponse::_Internal {
 public:
};

CreateObjectResponse::CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.CreateObjectResponse)
}
CreateObjectResponse::CreateObjectResponse(const CreateObjectResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateObjectResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.CreateObjectResponse)
}

inline void CreateObjectResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateObjectResponse::~CreateObjectResponse() {
  // @@protoc_insertion_point(destructor:physics.CreateObjectResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateObjectResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void CreateObjectResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateObjectResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.CreateObjectResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateObjectResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.CreateObjectResponse.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateObjectResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.CreateObjectResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.CreateObjectResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.CreateObjectResponse)
  return target;
}

size_t CreateObjectResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.CreateObjectResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateObjectResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateObjectResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateObjectResponse::GetClassData() const { return &_class_data_; }


void CreateObjectResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateObjectResponse*>(&to_msg);
  auto& from = static_cast<const CreateObjectResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.CreateObjectResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateObjectResponse::CopyFrom(const CreateObjectResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.CreateObjectResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateObjectResponse::IsInitialized() const {
  return true;
}

void CreateObjectResponse::InternalSwap(CreateObjectResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateObjectResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[7]);
}

// ===================================================================

class ApplyImpulseRequest::_Internal {
 public:
  static const ::physics::Vector3& impulse(const ApplyImpulseRequest* msg);
};

const ::physics::Vector3&
ApplyImpulseRequest::_Internal::impulse(const ApplyImpulseRequest* msg) {
  return *msg->_impl_.impulse_;
}
ApplyImpulseRequest::ApplyImpulseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ApplyImpulseRequest)
}
ApplyImpulseRequest::ApplyImpulseRequest(const ApplyImpulseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyImpulseRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.impulse_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_impulse()) {
    _this->_impl_.impulse_ = new ::physics::Vector3(*from._impl_.impulse_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.ApplyImpulseRequest)
}

inline void ApplyImpulseRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.impulse_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyImpulseRequest::~ApplyImpulseRequest() {
  // @@protoc_insertion_point(destructor:physics.ApplyImpulseRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyImpulseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.impulse_;
}

void ApplyImpulseRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyImpulseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ApplyImpulseRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.impulse_ != nullptr) {
    delete _impl_.impulse_;
  }
  _impl_.impulse_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyImpulseRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.ApplyImpulseRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // .physics.Vector3 impulse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_impulse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyImpulseRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ApplyImpulseRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.ApplyImpulseRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // .physics.Vector3 impulse = 2;
  if (this->_internal_has_impulse()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::impulse(this),
        _Internal::impulse(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ApplyImpulseRequest)
  return target;
}

size_t ApplyImpulseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ApplyImpulseRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // .physics.Vector3 impulse = 2;
  if (this->_internal_has_impulse()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.impulse_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyImpulseRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyImpulseRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyImpulseRequest::GetClassData() const { return &_class_data_; }


void ApplyImpulseRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyImpulseRequest*>(&to_msg);
  auto& from = static_cast<const ApplyImpulseRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ApplyImpulseRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_impulse()) {
    _this->_internal_mutable_impulse()->::physics::Vector3::MergeFrom(
        from._internal_impulse());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyImpulseRequest::CopyFrom(const ApplyImpulseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ApplyImpulseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyImpulseRequest::IsInitialized() const {
  return true;
}

void ApplyImpulseRequest::InternalSwap(ApplyImpulseRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  swap(_impl_.impulse_, other->_impl_.impulse_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyImpulseRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[8]);
}

// ===================================================================

class ApplyImpulseResponse::_Internal {
 public:
};

ApplyImpulseResponse::ApplyImpulseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ApplyImpulseResponse)
}
ApplyImpulseResponse::ApplyImpulseResponse(const ApplyImpulseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyImpulseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.ApplyImpulseResponse)
}

inline void ApplyImpulseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyImpulseResponse::~ApplyImpulseResponse() {
  // @@protoc_insertion_point(destructor:physics.ApplyImpulseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyImpulseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void ApplyImpulseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyImpulseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ApplyImpulseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyImpulseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.ApplyImpulseResponse.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyImpulseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ApplyImpulseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.ApplyImpulseResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ApplyImpulseResponse)
  return target;
}

size_t ApplyImpulseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ApplyImpulseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyImpulseResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyImpulseResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyImpulseResponse::GetClassData() const { return &_class_data_; }


void ApplyImpulseResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyImpulseResponse*>(&to_msg);
  auto& from = static_cast<const ApplyImpulseResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ApplyImpulseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyImpulseResponse::CopyFrom(const ApplyImpulseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ApplyImpulseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyImpulseResponse::IsInitialized() const {
  return true;
}

void ApplyImpulseResponse::InternalSwap(ApplyImpulseResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyImpulseResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[9]);
}

// ===================================================================

class ApplyTorqueRequest::_Internal {
 public:
  static const ::physics::Vector3& torque(const ApplyTorqueRequest* msg);
};

const ::physics::Vector3&
ApplyTorqueRequest::_Internal::torque(const ApplyTorqueRequest* msg) {
  return *msg->_impl_.torque_;
}
ApplyTorqueRequest::ApplyTorqueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ApplyTorqueRequest)
}
ApplyTorqueRequest::ApplyTorqueRequest(const ApplyTorqueRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyTorqueRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.torque_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_torque()) {
    _this->_impl_.torque_ = new ::physics::Vector3(*from._impl_.torque_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.ApplyTorqueRequest)
}

inline void ApplyTorqueRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.torque_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyTorqueRequest::~ApplyTorqueRequest() {
  // @@protoc_insertion_point(destructor:physics.ApplyTorqueRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyTorqueRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.torque_;
}

void ApplyTorqueRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyTorqueRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ApplyTorqueRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.torque_ != nullptr) {
    delete _impl_.torque_;
  }
  _impl_.torque_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyTorqueRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.ApplyTorqueRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // .physics.Vector3 torque = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_torque(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyTorqueRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ApplyTorqueRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.ApplyTorqueRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // .physics.Vector3 torque = 2;
  if (this->_internal_has_torque()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::torque(this),
        _Internal::torque(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ApplyTorqueRequest)
  return target;
}

size_t ApplyTorqueRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ApplyTorqueRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // .physics.Vector3 torque = 2;
  if (this->_internal_has_torque()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.torque_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyTorqueRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyTorqueRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyTorqueRequest::GetClassData() const { return &_class_data_; }


void ApplyTorqueRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyTorqueRequest*>(&to_msg);
  auto& from = static_cast<const ApplyTorqueRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ApplyTorqueRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_torque()) {
    _this->_internal_mutable_torque()->::physics::Vector3::MergeFrom(
        from._internal_torque());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyTorqueRequest::CopyFrom(const ApplyTorqueRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ApplyTorqueRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyTorqueRequest::IsInitialized() const {
  return true;
}

void ApplyTorqueRequest::InternalSwap(ApplyTorqueRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  swap(_impl_.torque_, other->_impl_.torque_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyTorqueRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[10]);
}

// ===================================================================

class ApplyTorqueResponse::_Internal {
 public:
};

ApplyTorqueResponse::ApplyTorqueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ApplyTorqueResponse)
}
ApplyTorqueResponse::ApplyTorqueResponse(const ApplyTorqueResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyTorqueResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.ApplyTorqueResponse)
}

inline void ApplyTorqueResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyTorqueResponse::~ApplyTorqueResponse() {
  // @@protoc_insertion_point(destructor:physics.ApplyTorqueResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyTorqueResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void ApplyTorqueResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyTorqueResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ApplyTorqueResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyTorqueResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.ApplyTorqueResponse.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyTorqueResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ApplyTorqueResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.ApplyTorqueResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ApplyTorqueResponse)
  return target;
}

size_t ApplyTorqueResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ApplyTorqueResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyTorqueResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyTorqueResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyTorqueResponse::GetClassData() const { return &_class_data_; }


void ApplyTorqueResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyTorqueResponse*>(&to_msg);
  auto& from = static_cast<const ApplyTorqueResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ApplyTorqueResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyTorqueResponse::CopyFrom(const ApplyTorqueResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ApplyTorqueResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyTorqueResponse::IsInitialized() const {
  return true;
}

void ApplyTorqueResponse::InternalSwap(ApplyTorqueResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyTorqueResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[11]);
}

// ===================================================================

class GetObjectStateRequest::_Internal {
 public:
};

GetObjectStateRequest::GetObjectStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.GetObjectStateRequest)
}
GetObjectStateRequest::GetObjectStateRequest(const GetObjectStateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetObjectStateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.GetObjectStateRequest)
}

inline void GetObjectStateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetObjectStateRequest::~GetObjectStateRequest() {
  // @@protoc_insertion_point(destructor:physics.GetObjectStateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetObjectStateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void GetObjectStateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetObjectStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.GetObjectStateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetObjectStateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.GetObjectStateRequest.id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetObjectStateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.GetObjectStateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.GetObjectStateRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.GetObjectStateRequest)
  return target;
}

size_t GetObjectStateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.GetObjectStateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetObjectStateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetObjectStateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetObjectStateRequest::GetClassData() const { return &_class_data_; }


void GetObjectStateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetObjectStateRequest*>(&to_msg);
  auto& from = static_cast<const GetObjectStateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.GetObjectStateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetObjectStateRequest::CopyFrom(const GetObjectStateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.GetObjectStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetObjectStateRequest::IsInitialized() const {
  return true;
}

void GetObjectStateRequest::InternalSwap(GetObjectStateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetObjectStateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[12]);
}

// ===================================================================

class ObjectState::_Internal {
 public:
  static const ::physics::Vector3& position(const ObjectState* msg);
  static const ::physics::Quaternion& rotation(const ObjectState* msg);
  static const ::physics::Vector3& linear_velocity(const ObjectState* msg);
  static const ::physics::Vector3& angular_velocity(const ObjectState* msg);
};

const ::physics::Vector3&
ObjectState::_Internal::position(const ObjectState* msg) {
  return *msg->_impl_.position_;
}
const ::physics::Quaternion&
ObjectState::_Internal::rotation(const ObjectState* msg) {
  return *msg->_impl_.rotation_;
}
const ::physics::Vector3&
ObjectState::_Internal::linear_velocity(const ObjectState* msg) {
  return *msg->_impl_.linear_velocity_;
}
const ::physics::Vector3&
ObjectState::_Internal::angular_velocity(const ObjectState* msg) {
  return *msg->_impl_.angular_velocity_;
}
ObjectState::ObjectState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.ObjectState)
}
ObjectState::ObjectState(const ObjectState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.linear_velocity_){nullptr}
    , decltype(_impl_.angular_velocity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::physics::Vector3(*from._impl_.position_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::physics::Quaternion(*from._impl_.rotation_);
  }
  if (from._internal_has_linear_velocity()) {
    _this->_impl_.linear_velocity_ = new ::physics::Vector3(*from._impl_.linear_velocity_);
  }
  if (from._internal_has_angular_velocity()) {
    _this->_impl_.angular_velocity_ = new ::physics::Vector3(*from._impl_.angular_velocity_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.ObjectState)
}

inline void ObjectState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.linear_velocity_){nullptr}
    , decltype(_impl_.angular_velocity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ObjectState::~ObjectState() {
  // @@protoc_insertion_point(destructor:physics.ObjectState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.linear_velocity_;
  if (this != internal_default_instance()) delete _impl_.angular_velocity_;
}

void ObjectState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectState::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.ObjectState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .physics.Vector3 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.Quaternion rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.Vector3 linear_velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .physics.Vector3 angular_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.ObjectState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .physics.Vector3 position = 1;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .physics.Quaternion rotation = 2;
  if (this->_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // .physics.Vector3 linear_velocity = 3;
  if (this->_internal_has_linear_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::linear_velocity(this),
        _Internal::linear_velocity(this).GetCachedSize(), target, stream);
  }

  // .physics.Vector3 angular_velocity = 4;
  if (this->_internal_has_angular_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::angular_velocity(this),
        _Internal::angular_velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.ObjectState)
  return target;
}

size_t ObjectState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.ObjectState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .physics.Vector3 position = 1;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .physics.Quaternion rotation = 2;
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  // .physics.Vector3 linear_velocity = 3;
  if (this->_internal_has_linear_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.linear_velocity_);
  }

  // .physics.Vector3 angular_velocity = 4;
  if (this->_internal_has_angular_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angular_velocity_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectState::GetClassData() const { return &_class_data_; }


void ObjectState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectState*>(&to_msg);
  auto& from = static_cast<const ObjectState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.ObjectState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::physics::Vector3::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_rotation()) {
    _this->_internal_mutable_rotation()->::physics::Quaternion::MergeFrom(
        from._internal_rotation());
  }
  if (from._internal_has_linear_velocity()) {
    _this->_internal_mutable_linear_velocity()->::physics::Vector3::MergeFrom(
        from._internal_linear_velocity());
  }
  if (from._internal_has_angular_velocity()) {
    _this->_internal_mutable_angular_velocity()->::physics::Vector3::MergeFrom(
        from._internal_angular_velocity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectState::CopyFrom(const ObjectState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.ObjectState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectState::IsInitialized() const {
  return true;
}

void ObjectState::InternalSwap(ObjectState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectState, _impl_.angular_velocity_)
      + sizeof(ObjectState::_impl_.angular_velocity_)
      - PROTOBUF_FIELD_OFFSET(ObjectState, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[13]);
}

// ===================================================================

class GetObjectStateResponse::_Internal {
 public:
  static const ::physics::ObjectState& state(const GetObjectStateResponse* msg);
};

const ::physics::ObjectState&
GetObjectStateResponse::_Internal::state(const GetObjectStateResponse* msg) {
  return *msg->_impl_.state_;
}
GetObjectStateResponse::GetObjectStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.GetObjectStateResponse)
}
GetObjectStateResponse::GetObjectStateResponse(const GetObjectStateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetObjectStateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , decltype(_impl_.state_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_state()) {
    _this->_impl_.state_ = new ::physics::ObjectState(*from._impl_.state_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.GetObjectStateResponse)
}

inline void GetObjectStateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , decltype(_impl_.state_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetObjectStateResponse::~GetObjectStateResponse() {
  // @@protoc_insertion_point(destructor:physics.GetObjectStateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetObjectStateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
  if (this != internal_default_instance()) delete _impl_.state_;
}

void GetObjectStateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetObjectStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.GetObjectStateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetObjectStateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.GetObjectStateResponse.status"));
        } else
          goto handle_unusual;
        continue;
      // .physics.ObjectState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetObjectStateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.GetObjectStateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.GetObjectStateResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  // .physics.ObjectState state = 2;
  if (this->_internal_has_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.GetObjectStateResponse)
  return target;
}

size_t GetObjectStateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.GetObjectStateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  // .physics.ObjectState state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetObjectStateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetObjectStateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetObjectStateResponse::GetClassData() const { return &_class_data_; }


void GetObjectStateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetObjectStateResponse*>(&to_msg);
  auto& from = static_cast<const GetObjectStateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.GetObjectStateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_has_state()) {
    _this->_internal_mutable_state()->::physics::ObjectState::MergeFrom(
        from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetObjectStateResponse::CopyFrom(const GetObjectStateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.GetObjectStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetObjectStateResponse::IsInitialized() const {
  return true;
}

void GetObjectStateResponse::InternalSwap(GetObjectStateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetObjectStateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[14]);
}

// ===================================================================

class UpdateObjectMassRequest::_Internal {
 public:
};

UpdateObjectMassRequest::UpdateObjectMassRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.UpdateObjectMassRequest)
}
UpdateObjectMassRequest::UpdateObjectMassRequest(const UpdateObjectMassRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateObjectMassRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.mass_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.mass_ = from._impl_.mass_;
  // @@protoc_insertion_point(copy_constructor:physics.UpdateObjectMassRequest)
}

inline void UpdateObjectMassRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.mass_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateObjectMassRequest::~UpdateObjectMassRequest() {
  // @@protoc_insertion_point(destructor:physics.UpdateObjectMassRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateObjectMassRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void UpdateObjectMassRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateObjectMassRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.UpdateObjectMassRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.mass_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateObjectMassRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.UpdateObjectMassRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // float mass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateObjectMassRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.UpdateObjectMassRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.UpdateObjectMassRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_mass(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.UpdateObjectMassRequest)
  return target;
}

size_t UpdateObjectMassRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.UpdateObjectMassRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateObjectMassRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateObjectMassRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateObjectMassRequest::GetClassData() const { return &_class_data_; }


void UpdateObjectMassRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateObjectMassRequest*>(&to_msg);
  auto& from = static_cast<const UpdateObjectMassRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.UpdateObjectMassRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = from._internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    _this->_internal_set_mass(from._internal_mass());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateObjectMassRequest::CopyFrom(const UpdateObjectMassRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.UpdateObjectMassRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateObjectMassRequest::IsInitialized() const {
  return true;
}

void UpdateObjectMassRequest::InternalSwap(UpdateObjectMassRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  swap(_impl_.mass_, other->_impl_.mass_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateObjectMassRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[15]);
}

// ===================================================================

class UpdateObjectMassResponse::_Internal {
 public:
};

UpdateObjectMassResponse::UpdateObjectMassResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.UpdateObjectMassResponse)
}
UpdateObjectMassResponse::UpdateObjectMassResponse(const UpdateObjectMassResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateObjectMassResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.UpdateObjectMassResponse)
}

inline void UpdateObjectMassResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateObjectMassResponse::~UpdateObjectMassResponse() {
  // @@protoc_insertion_point(destructor:physics.UpdateObjectMassResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateObjectMassResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void UpdateObjectMassResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateObjectMassResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.UpdateObjectMassResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateObjectMassResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.UpdateObjectMassResponse.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateObjectMassResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.UpdateObjectMassResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.UpdateObjectMassResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.UpdateObjectMassResponse)
  return target;
}

size_t UpdateObjectMassResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.UpdateObjectMassResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateObjectMassResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateObjectMassResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateObjectMassResponse::GetClassData() const { return &_class_data_; }


void UpdateObjectMassResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateObjectMassResponse*>(&to_msg);
  auto& from = static_cast<const UpdateObjectMassResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.UpdateObjectMassResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateObjectMassResponse::CopyFrom(const UpdateObjectMassResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.UpdateObjectMassResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateObjectMassResponse::IsInitialized() const {
  return true;
}

void UpdateObjectMassResponse::InternalSwap(UpdateObjectMassResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateObjectMassResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[16]);
}

// ===================================================================

class PhysicsConfig::_Internal {
 public:
};

PhysicsConfig::PhysicsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.PhysicsConfig)
}
PhysicsConfig::PhysicsConfig(const PhysicsConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhysicsConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_impulse_){}
    , decltype(_impl_.max_impulse_){}
    , decltype(_impl_.distance_multiplier_){}
    , decltype(_impl_.impulse_multiplier_){}
    , decltype(_impl_.player_mass_){}
    , decltype(_impl_.default_box_mass_){}
    , decltype(_impl_.restitution_){}
    , decltype(_impl_.friction_){}
    , decltype(_impl_.gravity_x_){}
    , decltype(_impl_.gravity_y_){}
    , decltype(_impl_.gravity_z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.base_impulse_, &from._impl_.base_impulse_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gravity_z_) -
    reinterpret_cast<char*>(&_impl_.base_impulse_)) + sizeof(_impl_.gravity_z_));
  // @@protoc_insertion_point(copy_constructor:physics.PhysicsConfig)
}

inline void PhysicsConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_impulse_){0}
    , decltype(_impl_.max_impulse_){0}
    , decltype(_impl_.distance_multiplier_){0}
    , decltype(_impl_.impulse_multiplier_){0}
    , decltype(_impl_.player_mass_){0}
    , decltype(_impl_.default_box_mass_){0}
    , decltype(_impl_.restitution_){0}
    , decltype(_impl_.friction_){0}
    , decltype(_impl_.gravity_x_){0}
    , decltype(_impl_.gravity_y_){0}
    , decltype(_impl_.gravity_z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhysicsConfig::~PhysicsConfig() {
  // @@protoc_insertion_point(destructor:physics.PhysicsConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhysicsConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PhysicsConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhysicsConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.PhysicsConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.base_impulse_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.gravity_z_) -
      reinterpret_cast<char*>(&_impl_.base_impulse_)) + sizeof(_impl_.gravity_z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhysicsConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float base_impulse = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.base_impulse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float max_impulse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.max_impulse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float distance_multiplier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.distance_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float impulse_multiplier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.impulse_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float player_mass = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.player_mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float default_box_mass = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.default_box_mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float restitution = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.restitution_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float friction = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.friction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float gravity_x = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.gravity_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float gravity_y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.gravity_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float gravity_z = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.gravity_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PhysicsConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.PhysicsConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float base_impulse = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_base_impulse = this->_internal_base_impulse();
  uint32_t raw_base_impulse;
  memcpy(&raw_base_impulse, &tmp_base_impulse, sizeof(tmp_base_impulse));
  if (raw_base_impulse != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_base_impulse(), target);
  }

  // float max_impulse = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_impulse = this->_internal_max_impulse();
  uint32_t raw_max_impulse;
  memcpy(&raw_max_impulse, &tmp_max_impulse, sizeof(tmp_max_impulse));
  if (raw_max_impulse != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_max_impulse(), target);
  }

  // float distance_multiplier = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_multiplier = this->_internal_distance_multiplier();
  uint32_t raw_distance_multiplier;
  memcpy(&raw_distance_multiplier, &tmp_distance_multiplier, sizeof(tmp_distance_multiplier));
  if (raw_distance_multiplier != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_distance_multiplier(), target);
  }

  // float impulse_multiplier = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_impulse_multiplier = this->_internal_impulse_multiplier();
  uint32_t raw_impulse_multiplier;
  memcpy(&raw_impulse_multiplier, &tmp_impulse_multiplier, sizeof(tmp_impulse_multiplier));
  if (raw_impulse_multiplier != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_impulse_multiplier(), target);
  }

  // float player_mass = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_player_mass = this->_internal_player_mass();
  uint32_t raw_player_mass;
  memcpy(&raw_player_mass, &tmp_player_mass, sizeof(tmp_player_mass));
  if (raw_player_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_player_mass(), target);
  }

  // float default_box_mass = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_box_mass = this->_internal_default_box_mass();
  uint32_t raw_default_box_mass;
  memcpy(&raw_default_box_mass, &tmp_default_box_mass, sizeof(tmp_default_box_mass));
  if (raw_default_box_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_default_box_mass(), target);
  }

  // float restitution = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_restitution = this->_internal_restitution();
  uint32_t raw_restitution;
  memcpy(&raw_restitution, &tmp_restitution, sizeof(tmp_restitution));
  if (raw_restitution != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_restitution(), target);
  }

  // float friction = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_friction = this->_internal_friction();
  uint32_t raw_friction;
  memcpy(&raw_friction, &tmp_friction, sizeof(tmp_friction));
  if (raw_friction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_friction(), target);
  }

  // float gravity_x = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_x = this->_internal_gravity_x();
  uint32_t raw_gravity_x;
  memcpy(&raw_gravity_x, &tmp_gravity_x, sizeof(tmp_gravity_x));
  if (raw_gravity_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_gravity_x(), target);
  }

  // float gravity_y = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_y = this->_internal_gravity_y();
  uint32_t raw_gravity_y;
  memcpy(&raw_gravity_y, &tmp_gravity_y, sizeof(tmp_gravity_y));
  if (raw_gravity_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_gravity_y(), target);
  }

  // float gravity_z = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_z = this->_internal_gravity_z();
  uint32_t raw_gravity_z;
  memcpy(&raw_gravity_z, &tmp_gravity_z, sizeof(tmp_gravity_z));
  if (raw_gravity_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_gravity_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.PhysicsConfig)
  return target;
}

size_t PhysicsConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.PhysicsConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float base_impulse = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_base_impulse = this->_internal_base_impulse();
  uint32_t raw_base_impulse;
  memcpy(&raw_base_impulse, &tmp_base_impulse, sizeof(tmp_base_impulse));
  if (raw_base_impulse != 0) {
    total_size += 1 + 4;
  }

  // float max_impulse = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_impulse = this->_internal_max_impulse();
  uint32_t raw_max_impulse;
  memcpy(&raw_max_impulse, &tmp_max_impulse, sizeof(tmp_max_impulse));
  if (raw_max_impulse != 0) {
    total_size += 1 + 4;
  }

  // float distance_multiplier = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_multiplier = this->_internal_distance_multiplier();
  uint32_t raw_distance_multiplier;
  memcpy(&raw_distance_multiplier, &tmp_distance_multiplier, sizeof(tmp_distance_multiplier));
  if (raw_distance_multiplier != 0) {
    total_size += 1 + 4;
  }

  // float impulse_multiplier = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_impulse_multiplier = this->_internal_impulse_multiplier();
  uint32_t raw_impulse_multiplier;
  memcpy(&raw_impulse_multiplier, &tmp_impulse_multiplier, sizeof(tmp_impulse_multiplier));
  if (raw_impulse_multiplier != 0) {
    total_size += 1 + 4;
  }

  // float player_mass = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_player_mass = this->_internal_player_mass();
  uint32_t raw_player_mass;
  memcpy(&raw_player_mass, &tmp_player_mass, sizeof(tmp_player_mass));
  if (raw_player_mass != 0) {
    total_size += 1 + 4;
  }

  // float default_box_mass = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_box_mass = this->_internal_default_box_mass();
  uint32_t raw_default_box_mass;
  memcpy(&raw_default_box_mass, &tmp_default_box_mass, sizeof(tmp_default_box_mass));
  if (raw_default_box_mass != 0) {
    total_size += 1 + 4;
  }

  // float restitution = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_restitution = this->_internal_restitution();
  uint32_t raw_restitution;
  memcpy(&raw_restitution, &tmp_restitution, sizeof(tmp_restitution));
  if (raw_restitution != 0) {
    total_size += 1 + 4;
  }

  // float friction = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_friction = this->_internal_friction();
  uint32_t raw_friction;
  memcpy(&raw_friction, &tmp_friction, sizeof(tmp_friction));
  if (raw_friction != 0) {
    total_size += 1 + 4;
  }

  // float gravity_x = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_x = this->_internal_gravity_x();
  uint32_t raw_gravity_x;
  memcpy(&raw_gravity_x, &tmp_gravity_x, sizeof(tmp_gravity_x));
  if (raw_gravity_x != 0) {
    total_size += 1 + 4;
  }

  // float gravity_y = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_y = this->_internal_gravity_y();
  uint32_t raw_gravity_y;
  memcpy(&raw_gravity_y, &tmp_gravity_y, sizeof(tmp_gravity_y));
  if (raw_gravity_y != 0) {
    total_size += 1 + 4;
  }

  // float gravity_z = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_z = this->_internal_gravity_z();
  uint32_t raw_gravity_z;
  memcpy(&raw_gravity_z, &tmp_gravity_z, sizeof(tmp_gravity_z));
  if (raw_gravity_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhysicsConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhysicsConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhysicsConfig::GetClassData() const { return &_class_data_; }


void PhysicsConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhysicsConfig*>(&to_msg);
  auto& from = static_cast<const PhysicsConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.PhysicsConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_base_impulse = from._internal_base_impulse();
  uint32_t raw_base_impulse;
  memcpy(&raw_base_impulse, &tmp_base_impulse, sizeof(tmp_base_impulse));
  if (raw_base_impulse != 0) {
    _this->_internal_set_base_impulse(from._internal_base_impulse());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_impulse = from._internal_max_impulse();
  uint32_t raw_max_impulse;
  memcpy(&raw_max_impulse, &tmp_max_impulse, sizeof(tmp_max_impulse));
  if (raw_max_impulse != 0) {
    _this->_internal_set_max_impulse(from._internal_max_impulse());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_multiplier = from._internal_distance_multiplier();
  uint32_t raw_distance_multiplier;
  memcpy(&raw_distance_multiplier, &tmp_distance_multiplier, sizeof(tmp_distance_multiplier));
  if (raw_distance_multiplier != 0) {
    _this->_internal_set_distance_multiplier(from._internal_distance_multiplier());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_impulse_multiplier = from._internal_impulse_multiplier();
  uint32_t raw_impulse_multiplier;
  memcpy(&raw_impulse_multiplier, &tmp_impulse_multiplier, sizeof(tmp_impulse_multiplier));
  if (raw_impulse_multiplier != 0) {
    _this->_internal_set_impulse_multiplier(from._internal_impulse_multiplier());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_player_mass = from._internal_player_mass();
  uint32_t raw_player_mass;
  memcpy(&raw_player_mass, &tmp_player_mass, sizeof(tmp_player_mass));
  if (raw_player_mass != 0) {
    _this->_internal_set_player_mass(from._internal_player_mass());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_box_mass = from._internal_default_box_mass();
  uint32_t raw_default_box_mass;
  memcpy(&raw_default_box_mass, &tmp_default_box_mass, sizeof(tmp_default_box_mass));
  if (raw_default_box_mass != 0) {
    _this->_internal_set_default_box_mass(from._internal_default_box_mass());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_restitution = from._internal_restitution();
  uint32_t raw_restitution;
  memcpy(&raw_restitution, &tmp_restitution, sizeof(tmp_restitution));
  if (raw_restitution != 0) {
    _this->_internal_set_restitution(from._internal_restitution());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_friction = from._internal_friction();
  uint32_t raw_friction;
  memcpy(&raw_friction, &tmp_friction, sizeof(tmp_friction));
  if (raw_friction != 0) {
    _this->_internal_set_friction(from._internal_friction());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_x = from._internal_gravity_x();
  uint32_t raw_gravity_x;
  memcpy(&raw_gravity_x, &tmp_gravity_x, sizeof(tmp_gravity_x));
  if (raw_gravity_x != 0) {
    _this->_internal_set_gravity_x(from._internal_gravity_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_y = from._internal_gravity_y();
  uint32_t raw_gravity_y;
  memcpy(&raw_gravity_y, &tmp_gravity_y, sizeof(tmp_gravity_y));
  if (raw_gravity_y != 0) {
    _this->_internal_set_gravity_y(from._internal_gravity_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_gravity_z = from._internal_gravity_z();
  uint32_t raw_gravity_z;
  memcpy(&raw_gravity_z, &tmp_gravity_z, sizeof(tmp_gravity_z));
  if (raw_gravity_z != 0) {
    _this->_internal_set_gravity_z(from._internal_gravity_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhysicsConfig::CopyFrom(const PhysicsConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.PhysicsConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicsConfig::IsInitialized() const {
  return true;
}

void PhysicsConfig::InternalSwap(PhysicsConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhysicsConfig, _impl_.gravity_z_)
      + sizeof(PhysicsConfig::_impl_.gravity_z_)
      - PROTOBUF_FIELD_OFFSET(PhysicsConfig, _impl_.base_impulse_)>(
          reinterpret_cast<char*>(&_impl_.base_impulse_),
          reinterpret_cast<char*>(&other->_impl_.base_impulse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhysicsConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[17]);
}

// ===================================================================

class SetPhysicsConfigRequest::_Internal {
 public:
  static const ::physics::PhysicsConfig& config(const SetPhysicsConfigRequest* msg);
};

const ::physics::PhysicsConfig&
SetPhysicsConfigRequest::_Internal::config(const SetPhysicsConfigRequest* msg) {
  return *msg->_impl_.config_;
}
SetPhysicsConfigRequest::SetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.SetPhysicsConfigRequest)
}
SetPhysicsConfigRequest::SetPhysicsConfigRequest(const SetPhysicsConfigRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetPhysicsConfigRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.config_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    _this->_impl_.config_ = new ::physics::PhysicsConfig(*from._impl_.config_);
  }
  // @@protoc_insertion_point(copy_constructor:physics.SetPhysicsConfigRequest)
}

inline void SetPhysicsConfigRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.config_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetPhysicsConfigRequest::~SetPhysicsConfigRequest() {
  // @@protoc_insertion_point(destructor:physics.SetPhysicsConfigRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetPhysicsConfigRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.config_;
}

void SetPhysicsConfigRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetPhysicsConfigRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.SetPhysicsConfigRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetPhysicsConfigRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .physics.PhysicsConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetPhysicsConfigRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.SetPhysicsConfigRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .physics.PhysicsConfig config = 1;
  if (this->_internal_has_config()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.SetPhysicsConfigRequest)
  return target;
}

size_t SetPhysicsConfigRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.SetPhysicsConfigRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .physics.PhysicsConfig config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetPhysicsConfigRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetPhysicsConfigRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetPhysicsConfigRequest::GetClassData() const { return &_class_data_; }


void SetPhysicsConfigRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetPhysicsConfigRequest*>(&to_msg);
  auto& from = static_cast<const SetPhysicsConfigRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.SetPhysicsConfigRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _this->_internal_mutable_config()->::physics::PhysicsConfig::MergeFrom(
        from._internal_config());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetPhysicsConfigRequest::CopyFrom(const SetPhysicsConfigRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.SetPhysicsConfigRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPhysicsConfigRequest::IsInitialized() const {
  return true;
}

void SetPhysicsConfigRequest::InternalSwap(SetPhysicsConfigRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.config_, other->_impl_.config_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetPhysicsConfigRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[18]);
}

// ===================================================================

class SetPhysicsConfigResponse::_Internal {
 public:
};

SetPhysicsConfigResponse::SetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:physics.SetPhysicsConfigResponse)
}
SetPhysicsConfigResponse::SetPhysicsConfigResponse(const SetPhysicsConfigResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetPhysicsConfigResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:physics.SetPhysicsConfigResponse)
}

inline void SetPhysicsConfigResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetPhysicsConfigResponse::~SetPhysicsConfigResponse() {
  // @@protoc_insertion_point(destructor:physics.SetPhysicsConfigResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetPhysicsConfigResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void SetPhysicsConfigResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetPhysicsConfigResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:physics.SetPhysicsConfigResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetPhysicsConfigResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "physics.SetPhysicsConfigResponse.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetPhysicsConfigResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:physics.SetPhysicsConfigResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "physics.SetPhysicsConfigResponse.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:physics.SetPhysicsConfigResponse)
  return target;
}

size_t SetPhysicsConfigResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:physics.SetPhysicsConfigResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetPhysicsConfigResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetPhysicsConfigResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetPhysicsConfigResponse::GetClassData() const { return &_class_data_; }


void SetPhysicsConfigResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetPhysicsConfigResponse*>(&to_msg);
  auto& from = static_cast<const SetPhysicsConfigResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:physics.SetPhysicsConfigResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetPhysicsConfigResponse::CopyFrom(const SetPhysicsConfigResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:physics.SetPhysicsConfigResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPhysicsConfigResponse::IsInitialized() const {
  return true;
}

void SetPhysicsConfigResponse::InternalSwap(SetPhysicsConfigResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SetPhysicsConfigResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_physics_2eproto_getter, &descriptor_table_physics_2eproto_once,
      file_level_metadata_physics_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace physics
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::physics::Vector3*
Arena::CreateMaybeMessage< ::physics::Vector3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::Vector3 >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::Quaternion*
Arena::CreateMaybeMessage< ::physics::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ShapeDescriptor*
Arena::CreateMaybeMessage< ::physics::ShapeDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ShapeDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::SphereData*
Arena::CreateMaybeMessage< ::physics::SphereData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::SphereData >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::BoxData*
Arena::CreateMaybeMessage< ::physics::BoxData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::BoxData >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::TerrainData*
Arena::CreateMaybeMessage< ::physics::TerrainData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::TerrainData >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::CreateObjectRequest*
Arena::CreateMaybeMessage< ::physics::CreateObjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::CreateObjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::CreateObjectResponse*
Arena::CreateMaybeMessage< ::physics::CreateObjectResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::CreateObjectResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ApplyImpulseRequest*
Arena::CreateMaybeMessage< ::physics::ApplyImpulseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ApplyImpulseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ApplyImpulseResponse*
Arena::CreateMaybeMessage< ::physics::ApplyImpulseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ApplyImpulseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ApplyTorqueRequest*
Arena::CreateMaybeMessage< ::physics::ApplyTorqueRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ApplyTorqueRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ApplyTorqueResponse*
Arena::CreateMaybeMessage< ::physics::ApplyTorqueResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ApplyTorqueResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::GetObjectStateRequest*
Arena::CreateMaybeMessage< ::physics::GetObjectStateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::GetObjectStateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::ObjectState*
Arena::CreateMaybeMessage< ::physics::ObjectState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::ObjectState >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::GetObjectStateResponse*
Arena::CreateMaybeMessage< ::physics::GetObjectStateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::GetObjectStateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::UpdateObjectMassRequest*
Arena::CreateMaybeMessage< ::physics::UpdateObjectMassRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::UpdateObjectMassRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::UpdateObjectMassResponse*
Arena::CreateMaybeMessage< ::physics::UpdateObjectMassResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::UpdateObjectMassResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::PhysicsConfig*
Arena::CreateMaybeMessage< ::physics::PhysicsConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::PhysicsConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::SetPhysicsConfigRequest*
Arena::CreateMaybeMessage< ::physics::SetPhysicsConfigRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::SetPhysicsConfigRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::physics::SetPhysicsConfigResponse*
Arena::CreateMaybeMessage< ::physics::SetPhysicsConfigResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::physics::SetPhysicsConfigResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
