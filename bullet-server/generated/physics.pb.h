// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: physics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_physics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_physics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_physics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_physics_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_physics_2eproto;
namespace physics {
class ApplyImpulseRequest;
struct ApplyImpulseRequestDefaultTypeInternal;
extern ApplyImpulseRequestDefaultTypeInternal _ApplyImpulseRequest_default_instance_;
class ApplyImpulseResponse;
struct ApplyImpulseResponseDefaultTypeInternal;
extern ApplyImpulseResponseDefaultTypeInternal _ApplyImpulseResponse_default_instance_;
class ApplyTorqueRequest;
struct ApplyTorqueRequestDefaultTypeInternal;
extern ApplyTorqueRequestDefaultTypeInternal _ApplyTorqueRequest_default_instance_;
class ApplyTorqueResponse;
struct ApplyTorqueResponseDefaultTypeInternal;
extern ApplyTorqueResponseDefaultTypeInternal _ApplyTorqueResponse_default_instance_;
class BoxData;
struct BoxDataDefaultTypeInternal;
extern BoxDataDefaultTypeInternal _BoxData_default_instance_;
class ControlConfig;
struct ControlConfigDefaultTypeInternal;
extern ControlConfigDefaultTypeInternal _ControlConfig_default_instance_;
class CreateObjectRequest;
struct CreateObjectRequestDefaultTypeInternal;
extern CreateObjectRequestDefaultTypeInternal _CreateObjectRequest_default_instance_;
class CreateObjectResponse;
struct CreateObjectResponseDefaultTypeInternal;
extern CreateObjectResponseDefaultTypeInternal _CreateObjectResponse_default_instance_;
class GetObjectStateRequest;
struct GetObjectStateRequestDefaultTypeInternal;
extern GetObjectStateRequestDefaultTypeInternal _GetObjectStateRequest_default_instance_;
class GetObjectStateResponse;
struct GetObjectStateResponseDefaultTypeInternal;
extern GetObjectStateResponseDefaultTypeInternal _GetObjectStateResponse_default_instance_;
class ObjectState;
struct ObjectStateDefaultTypeInternal;
extern ObjectStateDefaultTypeInternal _ObjectState_default_instance_;
class PhysicsConfig;
struct PhysicsConfigDefaultTypeInternal;
extern PhysicsConfigDefaultTypeInternal _PhysicsConfig_default_instance_;
class PlayerConfig;
struct PlayerConfigDefaultTypeInternal;
extern PlayerConfigDefaultTypeInternal _PlayerConfig_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SetPhysicsConfigRequest;
struct SetPhysicsConfigRequestDefaultTypeInternal;
extern SetPhysicsConfigRequestDefaultTypeInternal _SetPhysicsConfigRequest_default_instance_;
class SetPhysicsConfigResponse;
struct SetPhysicsConfigResponseDefaultTypeInternal;
extern SetPhysicsConfigResponseDefaultTypeInternal _SetPhysicsConfigResponse_default_instance_;
class ShapeDescriptor;
struct ShapeDescriptorDefaultTypeInternal;
extern ShapeDescriptorDefaultTypeInternal _ShapeDescriptor_default_instance_;
class SphereData;
struct SphereDataDefaultTypeInternal;
extern SphereDataDefaultTypeInternal _SphereData_default_instance_;
class TerrainData;
struct TerrainDataDefaultTypeInternal;
extern TerrainDataDefaultTypeInternal _TerrainData_default_instance_;
class UpdateObjectMassAndRadiusRequest;
struct UpdateObjectMassAndRadiusRequestDefaultTypeInternal;
extern UpdateObjectMassAndRadiusRequestDefaultTypeInternal _UpdateObjectMassAndRadiusRequest_default_instance_;
class UpdateObjectMassAndRadiusResponse;
struct UpdateObjectMassAndRadiusResponseDefaultTypeInternal;
extern UpdateObjectMassAndRadiusResponseDefaultTypeInternal _UpdateObjectMassAndRadiusResponse_default_instance_;
class UpdateObjectMassRequest;
struct UpdateObjectMassRequestDefaultTypeInternal;
extern UpdateObjectMassRequestDefaultTypeInternal _UpdateObjectMassRequest_default_instance_;
class UpdateObjectMassResponse;
struct UpdateObjectMassResponseDefaultTypeInternal;
extern UpdateObjectMassResponseDefaultTypeInternal _UpdateObjectMassResponse_default_instance_;
class UpdateObjectRadiusRequest;
struct UpdateObjectRadiusRequestDefaultTypeInternal;
extern UpdateObjectRadiusRequestDefaultTypeInternal _UpdateObjectRadiusRequest_default_instance_;
class UpdateObjectRadiusResponse;
struct UpdateObjectRadiusResponseDefaultTypeInternal;
extern UpdateObjectRadiusResponseDefaultTypeInternal _UpdateObjectRadiusResponse_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class WorldPhysicsConfig;
struct WorldPhysicsConfigDefaultTypeInternal;
extern WorldPhysicsConfigDefaultTypeInternal _WorldPhysicsConfig_default_instance_;
}  // namespace physics
PROTOBUF_NAMESPACE_OPEN
template<> ::physics::ApplyImpulseRequest* Arena::CreateMaybeMessage<::physics::ApplyImpulseRequest>(Arena*);
template<> ::physics::ApplyImpulseResponse* Arena::CreateMaybeMessage<::physics::ApplyImpulseResponse>(Arena*);
template<> ::physics::ApplyTorqueRequest* Arena::CreateMaybeMessage<::physics::ApplyTorqueRequest>(Arena*);
template<> ::physics::ApplyTorqueResponse* Arena::CreateMaybeMessage<::physics::ApplyTorqueResponse>(Arena*);
template<> ::physics::BoxData* Arena::CreateMaybeMessage<::physics::BoxData>(Arena*);
template<> ::physics::ControlConfig* Arena::CreateMaybeMessage<::physics::ControlConfig>(Arena*);
template<> ::physics::CreateObjectRequest* Arena::CreateMaybeMessage<::physics::CreateObjectRequest>(Arena*);
template<> ::physics::CreateObjectResponse* Arena::CreateMaybeMessage<::physics::CreateObjectResponse>(Arena*);
template<> ::physics::GetObjectStateRequest* Arena::CreateMaybeMessage<::physics::GetObjectStateRequest>(Arena*);
template<> ::physics::GetObjectStateResponse* Arena::CreateMaybeMessage<::physics::GetObjectStateResponse>(Arena*);
template<> ::physics::ObjectState* Arena::CreateMaybeMessage<::physics::ObjectState>(Arena*);
template<> ::physics::PhysicsConfig* Arena::CreateMaybeMessage<::physics::PhysicsConfig>(Arena*);
template<> ::physics::PlayerConfig* Arena::CreateMaybeMessage<::physics::PlayerConfig>(Arena*);
template<> ::physics::Quaternion* Arena::CreateMaybeMessage<::physics::Quaternion>(Arena*);
template<> ::physics::SetPhysicsConfigRequest* Arena::CreateMaybeMessage<::physics::SetPhysicsConfigRequest>(Arena*);
template<> ::physics::SetPhysicsConfigResponse* Arena::CreateMaybeMessage<::physics::SetPhysicsConfigResponse>(Arena*);
template<> ::physics::ShapeDescriptor* Arena::CreateMaybeMessage<::physics::ShapeDescriptor>(Arena*);
template<> ::physics::SphereData* Arena::CreateMaybeMessage<::physics::SphereData>(Arena*);
template<> ::physics::TerrainData* Arena::CreateMaybeMessage<::physics::TerrainData>(Arena*);
template<> ::physics::UpdateObjectMassAndRadiusRequest* Arena::CreateMaybeMessage<::physics::UpdateObjectMassAndRadiusRequest>(Arena*);
template<> ::physics::UpdateObjectMassAndRadiusResponse* Arena::CreateMaybeMessage<::physics::UpdateObjectMassAndRadiusResponse>(Arena*);
template<> ::physics::UpdateObjectMassRequest* Arena::CreateMaybeMessage<::physics::UpdateObjectMassRequest>(Arena*);
template<> ::physics::UpdateObjectMassResponse* Arena::CreateMaybeMessage<::physics::UpdateObjectMassResponse>(Arena*);
template<> ::physics::UpdateObjectRadiusRequest* Arena::CreateMaybeMessage<::physics::UpdateObjectRadiusRequest>(Arena*);
template<> ::physics::UpdateObjectRadiusResponse* Arena::CreateMaybeMessage<::physics::UpdateObjectRadiusResponse>(Arena*);
template<> ::physics::Vector3* Arena::CreateMaybeMessage<::physics::Vector3>(Arena*);
template<> ::physics::WorldPhysicsConfig* Arena::CreateMaybeMessage<::physics::WorldPhysicsConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace physics {

enum ShapeDescriptor_ShapeType : int {
  ShapeDescriptor_ShapeType_UNKNOWN = 0,
  ShapeDescriptor_ShapeType_SPHERE = 1,
  ShapeDescriptor_ShapeType_BOX = 2,
  ShapeDescriptor_ShapeType_TERRAIN = 3,
  ShapeDescriptor_ShapeType_ShapeDescriptor_ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeDescriptor_ShapeType_ShapeDescriptor_ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeDescriptor_ShapeType_IsValid(int value);
constexpr ShapeDescriptor_ShapeType ShapeDescriptor_ShapeType_ShapeType_MIN = ShapeDescriptor_ShapeType_UNKNOWN;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor_ShapeType_ShapeType_MAX = ShapeDescriptor_ShapeType_TERRAIN;
constexpr int ShapeDescriptor_ShapeType_ShapeType_ARRAYSIZE = ShapeDescriptor_ShapeType_ShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeDescriptor_ShapeType_descriptor();
template<typename T>
inline const std::string& ShapeDescriptor_ShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeDescriptor_ShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeDescriptor_ShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeDescriptor_ShapeType_descriptor(), enum_t_value);
}
inline bool ShapeDescriptor_ShapeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeDescriptor_ShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeDescriptor_ShapeType>(
    ShapeDescriptor_ShapeType_descriptor(), name, value);
}
// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ShapeDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ShapeDescriptor) */ {
 public:
  inline ShapeDescriptor() : ShapeDescriptor(nullptr) {}
  ~ShapeDescriptor() override;
  explicit PROTOBUF_CONSTEXPR ShapeDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeDescriptor(const ShapeDescriptor& from);
  ShapeDescriptor(ShapeDescriptor&& from) noexcept
    : ShapeDescriptor() {
    *this = ::std::move(from);
  }

  inline ShapeDescriptor& operator=(const ShapeDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeDescriptor& operator=(ShapeDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeDescriptor& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeCase {
    kSphere = 10,
    kBox = 11,
    kTerrain = 12,
    SHAPE_NOT_SET = 0,
  };

  static inline const ShapeDescriptor* internal_default_instance() {
    return reinterpret_cast<const ShapeDescriptor*>(
               &_ShapeDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ShapeDescriptor& a, ShapeDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeDescriptor& from) {
    ShapeDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ShapeDescriptor";
  }
  protected:
  explicit ShapeDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShapeDescriptor_ShapeType ShapeType;
  static constexpr ShapeType UNKNOWN =
    ShapeDescriptor_ShapeType_UNKNOWN;
  static constexpr ShapeType SPHERE =
    ShapeDescriptor_ShapeType_SPHERE;
  static constexpr ShapeType BOX =
    ShapeDescriptor_ShapeType_BOX;
  static constexpr ShapeType TERRAIN =
    ShapeDescriptor_ShapeType_TERRAIN;
  static inline bool ShapeType_IsValid(int value) {
    return ShapeDescriptor_ShapeType_IsValid(value);
  }
  static constexpr ShapeType ShapeType_MIN =
    ShapeDescriptor_ShapeType_ShapeType_MIN;
  static constexpr ShapeType ShapeType_MAX =
    ShapeDescriptor_ShapeType_ShapeType_MAX;
  static constexpr int ShapeType_ARRAYSIZE =
    ShapeDescriptor_ShapeType_ShapeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShapeType_descriptor() {
    return ShapeDescriptor_ShapeType_descriptor();
  }
  template<typename T>
  static inline const std::string& ShapeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShapeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShapeType_Name.");
    return ShapeDescriptor_ShapeType_Name(enum_t_value);
  }
  static inline bool ShapeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShapeType* value) {
    return ShapeDescriptor_ShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSphereFieldNumber = 10,
    kBoxFieldNumber = 11,
    kTerrainFieldNumber = 12,
  };
  // .physics.ShapeDescriptor.ShapeType type = 1;
  void clear_type();
  ::physics::ShapeDescriptor_ShapeType type() const;
  void set_type(::physics::ShapeDescriptor_ShapeType value);
  private:
  ::physics::ShapeDescriptor_ShapeType _internal_type() const;
  void _internal_set_type(::physics::ShapeDescriptor_ShapeType value);
  public:

  // .physics.SphereData sphere = 10;
  bool has_sphere() const;
  private:
  bool _internal_has_sphere() const;
  public:
  void clear_sphere();
  const ::physics::SphereData& sphere() const;
  PROTOBUF_NODISCARD ::physics::SphereData* release_sphere();
  ::physics::SphereData* mutable_sphere();
  void set_allocated_sphere(::physics::SphereData* sphere);
  private:
  const ::physics::SphereData& _internal_sphere() const;
  ::physics::SphereData* _internal_mutable_sphere();
  public:
  void unsafe_arena_set_allocated_sphere(
      ::physics::SphereData* sphere);
  ::physics::SphereData* unsafe_arena_release_sphere();

  // .physics.BoxData box = 11;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::physics::BoxData& box() const;
  PROTOBUF_NODISCARD ::physics::BoxData* release_box();
  ::physics::BoxData* mutable_box();
  void set_allocated_box(::physics::BoxData* box);
  private:
  const ::physics::BoxData& _internal_box() const;
  ::physics::BoxData* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::physics::BoxData* box);
  ::physics::BoxData* unsafe_arena_release_box();

  // .physics.TerrainData terrain = 12;
  bool has_terrain() const;
  private:
  bool _internal_has_terrain() const;
  public:
  void clear_terrain();
  const ::physics::TerrainData& terrain() const;
  PROTOBUF_NODISCARD ::physics::TerrainData* release_terrain();
  ::physics::TerrainData* mutable_terrain();
  void set_allocated_terrain(::physics::TerrainData* terrain);
  private:
  const ::physics::TerrainData& _internal_terrain() const;
  ::physics::TerrainData* _internal_mutable_terrain();
  public:
  void unsafe_arena_set_allocated_terrain(
      ::physics::TerrainData* terrain);
  ::physics::TerrainData* unsafe_arena_release_terrain();

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:physics.ShapeDescriptor)
 private:
  class _Internal;
  void set_has_sphere();
  void set_has_box();
  void set_has_terrain();

  inline bool has_shape() const;
  inline void clear_has_shape();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union ShapeUnion {
      constexpr ShapeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::physics::SphereData* sphere_;
      ::physics::BoxData* box_;
      ::physics::TerrainData* terrain_;
    } shape_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SphereData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SphereData) */ {
 public:
  inline SphereData() : SphereData(nullptr) {}
  ~SphereData() override;
  explicit PROTOBUF_CONSTEXPR SphereData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SphereData(const SphereData& from);
  SphereData(SphereData&& from) noexcept
    : SphereData() {
    *this = ::std::move(from);
  }

  inline SphereData& operator=(const SphereData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SphereData& operator=(SphereData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SphereData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SphereData* internal_default_instance() {
    return reinterpret_cast<const SphereData*>(
               &_SphereData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SphereData& a, SphereData& b) {
    a.Swap(&b);
  }
  inline void Swap(SphereData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SphereData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SphereData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SphereData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SphereData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SphereData& from) {
    SphereData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SphereData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SphereData";
  }
  protected:
  explicit SphereData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 3,
    kRadiusFieldNumber = 1,
    kMassFieldNumber = 2,
    kRestitutionFieldNumber = 4,
    kFrictionFieldNumber = 5,
    kRollingFrictionFieldNumber = 6,
    kLinearDampingFieldNumber = 7,
    kAngularDampingFieldNumber = 8,
  };
  // string color = 3;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float radius = 1;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float mass = 2;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // float restitution = 4;
  void clear_restitution();
  float restitution() const;
  void set_restitution(float value);
  private:
  float _internal_restitution() const;
  void _internal_set_restitution(float value);
  public:

  // float friction = 5;
  void clear_friction();
  float friction() const;
  void set_friction(float value);
  private:
  float _internal_friction() const;
  void _internal_set_friction(float value);
  public:

  // float rolling_friction = 6;
  void clear_rolling_friction();
  float rolling_friction() const;
  void set_rolling_friction(float value);
  private:
  float _internal_rolling_friction() const;
  void _internal_set_rolling_friction(float value);
  public:

  // float linear_damping = 7;
  void clear_linear_damping();
  float linear_damping() const;
  void set_linear_damping(float value);
  private:
  float _internal_linear_damping() const;
  void _internal_set_linear_damping(float value);
  public:

  // float angular_damping = 8;
  void clear_angular_damping();
  float angular_damping() const;
  void set_angular_damping(float value);
  private:
  float _internal_angular_damping() const;
  void _internal_set_angular_damping(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.SphereData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float radius_;
    float mass_;
    float restitution_;
    float friction_;
    float rolling_friction_;
    float linear_damping_;
    float angular_damping_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class BoxData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.BoxData) */ {
 public:
  inline BoxData() : BoxData(nullptr) {}
  ~BoxData() override;
  explicit PROTOBUF_CONSTEXPR BoxData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxData(const BoxData& from);
  BoxData(BoxData&& from) noexcept
    : BoxData() {
    *this = ::std::move(from);
  }

  inline BoxData& operator=(const BoxData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxData& operator=(BoxData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxData* internal_default_instance() {
    return reinterpret_cast<const BoxData*>(
               &_BoxData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BoxData& a, BoxData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxData& from) {
    BoxData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.BoxData";
  }
  protected:
  explicit BoxData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
    kMassFieldNumber = 4,
    kRestitutionFieldNumber = 6,
    kFrictionFieldNumber = 7,
    kRollingFrictionFieldNumber = 8,
    kLinearDampingFieldNumber = 9,
    kAngularDampingFieldNumber = 10,
  };
  // string color = 5;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float width = 1;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 2;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float depth = 3;
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // float mass = 4;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // float restitution = 6;
  void clear_restitution();
  float restitution() const;
  void set_restitution(float value);
  private:
  float _internal_restitution() const;
  void _internal_set_restitution(float value);
  public:

  // float friction = 7;
  void clear_friction();
  float friction() const;
  void set_friction(float value);
  private:
  float _internal_friction() const;
  void _internal_set_friction(float value);
  public:

  // float rolling_friction = 8;
  void clear_rolling_friction();
  float rolling_friction() const;
  void set_rolling_friction(float value);
  private:
  float _internal_rolling_friction() const;
  void _internal_set_rolling_friction(float value);
  public:

  // float linear_damping = 9;
  void clear_linear_damping();
  float linear_damping() const;
  void set_linear_damping(float value);
  private:
  float _internal_linear_damping() const;
  void _internal_set_linear_damping(float value);
  public:

  // float angular_damping = 10;
  void clear_angular_damping();
  float angular_damping() const;
  void set_angular_damping(float value);
  private:
  float _internal_angular_damping() const;
  void _internal_set_angular_damping(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.BoxData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float width_;
    float height_;
    float depth_;
    float mass_;
    float restitution_;
    float friction_;
    float rolling_friction_;
    float linear_damping_;
    float angular_damping_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class TerrainData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.TerrainData) */ {
 public:
  inline TerrainData() : TerrainData(nullptr) {}
  ~TerrainData() override;
  explicit PROTOBUF_CONSTEXPR TerrainData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerrainData(const TerrainData& from);
  TerrainData(TerrainData&& from) noexcept
    : TerrainData() {
    *this = ::std::move(from);
  }

  inline TerrainData& operator=(const TerrainData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerrainData& operator=(TerrainData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerrainData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerrainData* internal_default_instance() {
    return reinterpret_cast<const TerrainData*>(
               &_TerrainData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TerrainData& a, TerrainData& b) {
    a.Swap(&b);
  }
  inline void Swap(TerrainData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerrainData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerrainData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerrainData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerrainData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerrainData& from) {
    TerrainData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerrainData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.TerrainData";
  }
  protected:
  explicit TerrainData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightmapFieldNumber = 3,
    kWidthFieldNumber = 1,
    kDepthFieldNumber = 2,
    kScaleXFieldNumber = 4,
    kScaleYFieldNumber = 5,
    kScaleZFieldNumber = 6,
    kMinHeightFieldNumber = 7,
    kMaxHeightFieldNumber = 8,
  };
  // repeated float heightmap = 3;
  int heightmap_size() const;
  private:
  int _internal_heightmap_size() const;
  public:
  void clear_heightmap();
  private:
  float _internal_heightmap(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_heightmap() const;
  void _internal_add_heightmap(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_heightmap();
  public:
  float heightmap(int index) const;
  void set_heightmap(int index, float value);
  void add_heightmap(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      heightmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_heightmap();

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 depth = 2;
  void clear_depth();
  int32_t depth() const;
  void set_depth(int32_t value);
  private:
  int32_t _internal_depth() const;
  void _internal_set_depth(int32_t value);
  public:

  // float scale_x = 4;
  void clear_scale_x();
  float scale_x() const;
  void set_scale_x(float value);
  private:
  float _internal_scale_x() const;
  void _internal_set_scale_x(float value);
  public:

  // float scale_y = 5;
  void clear_scale_y();
  float scale_y() const;
  void set_scale_y(float value);
  private:
  float _internal_scale_y() const;
  void _internal_set_scale_y(float value);
  public:

  // float scale_z = 6;
  void clear_scale_z();
  float scale_z() const;
  void set_scale_z(float value);
  private:
  float _internal_scale_z() const;
  void _internal_set_scale_z(float value);
  public:

  // float min_height = 7;
  void clear_min_height();
  float min_height() const;
  void set_min_height(float value);
  private:
  float _internal_min_height() const;
  void _internal_set_min_height(float value);
  public:

  // float max_height = 8;
  void clear_max_height();
  float max_height() const;
  void set_max_height(float value);
  private:
  float _internal_max_height() const;
  void _internal_set_max_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.TerrainData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > heightmap_;
    int32_t width_;
    int32_t depth_;
    float scale_x_;
    float scale_y_;
    float scale_z_;
    float min_height_;
    float max_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.CreateObjectRequest) */ {
 public:
  inline CreateObjectRequest() : CreateObjectRequest(nullptr) {}
  ~CreateObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateObjectRequest(const CreateObjectRequest& from);
  CreateObjectRequest(CreateObjectRequest&& from) noexcept
    : CreateObjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateObjectRequest& operator=(const CreateObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectRequest& operator=(CreateObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateObjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateObjectRequest*>(
               &_CreateObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateObjectRequest& a, CreateObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateObjectRequest& from) {
    CreateObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.CreateObjectRequest";
  }
  protected:
  explicit CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kShapeFieldNumber = 4,
    kPhysicsConfigFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Vector3& position() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_position();
  ::physics::Vector3* mutable_position();
  void set_allocated_position(::physics::Vector3* position);
  private:
  const ::physics::Vector3& _internal_position() const;
  ::physics::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Vector3* position);
  ::physics::Vector3* unsafe_arena_release_position();

  // .physics.Quaternion rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::physics::Quaternion* release_rotation();
  ::physics::Quaternion* mutable_rotation();
  void set_allocated_rotation(::physics::Quaternion* rotation);
  private:
  const ::physics::Quaternion& _internal_rotation() const;
  ::physics::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Quaternion* rotation);
  ::physics::Quaternion* unsafe_arena_release_rotation();

  // .physics.ShapeDescriptor shape = 4;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::physics::ShapeDescriptor& shape() const;
  PROTOBUF_NODISCARD ::physics::ShapeDescriptor* release_shape();
  ::physics::ShapeDescriptor* mutable_shape();
  void set_allocated_shape(::physics::ShapeDescriptor* shape);
  private:
  const ::physics::ShapeDescriptor& _internal_shape() const;
  ::physics::ShapeDescriptor* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::physics::ShapeDescriptor* shape);
  ::physics::ShapeDescriptor* unsafe_arena_release_shape();

  // .physics.PhysicsConfig physics_config = 5;
  bool has_physics_config() const;
  private:
  bool _internal_has_physics_config() const;
  public:
  void clear_physics_config();
  const ::physics::PhysicsConfig& physics_config() const;
  PROTOBUF_NODISCARD ::physics::PhysicsConfig* release_physics_config();
  ::physics::PhysicsConfig* mutable_physics_config();
  void set_allocated_physics_config(::physics::PhysicsConfig* physics_config);
  private:
  const ::physics::PhysicsConfig& _internal_physics_config() const;
  ::physics::PhysicsConfig* _internal_mutable_physics_config();
  public:
  void unsafe_arena_set_allocated_physics_config(
      ::physics::PhysicsConfig* physics_config);
  ::physics::PhysicsConfig* unsafe_arena_release_physics_config();

  // @@protoc_insertion_point(class_scope:physics.CreateObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* position_;
    ::physics::Quaternion* rotation_;
    ::physics::ShapeDescriptor* shape_;
    ::physics::PhysicsConfig* physics_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.CreateObjectResponse) */ {
 public:
  inline CreateObjectResponse() : CreateObjectResponse(nullptr) {}
  ~CreateObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateObjectResponse(const CreateObjectResponse& from);
  CreateObjectResponse(CreateObjectResponse&& from) noexcept
    : CreateObjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateObjectResponse& operator=(const CreateObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectResponse& operator=(CreateObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateObjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateObjectResponse*>(
               &_CreateObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateObjectResponse& a, CreateObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateObjectResponse& from) {
    CreateObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.CreateObjectResponse";
  }
  protected:
  explicit CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.CreateObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyImpulseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyImpulseRequest) */ {
 public:
  inline ApplyImpulseRequest() : ApplyImpulseRequest(nullptr) {}
  ~ApplyImpulseRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyImpulseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyImpulseRequest(const ApplyImpulseRequest& from);
  ApplyImpulseRequest(ApplyImpulseRequest&& from) noexcept
    : ApplyImpulseRequest() {
    *this = ::std::move(from);
  }

  inline ApplyImpulseRequest& operator=(const ApplyImpulseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyImpulseRequest& operator=(ApplyImpulseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyImpulseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyImpulseRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyImpulseRequest*>(
               &_ApplyImpulseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ApplyImpulseRequest& a, ApplyImpulseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyImpulseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyImpulseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyImpulseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyImpulseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyImpulseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyImpulseRequest& from) {
    ApplyImpulseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyImpulseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyImpulseRequest";
  }
  protected:
  explicit ApplyImpulseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kImpulseFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 impulse = 2;
  bool has_impulse() const;
  private:
  bool _internal_has_impulse() const;
  public:
  void clear_impulse();
  const ::physics::Vector3& impulse() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_impulse();
  ::physics::Vector3* mutable_impulse();
  void set_allocated_impulse(::physics::Vector3* impulse);
  private:
  const ::physics::Vector3& _internal_impulse() const;
  ::physics::Vector3* _internal_mutable_impulse();
  public:
  void unsafe_arena_set_allocated_impulse(
      ::physics::Vector3* impulse);
  ::physics::Vector3* unsafe_arena_release_impulse();

  // @@protoc_insertion_point(class_scope:physics.ApplyImpulseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* impulse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyImpulseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyImpulseResponse) */ {
 public:
  inline ApplyImpulseResponse() : ApplyImpulseResponse(nullptr) {}
  ~ApplyImpulseResponse() override;
  explicit PROTOBUF_CONSTEXPR ApplyImpulseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyImpulseResponse(const ApplyImpulseResponse& from);
  ApplyImpulseResponse(ApplyImpulseResponse&& from) noexcept
    : ApplyImpulseResponse() {
    *this = ::std::move(from);
  }

  inline ApplyImpulseResponse& operator=(const ApplyImpulseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyImpulseResponse& operator=(ApplyImpulseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyImpulseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyImpulseResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyImpulseResponse*>(
               &_ApplyImpulseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ApplyImpulseResponse& a, ApplyImpulseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyImpulseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyImpulseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyImpulseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyImpulseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyImpulseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyImpulseResponse& from) {
    ApplyImpulseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyImpulseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyImpulseResponse";
  }
  protected:
  explicit ApplyImpulseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.ApplyImpulseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyTorqueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyTorqueRequest) */ {
 public:
  inline ApplyTorqueRequest() : ApplyTorqueRequest(nullptr) {}
  ~ApplyTorqueRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyTorqueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyTorqueRequest(const ApplyTorqueRequest& from);
  ApplyTorqueRequest(ApplyTorqueRequest&& from) noexcept
    : ApplyTorqueRequest() {
    *this = ::std::move(from);
  }

  inline ApplyTorqueRequest& operator=(const ApplyTorqueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyTorqueRequest& operator=(ApplyTorqueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyTorqueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyTorqueRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyTorqueRequest*>(
               &_ApplyTorqueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApplyTorqueRequest& a, ApplyTorqueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyTorqueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyTorqueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyTorqueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyTorqueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyTorqueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyTorqueRequest& from) {
    ApplyTorqueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyTorqueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyTorqueRequest";
  }
  protected:
  explicit ApplyTorqueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 torque = 2;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::physics::Vector3& torque() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_torque();
  ::physics::Vector3* mutable_torque();
  void set_allocated_torque(::physics::Vector3* torque);
  private:
  const ::physics::Vector3& _internal_torque() const;
  ::physics::Vector3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::physics::Vector3* torque);
  ::physics::Vector3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:physics.ApplyTorqueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* torque_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyTorqueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyTorqueResponse) */ {
 public:
  inline ApplyTorqueResponse() : ApplyTorqueResponse(nullptr) {}
  ~ApplyTorqueResponse() override;
  explicit PROTOBUF_CONSTEXPR ApplyTorqueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyTorqueResponse(const ApplyTorqueResponse& from);
  ApplyTorqueResponse(ApplyTorqueResponse&& from) noexcept
    : ApplyTorqueResponse() {
    *this = ::std::move(from);
  }

  inline ApplyTorqueResponse& operator=(const ApplyTorqueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyTorqueResponse& operator=(ApplyTorqueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyTorqueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyTorqueResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyTorqueResponse*>(
               &_ApplyTorqueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApplyTorqueResponse& a, ApplyTorqueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyTorqueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyTorqueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyTorqueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyTorqueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyTorqueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyTorqueResponse& from) {
    ApplyTorqueResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyTorqueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyTorqueResponse";
  }
  protected:
  explicit ApplyTorqueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.ApplyTorqueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetObjectStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.GetObjectStateRequest) */ {
 public:
  inline GetObjectStateRequest() : GetObjectStateRequest(nullptr) {}
  ~GetObjectStateRequest() override;
  explicit PROTOBUF_CONSTEXPR GetObjectStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectStateRequest(const GetObjectStateRequest& from);
  GetObjectStateRequest(GetObjectStateRequest&& from) noexcept
    : GetObjectStateRequest() {
    *this = ::std::move(from);
  }

  inline GetObjectStateRequest& operator=(const GetObjectStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectStateRequest& operator=(GetObjectStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetObjectStateRequest*>(
               &_GetObjectStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetObjectStateRequest& a, GetObjectStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectStateRequest& from) {
    GetObjectStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetObjectStateRequest";
  }
  protected:
  explicit GetObjectStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:physics.GetObjectStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ObjectState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ObjectState) */ {
 public:
  inline ObjectState() : ObjectState(nullptr) {}
  ~ObjectState() override;
  explicit PROTOBUF_CONSTEXPR ObjectState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectState(const ObjectState& from);
  ObjectState(ObjectState&& from) noexcept
    : ObjectState() {
    *this = ::std::move(from);
  }

  inline ObjectState& operator=(const ObjectState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectState& operator=(ObjectState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectState* internal_default_instance() {
    return reinterpret_cast<const ObjectState*>(
               &_ObjectState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ObjectState& a, ObjectState& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectState& from) {
    ObjectState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ObjectState";
  }
  protected:
  explicit ObjectState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kLinearVelocityFieldNumber = 3,
    kAngularVelocityFieldNumber = 4,
  };
  // .physics.Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Vector3& position() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_position();
  ::physics::Vector3* mutable_position();
  void set_allocated_position(::physics::Vector3* position);
  private:
  const ::physics::Vector3& _internal_position() const;
  ::physics::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Vector3* position);
  ::physics::Vector3* unsafe_arena_release_position();

  // .physics.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::physics::Quaternion* release_rotation();
  ::physics::Quaternion* mutable_rotation();
  void set_allocated_rotation(::physics::Quaternion* rotation);
  private:
  const ::physics::Quaternion& _internal_rotation() const;
  ::physics::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Quaternion* rotation);
  ::physics::Quaternion* unsafe_arena_release_rotation();

  // .physics.Vector3 linear_velocity = 3;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::physics::Vector3& linear_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_linear_velocity();
  ::physics::Vector3* mutable_linear_velocity();
  void set_allocated_linear_velocity(::physics::Vector3* linear_velocity);
  private:
  const ::physics::Vector3& _internal_linear_velocity() const;
  ::physics::Vector3* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::physics::Vector3* linear_velocity);
  ::physics::Vector3* unsafe_arena_release_linear_velocity();

  // .physics.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::physics::Vector3& angular_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_angular_velocity();
  ::physics::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::physics::Vector3* angular_velocity);
  private:
  const ::physics::Vector3& _internal_angular_velocity() const;
  ::physics::Vector3* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::physics::Vector3* angular_velocity);
  ::physics::Vector3* unsafe_arena_release_angular_velocity();

  // @@protoc_insertion_point(class_scope:physics.ObjectState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::physics::Vector3* position_;
    ::physics::Quaternion* rotation_;
    ::physics::Vector3* linear_velocity_;
    ::physics::Vector3* angular_velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetObjectStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.GetObjectStateResponse) */ {
 public:
  inline GetObjectStateResponse() : GetObjectStateResponse(nullptr) {}
  ~GetObjectStateResponse() override;
  explicit PROTOBUF_CONSTEXPR GetObjectStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectStateResponse(const GetObjectStateResponse& from);
  GetObjectStateResponse(GetObjectStateResponse&& from) noexcept
    : GetObjectStateResponse() {
    *this = ::std::move(from);
  }

  inline GetObjectStateResponse& operator=(const GetObjectStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectStateResponse& operator=(GetObjectStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetObjectStateResponse*>(
               &_GetObjectStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetObjectStateResponse& a, GetObjectStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectStateResponse& from) {
    GetObjectStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetObjectStateResponse";
  }
  protected:
  explicit GetObjectStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .physics.ObjectState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::physics::ObjectState& state() const;
  PROTOBUF_NODISCARD ::physics::ObjectState* release_state();
  ::physics::ObjectState* mutable_state();
  void set_allocated_state(::physics::ObjectState* state);
  private:
  const ::physics::ObjectState& _internal_state() const;
  ::physics::ObjectState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::physics::ObjectState* state);
  ::physics::ObjectState* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:physics.GetObjectStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::physics::ObjectState* state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectMassRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectMassRequest) */ {
 public:
  inline UpdateObjectMassRequest() : UpdateObjectMassRequest(nullptr) {}
  ~UpdateObjectMassRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectMassRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectMassRequest(const UpdateObjectMassRequest& from);
  UpdateObjectMassRequest(UpdateObjectMassRequest&& from) noexcept
    : UpdateObjectMassRequest() {
    *this = ::std::move(from);
  }

  inline UpdateObjectMassRequest& operator=(const UpdateObjectMassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectMassRequest& operator=(UpdateObjectMassRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectMassRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectMassRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectMassRequest*>(
               &_UpdateObjectMassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateObjectMassRequest& a, UpdateObjectMassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectMassRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectMassRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectMassRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectMassRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectMassRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectMassRequest& from) {
    UpdateObjectMassRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectMassRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectMassRequest";
  }
  protected:
  explicit UpdateObjectMassRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMassFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // float mass = 2;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectMassRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    float mass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectMassResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectMassResponse) */ {
 public:
  inline UpdateObjectMassResponse() : UpdateObjectMassResponse(nullptr) {}
  ~UpdateObjectMassResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectMassResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectMassResponse(const UpdateObjectMassResponse& from);
  UpdateObjectMassResponse(UpdateObjectMassResponse&& from) noexcept
    : UpdateObjectMassResponse() {
    *this = ::std::move(from);
  }

  inline UpdateObjectMassResponse& operator=(const UpdateObjectMassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectMassResponse& operator=(UpdateObjectMassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectMassResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectMassResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectMassResponse*>(
               &_UpdateObjectMassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateObjectMassResponse& a, UpdateObjectMassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectMassResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectMassResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectMassResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectMassResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectMassResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectMassResponse& from) {
    UpdateObjectMassResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectMassResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectMassResponse";
  }
  protected:
  explicit UpdateObjectMassResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectMassResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectRadiusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectRadiusRequest) */ {
 public:
  inline UpdateObjectRadiusRequest() : UpdateObjectRadiusRequest(nullptr) {}
  ~UpdateObjectRadiusRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectRadiusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectRadiusRequest(const UpdateObjectRadiusRequest& from);
  UpdateObjectRadiusRequest(UpdateObjectRadiusRequest&& from) noexcept
    : UpdateObjectRadiusRequest() {
    *this = ::std::move(from);
  }

  inline UpdateObjectRadiusRequest& operator=(const UpdateObjectRadiusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectRadiusRequest& operator=(UpdateObjectRadiusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectRadiusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectRadiusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectRadiusRequest*>(
               &_UpdateObjectRadiusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateObjectRadiusRequest& a, UpdateObjectRadiusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectRadiusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectRadiusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectRadiusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectRadiusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectRadiusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectRadiusRequest& from) {
    UpdateObjectRadiusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectRadiusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectRadiusRequest";
  }
  protected:
  explicit UpdateObjectRadiusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // float radius = 2;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectRadiusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    float radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectRadiusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectRadiusResponse) */ {
 public:
  inline UpdateObjectRadiusResponse() : UpdateObjectRadiusResponse(nullptr) {}
  ~UpdateObjectRadiusResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectRadiusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectRadiusResponse(const UpdateObjectRadiusResponse& from);
  UpdateObjectRadiusResponse(UpdateObjectRadiusResponse&& from) noexcept
    : UpdateObjectRadiusResponse() {
    *this = ::std::move(from);
  }

  inline UpdateObjectRadiusResponse& operator=(const UpdateObjectRadiusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectRadiusResponse& operator=(UpdateObjectRadiusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectRadiusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectRadiusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectRadiusResponse*>(
               &_UpdateObjectRadiusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateObjectRadiusResponse& a, UpdateObjectRadiusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectRadiusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectRadiusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectRadiusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectRadiusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectRadiusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectRadiusResponse& from) {
    UpdateObjectRadiusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectRadiusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectRadiusResponse";
  }
  protected:
  explicit UpdateObjectRadiusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectRadiusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectMassAndRadiusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectMassAndRadiusRequest) */ {
 public:
  inline UpdateObjectMassAndRadiusRequest() : UpdateObjectMassAndRadiusRequest(nullptr) {}
  ~UpdateObjectMassAndRadiusRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectMassAndRadiusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectMassAndRadiusRequest(const UpdateObjectMassAndRadiusRequest& from);
  UpdateObjectMassAndRadiusRequest(UpdateObjectMassAndRadiusRequest&& from) noexcept
    : UpdateObjectMassAndRadiusRequest() {
    *this = ::std::move(from);
  }

  inline UpdateObjectMassAndRadiusRequest& operator=(const UpdateObjectMassAndRadiusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectMassAndRadiusRequest& operator=(UpdateObjectMassAndRadiusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectMassAndRadiusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectMassAndRadiusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectMassAndRadiusRequest*>(
               &_UpdateObjectMassAndRadiusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateObjectMassAndRadiusRequest& a, UpdateObjectMassAndRadiusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectMassAndRadiusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectMassAndRadiusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectMassAndRadiusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectMassAndRadiusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectMassAndRadiusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectMassAndRadiusRequest& from) {
    UpdateObjectMassAndRadiusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectMassAndRadiusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectMassAndRadiusRequest";
  }
  protected:
  explicit UpdateObjectMassAndRadiusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMassFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // float mass = 2;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // float radius = 3;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectMassAndRadiusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    float mass_;
    float radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectMassAndRadiusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectMassAndRadiusResponse) */ {
 public:
  inline UpdateObjectMassAndRadiusResponse() : UpdateObjectMassAndRadiusResponse(nullptr) {}
  ~UpdateObjectMassAndRadiusResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectMassAndRadiusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectMassAndRadiusResponse(const UpdateObjectMassAndRadiusResponse& from);
  UpdateObjectMassAndRadiusResponse(UpdateObjectMassAndRadiusResponse&& from) noexcept
    : UpdateObjectMassAndRadiusResponse() {
    *this = ::std::move(from);
  }

  inline UpdateObjectMassAndRadiusResponse& operator=(const UpdateObjectMassAndRadiusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectMassAndRadiusResponse& operator=(UpdateObjectMassAndRadiusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectMassAndRadiusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectMassAndRadiusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectMassAndRadiusResponse*>(
               &_UpdateObjectMassAndRadiusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateObjectMassAndRadiusResponse& a, UpdateObjectMassAndRadiusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectMassAndRadiusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectMassAndRadiusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectMassAndRadiusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectMassAndRadiusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectMassAndRadiusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectMassAndRadiusResponse& from) {
    UpdateObjectMassAndRadiusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectMassAndRadiusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectMassAndRadiusResponse";
  }
  protected:
  explicit UpdateObjectMassAndRadiusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectMassAndRadiusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class WorldPhysicsConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.WorldPhysicsConfig) */ {
 public:
  inline WorldPhysicsConfig() : WorldPhysicsConfig(nullptr) {}
  ~WorldPhysicsConfig() override;
  explicit PROTOBUF_CONSTEXPR WorldPhysicsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldPhysicsConfig(const WorldPhysicsConfig& from);
  WorldPhysicsConfig(WorldPhysicsConfig&& from) noexcept
    : WorldPhysicsConfig() {
    *this = ::std::move(from);
  }

  inline WorldPhysicsConfig& operator=(const WorldPhysicsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldPhysicsConfig& operator=(WorldPhysicsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldPhysicsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldPhysicsConfig* internal_default_instance() {
    return reinterpret_cast<const WorldPhysicsConfig*>(
               &_WorldPhysicsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WorldPhysicsConfig& a, WorldPhysicsConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldPhysicsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldPhysicsConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldPhysicsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldPhysicsConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldPhysicsConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldPhysicsConfig& from) {
    WorldPhysicsConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldPhysicsConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.WorldPhysicsConfig";
  }
  protected:
  explicit WorldPhysicsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGravityXFieldNumber = 1,
    kGravityYFieldNumber = 2,
    kGravityZFieldNumber = 3,
    kLinearDampingFieldNumber = 4,
    kAngularDampingFieldNumber = 5,
    kFrictionFieldNumber = 6,
    kRollingFrictionFieldNumber = 7,
  };
  // float gravity_x = 1;
  void clear_gravity_x();
  float gravity_x() const;
  void set_gravity_x(float value);
  private:
  float _internal_gravity_x() const;
  void _internal_set_gravity_x(float value);
  public:

  // float gravity_y = 2;
  void clear_gravity_y();
  float gravity_y() const;
  void set_gravity_y(float value);
  private:
  float _internal_gravity_y() const;
  void _internal_set_gravity_y(float value);
  public:

  // float gravity_z = 3;
  void clear_gravity_z();
  float gravity_z() const;
  void set_gravity_z(float value);
  private:
  float _internal_gravity_z() const;
  void _internal_set_gravity_z(float value);
  public:

  // float linear_damping = 4;
  void clear_linear_damping();
  float linear_damping() const;
  void set_linear_damping(float value);
  private:
  float _internal_linear_damping() const;
  void _internal_set_linear_damping(float value);
  public:

  // float angular_damping = 5;
  void clear_angular_damping();
  float angular_damping() const;
  void set_angular_damping(float value);
  private:
  float _internal_angular_damping() const;
  void _internal_set_angular_damping(float value);
  public:

  // float friction = 6;
  void clear_friction();
  float friction() const;
  void set_friction(float value);
  private:
  float _internal_friction() const;
  void _internal_set_friction(float value);
  public:

  // float rolling_friction = 7;
  void clear_rolling_friction();
  float rolling_friction() const;
  void set_rolling_friction(float value);
  private:
  float _internal_rolling_friction() const;
  void _internal_set_rolling_friction(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.WorldPhysicsConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float gravity_x_;
    float gravity_y_;
    float gravity_z_;
    float linear_damping_;
    float angular_damping_;
    float friction_;
    float rolling_friction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class PlayerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.PlayerConfig) */ {
 public:
  inline PlayerConfig() : PlayerConfig(nullptr) {}
  ~PlayerConfig() override;
  explicit PROTOBUF_CONSTEXPR PlayerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerConfig(const PlayerConfig& from);
  PlayerConfig(PlayerConfig&& from) noexcept
    : PlayerConfig() {
    *this = ::std::move(from);
  }

  inline PlayerConfig& operator=(const PlayerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerConfig& operator=(PlayerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerConfig* internal_default_instance() {
    return reinterpret_cast<const PlayerConfig*>(
               &_PlayerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayerConfig& a, PlayerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerConfig& from) {
    PlayerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.PlayerConfig";
  }
  protected:
  explicit PlayerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerMassFieldNumber = 1,
    kRestitutionFieldNumber = 2,
  };
  // float player_mass = 1;
  void clear_player_mass();
  float player_mass() const;
  void set_player_mass(float value);
  private:
  float _internal_player_mass() const;
  void _internal_set_player_mass(float value);
  public:

  // float restitution = 2;
  void clear_restitution();
  float restitution() const;
  void set_restitution(float value);
  private:
  float _internal_restitution() const;
  void _internal_set_restitution(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.PlayerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float player_mass_;
    float restitution_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ControlConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ControlConfig) */ {
 public:
  inline ControlConfig() : ControlConfig(nullptr) {}
  ~ControlConfig() override;
  explicit PROTOBUF_CONSTEXPR ControlConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlConfig(const ControlConfig& from);
  ControlConfig(ControlConfig&& from) noexcept
    : ControlConfig() {
    *this = ::std::move(from);
  }

  inline ControlConfig& operator=(const ControlConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlConfig& operator=(ControlConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlConfig* internal_default_instance() {
    return reinterpret_cast<const ControlConfig*>(
               &_ControlConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ControlConfig& a, ControlConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlConfig& from) {
    ControlConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ControlConfig";
  }
  protected:
  explicit ControlConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseImpulseFieldNumber = 1,
    kMaxImpulseFieldNumber = 2,
    kDistanceMultiplierFieldNumber = 3,
    kImpulseMultiplierFieldNumber = 4,
  };
  // float base_impulse = 1;
  void clear_base_impulse();
  float base_impulse() const;
  void set_base_impulse(float value);
  private:
  float _internal_base_impulse() const;
  void _internal_set_base_impulse(float value);
  public:

  // float max_impulse = 2;
  void clear_max_impulse();
  float max_impulse() const;
  void set_max_impulse(float value);
  private:
  float _internal_max_impulse() const;
  void _internal_set_max_impulse(float value);
  public:

  // float distance_multiplier = 3;
  void clear_distance_multiplier();
  float distance_multiplier() const;
  void set_distance_multiplier(float value);
  private:
  float _internal_distance_multiplier() const;
  void _internal_set_distance_multiplier(float value);
  public:

  // float impulse_multiplier = 4;
  void clear_impulse_multiplier();
  float impulse_multiplier() const;
  void set_impulse_multiplier(float value);
  private:
  float _internal_impulse_multiplier() const;
  void _internal_set_impulse_multiplier(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.ControlConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float base_impulse_;
    float max_impulse_;
    float distance_multiplier_;
    float impulse_multiplier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class PhysicsConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.PhysicsConfig) */ {
 public:
  inline PhysicsConfig() : PhysicsConfig(nullptr) {}
  ~PhysicsConfig() override;
  explicit PROTOBUF_CONSTEXPR PhysicsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicsConfig(const PhysicsConfig& from);
  PhysicsConfig(PhysicsConfig&& from) noexcept
    : PhysicsConfig() {
    *this = ::std::move(from);
  }

  inline PhysicsConfig& operator=(const PhysicsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicsConfig& operator=(PhysicsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicsConfig* internal_default_instance() {
    return reinterpret_cast<const PhysicsConfig*>(
               &_PhysicsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PhysicsConfig& a, PhysicsConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicsConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhysicsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhysicsConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicsConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhysicsConfig& from) {
    PhysicsConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicsConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.PhysicsConfig";
  }
  protected:
  explicit PhysicsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldFieldNumber = 1,
    kPlayerFieldNumber = 2,
    kControlFieldNumber = 3,
  };
  // .physics.WorldPhysicsConfig world = 1;
  bool has_world() const;
  private:
  bool _internal_has_world() const;
  public:
  void clear_world();
  const ::physics::WorldPhysicsConfig& world() const;
  PROTOBUF_NODISCARD ::physics::WorldPhysicsConfig* release_world();
  ::physics::WorldPhysicsConfig* mutable_world();
  void set_allocated_world(::physics::WorldPhysicsConfig* world);
  private:
  const ::physics::WorldPhysicsConfig& _internal_world() const;
  ::physics::WorldPhysicsConfig* _internal_mutable_world();
  public:
  void unsafe_arena_set_allocated_world(
      ::physics::WorldPhysicsConfig* world);
  ::physics::WorldPhysicsConfig* unsafe_arena_release_world();

  // .physics.PlayerConfig player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::physics::PlayerConfig& player() const;
  PROTOBUF_NODISCARD ::physics::PlayerConfig* release_player();
  ::physics::PlayerConfig* mutable_player();
  void set_allocated_player(::physics::PlayerConfig* player);
  private:
  const ::physics::PlayerConfig& _internal_player() const;
  ::physics::PlayerConfig* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::physics::PlayerConfig* player);
  ::physics::PlayerConfig* unsafe_arena_release_player();

  // .physics.ControlConfig control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::physics::ControlConfig& control() const;
  PROTOBUF_NODISCARD ::physics::ControlConfig* release_control();
  ::physics::ControlConfig* mutable_control();
  void set_allocated_control(::physics::ControlConfig* control);
  private:
  const ::physics::ControlConfig& _internal_control() const;
  ::physics::ControlConfig* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::physics::ControlConfig* control);
  ::physics::ControlConfig* unsafe_arena_release_control();

  // @@protoc_insertion_point(class_scope:physics.PhysicsConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::physics::WorldPhysicsConfig* world_;
    ::physics::PlayerConfig* player_;
    ::physics::ControlConfig* control_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SetPhysicsConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SetPhysicsConfigRequest) */ {
 public:
  inline SetPhysicsConfigRequest() : SetPhysicsConfigRequest(nullptr) {}
  ~SetPhysicsConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPhysicsConfigRequest(const SetPhysicsConfigRequest& from);
  SetPhysicsConfigRequest(SetPhysicsConfigRequest&& from) noexcept
    : SetPhysicsConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetPhysicsConfigRequest& operator=(const SetPhysicsConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPhysicsConfigRequest& operator=(SetPhysicsConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPhysicsConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPhysicsConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetPhysicsConfigRequest*>(
               &_SetPhysicsConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetPhysicsConfigRequest& a, SetPhysicsConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPhysicsConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPhysicsConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPhysicsConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPhysicsConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPhysicsConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPhysicsConfigRequest& from) {
    SetPhysicsConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPhysicsConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SetPhysicsConfigRequest";
  }
  protected:
  explicit SetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .physics.PhysicsConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::physics::PhysicsConfig& config() const;
  PROTOBUF_NODISCARD ::physics::PhysicsConfig* release_config();
  ::physics::PhysicsConfig* mutable_config();
  void set_allocated_config(::physics::PhysicsConfig* config);
  private:
  const ::physics::PhysicsConfig& _internal_config() const;
  ::physics::PhysicsConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::physics::PhysicsConfig* config);
  ::physics::PhysicsConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:physics.SetPhysicsConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::physics::PhysicsConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SetPhysicsConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SetPhysicsConfigResponse) */ {
 public:
  inline SetPhysicsConfigResponse() : SetPhysicsConfigResponse(nullptr) {}
  ~SetPhysicsConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR SetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPhysicsConfigResponse(const SetPhysicsConfigResponse& from);
  SetPhysicsConfigResponse(SetPhysicsConfigResponse&& from) noexcept
    : SetPhysicsConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetPhysicsConfigResponse& operator=(const SetPhysicsConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPhysicsConfigResponse& operator=(SetPhysicsConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPhysicsConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPhysicsConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetPhysicsConfigResponse*>(
               &_SetPhysicsConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetPhysicsConfigResponse& a, SetPhysicsConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPhysicsConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPhysicsConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPhysicsConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPhysicsConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPhysicsConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPhysicsConfigResponse& from) {
    SetPhysicsConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPhysicsConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SetPhysicsConfigResponse";
  }
  protected:
  explicit SetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.SetPhysicsConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.z)
}

// -------------------------------------------------------------------

// Quaternion

// float x = 1;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline float Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.x)
}

// float y = 2;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline float Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.y)
}

// float z = 3;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline float Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.z)
}

// float w = 4;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline float Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void Quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.w)
}

// -------------------------------------------------------------------

// ShapeDescriptor

// .physics.ShapeDescriptor.ShapeType type = 1;
inline void ShapeDescriptor::clear_type() {
  _impl_.type_ = 0;
}
inline ::physics::ShapeDescriptor_ShapeType ShapeDescriptor::_internal_type() const {
  return static_cast< ::physics::ShapeDescriptor_ShapeType >(_impl_.type_);
}
inline ::physics::ShapeDescriptor_ShapeType ShapeDescriptor::type() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.type)
  return _internal_type();
}
inline void ShapeDescriptor::_internal_set_type(::physics::ShapeDescriptor_ShapeType value) {
  
  _impl_.type_ = value;
}
inline void ShapeDescriptor::set_type(::physics::ShapeDescriptor_ShapeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:physics.ShapeDescriptor.type)
}

// .physics.SphereData sphere = 10;
inline bool ShapeDescriptor::_internal_has_sphere() const {
  return shape_case() == kSphere;
}
inline bool ShapeDescriptor::has_sphere() const {
  return _internal_has_sphere();
}
inline void ShapeDescriptor::set_has_sphere() {
  _impl_._oneof_case_[0] = kSphere;
}
inline void ShapeDescriptor::clear_sphere() {
  if (_internal_has_sphere()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.sphere_;
    }
    clear_has_shape();
  }
}
inline ::physics::SphereData* ShapeDescriptor::release_sphere() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.sphere)
  if (_internal_has_sphere()) {
    clear_has_shape();
    ::physics::SphereData* temp = _impl_.shape_.sphere_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::SphereData& ShapeDescriptor::_internal_sphere() const {
  return _internal_has_sphere()
      ? *_impl_.shape_.sphere_
      : reinterpret_cast< ::physics::SphereData&>(::physics::_SphereData_default_instance_);
}
inline const ::physics::SphereData& ShapeDescriptor::sphere() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.sphere)
  return _internal_sphere();
}
inline ::physics::SphereData* ShapeDescriptor::unsafe_arena_release_sphere() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.sphere)
  if (_internal_has_sphere()) {
    clear_has_shape();
    ::physics::SphereData* temp = _impl_.shape_.sphere_;
    _impl_.shape_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_sphere(::physics::SphereData* sphere) {
  clear_shape();
  if (sphere) {
    set_has_sphere();
    _impl_.shape_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.sphere)
}
inline ::physics::SphereData* ShapeDescriptor::_internal_mutable_sphere() {
  if (!_internal_has_sphere()) {
    clear_shape();
    set_has_sphere();
    _impl_.shape_.sphere_ = CreateMaybeMessage< ::physics::SphereData >(GetArenaForAllocation());
  }
  return _impl_.shape_.sphere_;
}
inline ::physics::SphereData* ShapeDescriptor::mutable_sphere() {
  ::physics::SphereData* _msg = _internal_mutable_sphere();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.sphere)
  return _msg;
}

// .physics.BoxData box = 11;
inline bool ShapeDescriptor::_internal_has_box() const {
  return shape_case() == kBox;
}
inline bool ShapeDescriptor::has_box() const {
  return _internal_has_box();
}
inline void ShapeDescriptor::set_has_box() {
  _impl_._oneof_case_[0] = kBox;
}
inline void ShapeDescriptor::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.box_;
    }
    clear_has_shape();
  }
}
inline ::physics::BoxData* ShapeDescriptor::release_box() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.box)
  if (_internal_has_box()) {
    clear_has_shape();
    ::physics::BoxData* temp = _impl_.shape_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::BoxData& ShapeDescriptor::_internal_box() const {
  return _internal_has_box()
      ? *_impl_.shape_.box_
      : reinterpret_cast< ::physics::BoxData&>(::physics::_BoxData_default_instance_);
}
inline const ::physics::BoxData& ShapeDescriptor::box() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.box)
  return _internal_box();
}
inline ::physics::BoxData* ShapeDescriptor::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.box)
  if (_internal_has_box()) {
    clear_has_shape();
    ::physics::BoxData* temp = _impl_.shape_.box_;
    _impl_.shape_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_box(::physics::BoxData* box) {
  clear_shape();
  if (box) {
    set_has_box();
    _impl_.shape_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.box)
}
inline ::physics::BoxData* ShapeDescriptor::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_shape();
    set_has_box();
    _impl_.shape_.box_ = CreateMaybeMessage< ::physics::BoxData >(GetArenaForAllocation());
  }
  return _impl_.shape_.box_;
}
inline ::physics::BoxData* ShapeDescriptor::mutable_box() {
  ::physics::BoxData* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.box)
  return _msg;
}

// .physics.TerrainData terrain = 12;
inline bool ShapeDescriptor::_internal_has_terrain() const {
  return shape_case() == kTerrain;
}
inline bool ShapeDescriptor::has_terrain() const {
  return _internal_has_terrain();
}
inline void ShapeDescriptor::set_has_terrain() {
  _impl_._oneof_case_[0] = kTerrain;
}
inline void ShapeDescriptor::clear_terrain() {
  if (_internal_has_terrain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.terrain_;
    }
    clear_has_shape();
  }
}
inline ::physics::TerrainData* ShapeDescriptor::release_terrain() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.terrain)
  if (_internal_has_terrain()) {
    clear_has_shape();
    ::physics::TerrainData* temp = _impl_.shape_.terrain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::TerrainData& ShapeDescriptor::_internal_terrain() const {
  return _internal_has_terrain()
      ? *_impl_.shape_.terrain_
      : reinterpret_cast< ::physics::TerrainData&>(::physics::_TerrainData_default_instance_);
}
inline const ::physics::TerrainData& ShapeDescriptor::terrain() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.terrain)
  return _internal_terrain();
}
inline ::physics::TerrainData* ShapeDescriptor::unsafe_arena_release_terrain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.terrain)
  if (_internal_has_terrain()) {
    clear_has_shape();
    ::physics::TerrainData* temp = _impl_.shape_.terrain_;
    _impl_.shape_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_terrain(::physics::TerrainData* terrain) {
  clear_shape();
  if (terrain) {
    set_has_terrain();
    _impl_.shape_.terrain_ = terrain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.terrain)
}
inline ::physics::TerrainData* ShapeDescriptor::_internal_mutable_terrain() {
  if (!_internal_has_terrain()) {
    clear_shape();
    set_has_terrain();
    _impl_.shape_.terrain_ = CreateMaybeMessage< ::physics::TerrainData >(GetArenaForAllocation());
  }
  return _impl_.shape_.terrain_;
}
inline ::physics::TerrainData* ShapeDescriptor::mutable_terrain() {
  ::physics::TerrainData* _msg = _internal_mutable_terrain();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.terrain)
  return _msg;
}

inline bool ShapeDescriptor::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void ShapeDescriptor::clear_has_shape() {
  _impl_._oneof_case_[0] = SHAPE_NOT_SET;
}
inline ShapeDescriptor::ShapeCase ShapeDescriptor::shape_case() const {
  return ShapeDescriptor::ShapeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SphereData

// float radius = 1;
inline void SphereData::clear_radius() {
  _impl_.radius_ = 0;
}
inline float SphereData::_internal_radius() const {
  return _impl_.radius_;
}
inline float SphereData::radius() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.radius)
  return _internal_radius();
}
inline void SphereData::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void SphereData::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.radius)
}

// float mass = 2;
inline void SphereData::clear_mass() {
  _impl_.mass_ = 0;
}
inline float SphereData::_internal_mass() const {
  return _impl_.mass_;
}
inline float SphereData::mass() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.mass)
  return _internal_mass();
}
inline void SphereData::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void SphereData::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.mass)
}

// string color = 3;
inline void SphereData::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& SphereData::color() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SphereData::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.SphereData.color)
}
inline std::string* SphereData::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:physics.SphereData.color)
  return _s;
}
inline const std::string& SphereData::_internal_color() const {
  return _impl_.color_.Get();
}
inline void SphereData::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* SphereData::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* SphereData::release_color() {
  // @@protoc_insertion_point(field_release:physics.SphereData.color)
  return _impl_.color_.Release();
}
inline void SphereData::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.SphereData.color)
}

// float restitution = 4;
inline void SphereData::clear_restitution() {
  _impl_.restitution_ = 0;
}
inline float SphereData::_internal_restitution() const {
  return _impl_.restitution_;
}
inline float SphereData::restitution() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.restitution)
  return _internal_restitution();
}
inline void SphereData::_internal_set_restitution(float value) {
  
  _impl_.restitution_ = value;
}
inline void SphereData::set_restitution(float value) {
  _internal_set_restitution(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.restitution)
}

// float friction = 5;
inline void SphereData::clear_friction() {
  _impl_.friction_ = 0;
}
inline float SphereData::_internal_friction() const {
  return _impl_.friction_;
}
inline float SphereData::friction() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.friction)
  return _internal_friction();
}
inline void SphereData::_internal_set_friction(float value) {
  
  _impl_.friction_ = value;
}
inline void SphereData::set_friction(float value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.friction)
}

// float rolling_friction = 6;
inline void SphereData::clear_rolling_friction() {
  _impl_.rolling_friction_ = 0;
}
inline float SphereData::_internal_rolling_friction() const {
  return _impl_.rolling_friction_;
}
inline float SphereData::rolling_friction() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.rolling_friction)
  return _internal_rolling_friction();
}
inline void SphereData::_internal_set_rolling_friction(float value) {
  
  _impl_.rolling_friction_ = value;
}
inline void SphereData::set_rolling_friction(float value) {
  _internal_set_rolling_friction(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.rolling_friction)
}

// float linear_damping = 7;
inline void SphereData::clear_linear_damping() {
  _impl_.linear_damping_ = 0;
}
inline float SphereData::_internal_linear_damping() const {
  return _impl_.linear_damping_;
}
inline float SphereData::linear_damping() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.linear_damping)
  return _internal_linear_damping();
}
inline void SphereData::_internal_set_linear_damping(float value) {
  
  _impl_.linear_damping_ = value;
}
inline void SphereData::set_linear_damping(float value) {
  _internal_set_linear_damping(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.linear_damping)
}

// float angular_damping = 8;
inline void SphereData::clear_angular_damping() {
  _impl_.angular_damping_ = 0;
}
inline float SphereData::_internal_angular_damping() const {
  return _impl_.angular_damping_;
}
inline float SphereData::angular_damping() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.angular_damping)
  return _internal_angular_damping();
}
inline void SphereData::_internal_set_angular_damping(float value) {
  
  _impl_.angular_damping_ = value;
}
inline void SphereData::set_angular_damping(float value) {
  _internal_set_angular_damping(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.angular_damping)
}

// -------------------------------------------------------------------

// BoxData

// float width = 1;
inline void BoxData::clear_width() {
  _impl_.width_ = 0;
}
inline float BoxData::_internal_width() const {
  return _impl_.width_;
}
inline float BoxData::width() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.width)
  return _internal_width();
}
inline void BoxData::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void BoxData::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.width)
}

// float height = 2;
inline void BoxData::clear_height() {
  _impl_.height_ = 0;
}
inline float BoxData::_internal_height() const {
  return _impl_.height_;
}
inline float BoxData::height() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.height)
  return _internal_height();
}
inline void BoxData::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void BoxData::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.height)
}

// float depth = 3;
inline void BoxData::clear_depth() {
  _impl_.depth_ = 0;
}
inline float BoxData::_internal_depth() const {
  return _impl_.depth_;
}
inline float BoxData::depth() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.depth)
  return _internal_depth();
}
inline void BoxData::_internal_set_depth(float value) {
  
  _impl_.depth_ = value;
}
inline void BoxData::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.depth)
}

// float mass = 4;
inline void BoxData::clear_mass() {
  _impl_.mass_ = 0;
}
inline float BoxData::_internal_mass() const {
  return _impl_.mass_;
}
inline float BoxData::mass() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.mass)
  return _internal_mass();
}
inline void BoxData::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void BoxData::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.mass)
}

// string color = 5;
inline void BoxData::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& BoxData::color() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BoxData::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.BoxData.color)
}
inline std::string* BoxData::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:physics.BoxData.color)
  return _s;
}
inline const std::string& BoxData::_internal_color() const {
  return _impl_.color_.Get();
}
inline void BoxData::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* BoxData::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* BoxData::release_color() {
  // @@protoc_insertion_point(field_release:physics.BoxData.color)
  return _impl_.color_.Release();
}
inline void BoxData::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.BoxData.color)
}

// float restitution = 6;
inline void BoxData::clear_restitution() {
  _impl_.restitution_ = 0;
}
inline float BoxData::_internal_restitution() const {
  return _impl_.restitution_;
}
inline float BoxData::restitution() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.restitution)
  return _internal_restitution();
}
inline void BoxData::_internal_set_restitution(float value) {
  
  _impl_.restitution_ = value;
}
inline void BoxData::set_restitution(float value) {
  _internal_set_restitution(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.restitution)
}

// float friction = 7;
inline void BoxData::clear_friction() {
  _impl_.friction_ = 0;
}
inline float BoxData::_internal_friction() const {
  return _impl_.friction_;
}
inline float BoxData::friction() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.friction)
  return _internal_friction();
}
inline void BoxData::_internal_set_friction(float value) {
  
  _impl_.friction_ = value;
}
inline void BoxData::set_friction(float value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.friction)
}

// float rolling_friction = 8;
inline void BoxData::clear_rolling_friction() {
  _impl_.rolling_friction_ = 0;
}
inline float BoxData::_internal_rolling_friction() const {
  return _impl_.rolling_friction_;
}
inline float BoxData::rolling_friction() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.rolling_friction)
  return _internal_rolling_friction();
}
inline void BoxData::_internal_set_rolling_friction(float value) {
  
  _impl_.rolling_friction_ = value;
}
inline void BoxData::set_rolling_friction(float value) {
  _internal_set_rolling_friction(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.rolling_friction)
}

// float linear_damping = 9;
inline void BoxData::clear_linear_damping() {
  _impl_.linear_damping_ = 0;
}
inline float BoxData::_internal_linear_damping() const {
  return _impl_.linear_damping_;
}
inline float BoxData::linear_damping() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.linear_damping)
  return _internal_linear_damping();
}
inline void BoxData::_internal_set_linear_damping(float value) {
  
  _impl_.linear_damping_ = value;
}
inline void BoxData::set_linear_damping(float value) {
  _internal_set_linear_damping(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.linear_damping)
}

// float angular_damping = 10;
inline void BoxData::clear_angular_damping() {
  _impl_.angular_damping_ = 0;
}
inline float BoxData::_internal_angular_damping() const {
  return _impl_.angular_damping_;
}
inline float BoxData::angular_damping() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.angular_damping)
  return _internal_angular_damping();
}
inline void BoxData::_internal_set_angular_damping(float value) {
  
  _impl_.angular_damping_ = value;
}
inline void BoxData::set_angular_damping(float value) {
  _internal_set_angular_damping(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.angular_damping)
}

// -------------------------------------------------------------------

// TerrainData

// int32 width = 1;
inline void TerrainData::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t TerrainData::_internal_width() const {
  return _impl_.width_;
}
inline int32_t TerrainData::width() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.width)
  return _internal_width();
}
inline void TerrainData::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void TerrainData::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.width)
}

// int32 depth = 2;
inline void TerrainData::clear_depth() {
  _impl_.depth_ = 0;
}
inline int32_t TerrainData::_internal_depth() const {
  return _impl_.depth_;
}
inline int32_t TerrainData::depth() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.depth)
  return _internal_depth();
}
inline void TerrainData::_internal_set_depth(int32_t value) {
  
  _impl_.depth_ = value;
}
inline void TerrainData::set_depth(int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.depth)
}

// repeated float heightmap = 3;
inline int TerrainData::_internal_heightmap_size() const {
  return _impl_.heightmap_.size();
}
inline int TerrainData::heightmap_size() const {
  return _internal_heightmap_size();
}
inline void TerrainData::clear_heightmap() {
  _impl_.heightmap_.Clear();
}
inline float TerrainData::_internal_heightmap(int index) const {
  return _impl_.heightmap_.Get(index);
}
inline float TerrainData::heightmap(int index) const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.heightmap)
  return _internal_heightmap(index);
}
inline void TerrainData::set_heightmap(int index, float value) {
  _impl_.heightmap_.Set(index, value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.heightmap)
}
inline void TerrainData::_internal_add_heightmap(float value) {
  _impl_.heightmap_.Add(value);
}
inline void TerrainData::add_heightmap(float value) {
  _internal_add_heightmap(value);
  // @@protoc_insertion_point(field_add:physics.TerrainData.heightmap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TerrainData::_internal_heightmap() const {
  return _impl_.heightmap_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TerrainData::heightmap() const {
  // @@protoc_insertion_point(field_list:physics.TerrainData.heightmap)
  return _internal_heightmap();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TerrainData::_internal_mutable_heightmap() {
  return &_impl_.heightmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TerrainData::mutable_heightmap() {
  // @@protoc_insertion_point(field_mutable_list:physics.TerrainData.heightmap)
  return _internal_mutable_heightmap();
}

// float scale_x = 4;
inline void TerrainData::clear_scale_x() {
  _impl_.scale_x_ = 0;
}
inline float TerrainData::_internal_scale_x() const {
  return _impl_.scale_x_;
}
inline float TerrainData::scale_x() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_x)
  return _internal_scale_x();
}
inline void TerrainData::_internal_set_scale_x(float value) {
  
  _impl_.scale_x_ = value;
}
inline void TerrainData::set_scale_x(float value) {
  _internal_set_scale_x(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_x)
}

// float scale_y = 5;
inline void TerrainData::clear_scale_y() {
  _impl_.scale_y_ = 0;
}
inline float TerrainData::_internal_scale_y() const {
  return _impl_.scale_y_;
}
inline float TerrainData::scale_y() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_y)
  return _internal_scale_y();
}
inline void TerrainData::_internal_set_scale_y(float value) {
  
  _impl_.scale_y_ = value;
}
inline void TerrainData::set_scale_y(float value) {
  _internal_set_scale_y(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_y)
}

// float scale_z = 6;
inline void TerrainData::clear_scale_z() {
  _impl_.scale_z_ = 0;
}
inline float TerrainData::_internal_scale_z() const {
  return _impl_.scale_z_;
}
inline float TerrainData::scale_z() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_z)
  return _internal_scale_z();
}
inline void TerrainData::_internal_set_scale_z(float value) {
  
  _impl_.scale_z_ = value;
}
inline void TerrainData::set_scale_z(float value) {
  _internal_set_scale_z(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_z)
}

// float min_height = 7;
inline void TerrainData::clear_min_height() {
  _impl_.min_height_ = 0;
}
inline float TerrainData::_internal_min_height() const {
  return _impl_.min_height_;
}
inline float TerrainData::min_height() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.min_height)
  return _internal_min_height();
}
inline void TerrainData::_internal_set_min_height(float value) {
  
  _impl_.min_height_ = value;
}
inline void TerrainData::set_min_height(float value) {
  _internal_set_min_height(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.min_height)
}

// float max_height = 8;
inline void TerrainData::clear_max_height() {
  _impl_.max_height_ = 0;
}
inline float TerrainData::_internal_max_height() const {
  return _impl_.max_height_;
}
inline float TerrainData::max_height() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.max_height)
  return _internal_max_height();
}
inline void TerrainData::_internal_set_max_height(float value) {
  
  _impl_.max_height_ = value;
}
inline void TerrainData::set_max_height(float value) {
  _internal_set_max_height(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.max_height)
}

// -------------------------------------------------------------------

// CreateObjectRequest

// string id = 1;
inline void CreateObjectRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CreateObjectRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateObjectRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.CreateObjectRequest.id)
}
inline std::string* CreateObjectRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.id)
  return _s;
}
inline const std::string& CreateObjectRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CreateObjectRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateObjectRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateObjectRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.id)
  return _impl_.id_.Release();
}
inline void CreateObjectRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.id)
}

// .physics.Vector3 position = 2;
inline bool CreateObjectRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool CreateObjectRequest::has_position() const {
  return _internal_has_position();
}
inline void CreateObjectRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Vector3& CreateObjectRequest::_internal_position() const {
  const ::physics::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& CreateObjectRequest::position() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.position)
  return _internal_position();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_position(
    ::physics::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.position)
}
inline ::physics::Vector3* CreateObjectRequest::release_position() {
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.position)
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Vector3* CreateObjectRequest::mutable_position() {
  ::physics::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.position)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_position(::physics::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.position)
}

// .physics.Quaternion rotation = 3;
inline bool CreateObjectRequest::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool CreateObjectRequest::has_rotation() const {
  return _internal_has_rotation();
}
inline void CreateObjectRequest::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Quaternion& CreateObjectRequest::_internal_rotation() const {
  const ::physics::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Quaternion&>(
      ::physics::_Quaternion_default_instance_);
}
inline const ::physics::Quaternion& CreateObjectRequest::rotation() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.rotation)
  return _internal_rotation();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_rotation(
    ::physics::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.rotation)
}
inline ::physics::Quaternion* CreateObjectRequest::release_rotation() {
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Quaternion* CreateObjectRequest::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.rotation)
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Quaternion* CreateObjectRequest::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Quaternion* CreateObjectRequest::mutable_rotation() {
  ::physics::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.rotation)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_rotation(::physics::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.rotation)
}

// .physics.ShapeDescriptor shape = 4;
inline bool CreateObjectRequest::_internal_has_shape() const {
  return this != internal_default_instance() && _impl_.shape_ != nullptr;
}
inline bool CreateObjectRequest::has_shape() const {
  return _internal_has_shape();
}
inline void CreateObjectRequest::clear_shape() {
  if (GetArenaForAllocation() == nullptr && _impl_.shape_ != nullptr) {
    delete _impl_.shape_;
  }
  _impl_.shape_ = nullptr;
}
inline const ::physics::ShapeDescriptor& CreateObjectRequest::_internal_shape() const {
  const ::physics::ShapeDescriptor* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::ShapeDescriptor&>(
      ::physics::_ShapeDescriptor_default_instance_);
}
inline const ::physics::ShapeDescriptor& CreateObjectRequest::shape() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.shape)
  return _internal_shape();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_shape(
    ::physics::ShapeDescriptor* shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.shape)
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::release_shape() {
  
  ::physics::ShapeDescriptor* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.shape)
  
  ::physics::ShapeDescriptor* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::_internal_mutable_shape() {
  
  if (_impl_.shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::ShapeDescriptor>(GetArenaForAllocation());
    _impl_.shape_ = p;
  }
  return _impl_.shape_;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::mutable_shape() {
  ::physics::ShapeDescriptor* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.shape)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_shape(::physics::ShapeDescriptor* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_;
  }
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape);
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.shape)
}

// .physics.PhysicsConfig physics_config = 5;
inline bool CreateObjectRequest::_internal_has_physics_config() const {
  return this != internal_default_instance() && _impl_.physics_config_ != nullptr;
}
inline bool CreateObjectRequest::has_physics_config() const {
  return _internal_has_physics_config();
}
inline void CreateObjectRequest::clear_physics_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.physics_config_ != nullptr) {
    delete _impl_.physics_config_;
  }
  _impl_.physics_config_ = nullptr;
}
inline const ::physics::PhysicsConfig& CreateObjectRequest::_internal_physics_config() const {
  const ::physics::PhysicsConfig* p = _impl_.physics_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::PhysicsConfig&>(
      ::physics::_PhysicsConfig_default_instance_);
}
inline const ::physics::PhysicsConfig& CreateObjectRequest::physics_config() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.physics_config)
  return _internal_physics_config();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_physics_config(
    ::physics::PhysicsConfig* physics_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.physics_config_);
  }
  _impl_.physics_config_ = physics_config;
  if (physics_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.physics_config)
}
inline ::physics::PhysicsConfig* CreateObjectRequest::release_physics_config() {
  
  ::physics::PhysicsConfig* temp = _impl_.physics_config_;
  _impl_.physics_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::PhysicsConfig* CreateObjectRequest::unsafe_arena_release_physics_config() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.physics_config)
  
  ::physics::PhysicsConfig* temp = _impl_.physics_config_;
  _impl_.physics_config_ = nullptr;
  return temp;
}
inline ::physics::PhysicsConfig* CreateObjectRequest::_internal_mutable_physics_config() {
  
  if (_impl_.physics_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::PhysicsConfig>(GetArenaForAllocation());
    _impl_.physics_config_ = p;
  }
  return _impl_.physics_config_;
}
inline ::physics::PhysicsConfig* CreateObjectRequest::mutable_physics_config() {
  ::physics::PhysicsConfig* _msg = _internal_mutable_physics_config();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.physics_config)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_physics_config(::physics::PhysicsConfig* physics_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.physics_config_;
  }
  if (physics_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(physics_config);
    if (message_arena != submessage_arena) {
      physics_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, physics_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.physics_config_ = physics_config;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.physics_config)
}

// -------------------------------------------------------------------

// CreateObjectResponse

// string status = 1;
inline void CreateObjectResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& CreateObjectResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateObjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.CreateObjectResponse.status)
}
inline std::string* CreateObjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectResponse.status)
  return _s;
}
inline const std::string& CreateObjectResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void CreateObjectResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectResponse.status)
  return _impl_.status_.Release();
}
inline void CreateObjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectResponse.status)
}

// -------------------------------------------------------------------

// ApplyImpulseRequest

// string id = 1;
inline void ApplyImpulseRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ApplyImpulseRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyImpulseRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyImpulseRequest.id)
}
inline std::string* ApplyImpulseRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseRequest.id)
  return _s;
}
inline const std::string& ApplyImpulseRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ApplyImpulseRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyImpulseRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyImpulseRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseRequest.id)
  return _impl_.id_.Release();
}
inline void ApplyImpulseRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseRequest.id)
}

// .physics.Vector3 impulse = 2;
inline bool ApplyImpulseRequest::_internal_has_impulse() const {
  return this != internal_default_instance() && _impl_.impulse_ != nullptr;
}
inline bool ApplyImpulseRequest::has_impulse() const {
  return _internal_has_impulse();
}
inline void ApplyImpulseRequest::clear_impulse() {
  if (GetArenaForAllocation() == nullptr && _impl_.impulse_ != nullptr) {
    delete _impl_.impulse_;
  }
  _impl_.impulse_ = nullptr;
}
inline const ::physics::Vector3& ApplyImpulseRequest::_internal_impulse() const {
  const ::physics::Vector3* p = _impl_.impulse_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ApplyImpulseRequest::impulse() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseRequest.impulse)
  return _internal_impulse();
}
inline void ApplyImpulseRequest::unsafe_arena_set_allocated_impulse(
    ::physics::Vector3* impulse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impulse_);
  }
  _impl_.impulse_ = impulse;
  if (impulse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ApplyImpulseRequest.impulse)
}
inline ::physics::Vector3* ApplyImpulseRequest::release_impulse() {
  
  ::physics::Vector3* temp = _impl_.impulse_;
  _impl_.impulse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::unsafe_arena_release_impulse() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseRequest.impulse)
  
  ::physics::Vector3* temp = _impl_.impulse_;
  _impl_.impulse_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::_internal_mutable_impulse() {
  
  if (_impl_.impulse_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.impulse_ = p;
  }
  return _impl_.impulse_;
}
inline ::physics::Vector3* ApplyImpulseRequest::mutable_impulse() {
  ::physics::Vector3* _msg = _internal_mutable_impulse();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseRequest.impulse)
  return _msg;
}
inline void ApplyImpulseRequest::set_allocated_impulse(::physics::Vector3* impulse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.impulse_;
  }
  if (impulse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(impulse);
    if (message_arena != submessage_arena) {
      impulse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impulse, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impulse_ = impulse;
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseRequest.impulse)
}

// -------------------------------------------------------------------

// ApplyImpulseResponse

// string status = 1;
inline void ApplyImpulseResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ApplyImpulseResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyImpulseResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyImpulseResponse.status)
}
inline std::string* ApplyImpulseResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseResponse.status)
  return _s;
}
inline const std::string& ApplyImpulseResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ApplyImpulseResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseResponse.status)
  return _impl_.status_.Release();
}
inline void ApplyImpulseResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseResponse.status)
}

// -------------------------------------------------------------------

// ApplyTorqueRequest

// string id = 1;
inline void ApplyTorqueRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ApplyTorqueRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyTorqueRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyTorqueRequest.id)
}
inline std::string* ApplyTorqueRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueRequest.id)
  return _s;
}
inline const std::string& ApplyTorqueRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ApplyTorqueRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyTorqueRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyTorqueRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueRequest.id)
  return _impl_.id_.Release();
}
inline void ApplyTorqueRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueRequest.id)
}

// .physics.Vector3 torque = 2;
inline bool ApplyTorqueRequest::_internal_has_torque() const {
  return this != internal_default_instance() && _impl_.torque_ != nullptr;
}
inline bool ApplyTorqueRequest::has_torque() const {
  return _internal_has_torque();
}
inline void ApplyTorqueRequest::clear_torque() {
  if (GetArenaForAllocation() == nullptr && _impl_.torque_ != nullptr) {
    delete _impl_.torque_;
  }
  _impl_.torque_ = nullptr;
}
inline const ::physics::Vector3& ApplyTorqueRequest::_internal_torque() const {
  const ::physics::Vector3* p = _impl_.torque_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ApplyTorqueRequest::torque() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueRequest.torque)
  return _internal_torque();
}
inline void ApplyTorqueRequest::unsafe_arena_set_allocated_torque(
    ::physics::Vector3* torque) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.torque_);
  }
  _impl_.torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ApplyTorqueRequest.torque)
}
inline ::physics::Vector3* ApplyTorqueRequest::release_torque() {
  
  ::physics::Vector3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ApplyTorqueRequest::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueRequest.torque)
  
  ::physics::Vector3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ApplyTorqueRequest::_internal_mutable_torque() {
  
  if (_impl_.torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.torque_ = p;
  }
  return _impl_.torque_;
}
inline ::physics::Vector3* ApplyTorqueRequest::mutable_torque() {
  ::physics::Vector3* _msg = _internal_mutable_torque();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueRequest.torque)
  return _msg;
}
inline void ApplyTorqueRequest::set_allocated_torque(::physics::Vector3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueRequest.torque)
}

// -------------------------------------------------------------------

// ApplyTorqueResponse

// string status = 1;
inline void ApplyTorqueResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ApplyTorqueResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyTorqueResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyTorqueResponse.status)
}
inline std::string* ApplyTorqueResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueResponse.status)
  return _s;
}
inline const std::string& ApplyTorqueResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ApplyTorqueResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyTorqueResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyTorqueResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueResponse.status)
  return _impl_.status_.Release();
}
inline void ApplyTorqueResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueResponse.status)
}

// -------------------------------------------------------------------

// GetObjectStateRequest

// string id = 1;
inline void GetObjectStateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetObjectStateRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectStateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.GetObjectStateRequest.id)
}
inline std::string* GetObjectStateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateRequest.id)
  return _s;
}
inline const std::string& GetObjectStateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetObjectStateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectStateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectStateRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateRequest.id)
  return _impl_.id_.Release();
}
inline void GetObjectStateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateRequest.id)
}

// -------------------------------------------------------------------

// ObjectState

// .physics.Vector3 position = 1;
inline bool ObjectState::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool ObjectState::has_position() const {
  return _internal_has_position();
}
inline void ObjectState::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_position() const {
  const ::physics::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::position() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.position)
  return _internal_position();
}
inline void ObjectState::unsafe_arena_set_allocated_position(
    ::physics::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.position)
}
inline ::physics::Vector3* ObjectState::release_position() {
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.position)
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Vector3* ObjectState::mutable_position() {
  ::physics::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.position)
  return _msg;
}
inline void ObjectState::set_allocated_position(::physics::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.position)
}

// .physics.Quaternion rotation = 2;
inline bool ObjectState::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool ObjectState::has_rotation() const {
  return _internal_has_rotation();
}
inline void ObjectState::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Quaternion& ObjectState::_internal_rotation() const {
  const ::physics::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Quaternion&>(
      ::physics::_Quaternion_default_instance_);
}
inline const ::physics::Quaternion& ObjectState::rotation() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.rotation)
  return _internal_rotation();
}
inline void ObjectState::unsafe_arena_set_allocated_rotation(
    ::physics::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.rotation)
}
inline ::physics::Quaternion* ObjectState::release_rotation() {
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Quaternion* ObjectState::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.rotation)
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Quaternion* ObjectState::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Quaternion* ObjectState::mutable_rotation() {
  ::physics::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.rotation)
  return _msg;
}
inline void ObjectState::set_allocated_rotation(::physics::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.rotation)
}

// .physics.Vector3 linear_velocity = 3;
inline bool ObjectState::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && _impl_.linear_velocity_ != nullptr;
}
inline bool ObjectState::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void ObjectState::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_linear_velocity() const {
  const ::physics::Vector3* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::linear_velocity() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.linear_velocity)
  return _internal_linear_velocity();
}
inline void ObjectState::unsafe_arena_set_allocated_linear_velocity(
    ::physics::Vector3* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.linear_velocity)
}
inline ::physics::Vector3* ObjectState::release_linear_velocity() {
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.linear_velocity)
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_linear_velocity() {
  
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::physics::Vector3* ObjectState::mutable_linear_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.linear_velocity)
  return _msg;
}
inline void ObjectState::set_allocated_linear_velocity(::physics::Vector3* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.linear_velocity)
}

// .physics.Vector3 angular_velocity = 4;
inline bool ObjectState::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && _impl_.angular_velocity_ != nullptr;
}
inline bool ObjectState::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void ObjectState::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_angular_velocity() const {
  const ::physics::Vector3* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::angular_velocity() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.angular_velocity)
  return _internal_angular_velocity();
}
inline void ObjectState::unsafe_arena_set_allocated_angular_velocity(
    ::physics::Vector3* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.angular_velocity)
}
inline ::physics::Vector3* ObjectState::release_angular_velocity() {
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.angular_velocity)
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_angular_velocity() {
  
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::physics::Vector3* ObjectState::mutable_angular_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.angular_velocity)
  return _msg;
}
inline void ObjectState::set_allocated_angular_velocity(::physics::Vector3* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.angular_velocity)
}

// -------------------------------------------------------------------

// GetObjectStateResponse

// string status = 1;
inline void GetObjectStateResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GetObjectStateResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectStateResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.GetObjectStateResponse.status)
}
inline std::string* GetObjectStateResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateResponse.status)
  return _s;
}
inline const std::string& GetObjectStateResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void GetObjectStateResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectStateResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectStateResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateResponse.status)
  return _impl_.status_.Release();
}
inline void GetObjectStateResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateResponse.status)
}

// .physics.ObjectState state = 2;
inline bool GetObjectStateResponse::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool GetObjectStateResponse::has_state() const {
  return _internal_has_state();
}
inline void GetObjectStateResponse::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::physics::ObjectState& GetObjectStateResponse::_internal_state() const {
  const ::physics::ObjectState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::ObjectState&>(
      ::physics::_ObjectState_default_instance_);
}
inline const ::physics::ObjectState& GetObjectStateResponse::state() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateResponse.state)
  return _internal_state();
}
inline void GetObjectStateResponse::unsafe_arena_set_allocated_state(
    ::physics::ObjectState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.GetObjectStateResponse.state)
}
inline ::physics::ObjectState* GetObjectStateResponse::release_state() {
  
  ::physics::ObjectState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::ObjectState* GetObjectStateResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateResponse.state)
  
  ::physics::ObjectState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::physics::ObjectState* GetObjectStateResponse::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::ObjectState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::physics::ObjectState* GetObjectStateResponse::mutable_state() {
  ::physics::ObjectState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateResponse.state)
  return _msg;
}
inline void GetObjectStateResponse::set_allocated_state(::physics::ObjectState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateResponse.state)
}

// -------------------------------------------------------------------

// UpdateObjectMassRequest

// string id = 1;
inline void UpdateObjectMassRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateObjectMassRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectMassRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassRequest.id)
}
inline std::string* UpdateObjectMassRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectMassRequest.id)
  return _s;
}
inline const std::string& UpdateObjectMassRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateObjectMassRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectMassRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectMassRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectMassRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateObjectMassRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectMassRequest.id)
}

// float mass = 2;
inline void UpdateObjectMassRequest::clear_mass() {
  _impl_.mass_ = 0;
}
inline float UpdateObjectMassRequest::_internal_mass() const {
  return _impl_.mass_;
}
inline float UpdateObjectMassRequest::mass() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassRequest.mass)
  return _internal_mass();
}
inline void UpdateObjectMassRequest::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void UpdateObjectMassRequest::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassRequest.mass)
}

// -------------------------------------------------------------------

// UpdateObjectMassResponse

// string status = 1;
inline void UpdateObjectMassResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& UpdateObjectMassResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectMassResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassResponse.status)
}
inline std::string* UpdateObjectMassResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectMassResponse.status)
  return _s;
}
inline const std::string& UpdateObjectMassResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void UpdateObjectMassResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectMassResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectMassResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectMassResponse.status)
  return _impl_.status_.Release();
}
inline void UpdateObjectMassResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectMassResponse.status)
}

// -------------------------------------------------------------------

// UpdateObjectRadiusRequest

// string id = 1;
inline void UpdateObjectRadiusRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateObjectRadiusRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRadiusRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectRadiusRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectRadiusRequest.id)
}
inline std::string* UpdateObjectRadiusRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRadiusRequest.id)
  return _s;
}
inline const std::string& UpdateObjectRadiusRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateObjectRadiusRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectRadiusRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectRadiusRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRadiusRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateObjectRadiusRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRadiusRequest.id)
}

// float radius = 2;
inline void UpdateObjectRadiusRequest::clear_radius() {
  _impl_.radius_ = 0;
}
inline float UpdateObjectRadiusRequest::_internal_radius() const {
  return _impl_.radius_;
}
inline float UpdateObjectRadiusRequest::radius() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRadiusRequest.radius)
  return _internal_radius();
}
inline void UpdateObjectRadiusRequest::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void UpdateObjectRadiusRequest::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:physics.UpdateObjectRadiusRequest.radius)
}

// -------------------------------------------------------------------

// UpdateObjectRadiusResponse

// string status = 1;
inline void UpdateObjectRadiusResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& UpdateObjectRadiusResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRadiusResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectRadiusResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectRadiusResponse.status)
}
inline std::string* UpdateObjectRadiusResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRadiusResponse.status)
  return _s;
}
inline const std::string& UpdateObjectRadiusResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void UpdateObjectRadiusResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectRadiusResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectRadiusResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRadiusResponse.status)
  return _impl_.status_.Release();
}
inline void UpdateObjectRadiusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRadiusResponse.status)
}

// -------------------------------------------------------------------

// UpdateObjectMassAndRadiusRequest

// string id = 1;
inline void UpdateObjectMassAndRadiusRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateObjectMassAndRadiusRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassAndRadiusRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectMassAndRadiusRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassAndRadiusRequest.id)
}
inline std::string* UpdateObjectMassAndRadiusRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectMassAndRadiusRequest.id)
  return _s;
}
inline const std::string& UpdateObjectMassAndRadiusRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateObjectMassAndRadiusRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectMassAndRadiusRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectMassAndRadiusRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectMassAndRadiusRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateObjectMassAndRadiusRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectMassAndRadiusRequest.id)
}

// float mass = 2;
inline void UpdateObjectMassAndRadiusRequest::clear_mass() {
  _impl_.mass_ = 0;
}
inline float UpdateObjectMassAndRadiusRequest::_internal_mass() const {
  return _impl_.mass_;
}
inline float UpdateObjectMassAndRadiusRequest::mass() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassAndRadiusRequest.mass)
  return _internal_mass();
}
inline void UpdateObjectMassAndRadiusRequest::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void UpdateObjectMassAndRadiusRequest::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassAndRadiusRequest.mass)
}

// float radius = 3;
inline void UpdateObjectMassAndRadiusRequest::clear_radius() {
  _impl_.radius_ = 0;
}
inline float UpdateObjectMassAndRadiusRequest::_internal_radius() const {
  return _impl_.radius_;
}
inline float UpdateObjectMassAndRadiusRequest::radius() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassAndRadiusRequest.radius)
  return _internal_radius();
}
inline void UpdateObjectMassAndRadiusRequest::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void UpdateObjectMassAndRadiusRequest::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassAndRadiusRequest.radius)
}

// -------------------------------------------------------------------

// UpdateObjectMassAndRadiusResponse

// string status = 1;
inline void UpdateObjectMassAndRadiusResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& UpdateObjectMassAndRadiusResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectMassAndRadiusResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectMassAndRadiusResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectMassAndRadiusResponse.status)
}
inline std::string* UpdateObjectMassAndRadiusResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectMassAndRadiusResponse.status)
  return _s;
}
inline const std::string& UpdateObjectMassAndRadiusResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void UpdateObjectMassAndRadiusResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectMassAndRadiusResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectMassAndRadiusResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectMassAndRadiusResponse.status)
  return _impl_.status_.Release();
}
inline void UpdateObjectMassAndRadiusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectMassAndRadiusResponse.status)
}

// -------------------------------------------------------------------

// WorldPhysicsConfig

// float gravity_x = 1;
inline void WorldPhysicsConfig::clear_gravity_x() {
  _impl_.gravity_x_ = 0;
}
inline float WorldPhysicsConfig::_internal_gravity_x() const {
  return _impl_.gravity_x_;
}
inline float WorldPhysicsConfig::gravity_x() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.gravity_x)
  return _internal_gravity_x();
}
inline void WorldPhysicsConfig::_internal_set_gravity_x(float value) {
  
  _impl_.gravity_x_ = value;
}
inline void WorldPhysicsConfig::set_gravity_x(float value) {
  _internal_set_gravity_x(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.gravity_x)
}

// float gravity_y = 2;
inline void WorldPhysicsConfig::clear_gravity_y() {
  _impl_.gravity_y_ = 0;
}
inline float WorldPhysicsConfig::_internal_gravity_y() const {
  return _impl_.gravity_y_;
}
inline float WorldPhysicsConfig::gravity_y() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.gravity_y)
  return _internal_gravity_y();
}
inline void WorldPhysicsConfig::_internal_set_gravity_y(float value) {
  
  _impl_.gravity_y_ = value;
}
inline void WorldPhysicsConfig::set_gravity_y(float value) {
  _internal_set_gravity_y(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.gravity_y)
}

// float gravity_z = 3;
inline void WorldPhysicsConfig::clear_gravity_z() {
  _impl_.gravity_z_ = 0;
}
inline float WorldPhysicsConfig::_internal_gravity_z() const {
  return _impl_.gravity_z_;
}
inline float WorldPhysicsConfig::gravity_z() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.gravity_z)
  return _internal_gravity_z();
}
inline void WorldPhysicsConfig::_internal_set_gravity_z(float value) {
  
  _impl_.gravity_z_ = value;
}
inline void WorldPhysicsConfig::set_gravity_z(float value) {
  _internal_set_gravity_z(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.gravity_z)
}

// float linear_damping = 4;
inline void WorldPhysicsConfig::clear_linear_damping() {
  _impl_.linear_damping_ = 0;
}
inline float WorldPhysicsConfig::_internal_linear_damping() const {
  return _impl_.linear_damping_;
}
inline float WorldPhysicsConfig::linear_damping() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.linear_damping)
  return _internal_linear_damping();
}
inline void WorldPhysicsConfig::_internal_set_linear_damping(float value) {
  
  _impl_.linear_damping_ = value;
}
inline void WorldPhysicsConfig::set_linear_damping(float value) {
  _internal_set_linear_damping(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.linear_damping)
}

// float angular_damping = 5;
inline void WorldPhysicsConfig::clear_angular_damping() {
  _impl_.angular_damping_ = 0;
}
inline float WorldPhysicsConfig::_internal_angular_damping() const {
  return _impl_.angular_damping_;
}
inline float WorldPhysicsConfig::angular_damping() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.angular_damping)
  return _internal_angular_damping();
}
inline void WorldPhysicsConfig::_internal_set_angular_damping(float value) {
  
  _impl_.angular_damping_ = value;
}
inline void WorldPhysicsConfig::set_angular_damping(float value) {
  _internal_set_angular_damping(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.angular_damping)
}

// float friction = 6;
inline void WorldPhysicsConfig::clear_friction() {
  _impl_.friction_ = 0;
}
inline float WorldPhysicsConfig::_internal_friction() const {
  return _impl_.friction_;
}
inline float WorldPhysicsConfig::friction() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.friction)
  return _internal_friction();
}
inline void WorldPhysicsConfig::_internal_set_friction(float value) {
  
  _impl_.friction_ = value;
}
inline void WorldPhysicsConfig::set_friction(float value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.friction)
}

// float rolling_friction = 7;
inline void WorldPhysicsConfig::clear_rolling_friction() {
  _impl_.rolling_friction_ = 0;
}
inline float WorldPhysicsConfig::_internal_rolling_friction() const {
  return _impl_.rolling_friction_;
}
inline float WorldPhysicsConfig::rolling_friction() const {
  // @@protoc_insertion_point(field_get:physics.WorldPhysicsConfig.rolling_friction)
  return _internal_rolling_friction();
}
inline void WorldPhysicsConfig::_internal_set_rolling_friction(float value) {
  
  _impl_.rolling_friction_ = value;
}
inline void WorldPhysicsConfig::set_rolling_friction(float value) {
  _internal_set_rolling_friction(value);
  // @@protoc_insertion_point(field_set:physics.WorldPhysicsConfig.rolling_friction)
}

// -------------------------------------------------------------------

// PlayerConfig

// float player_mass = 1;
inline void PlayerConfig::clear_player_mass() {
  _impl_.player_mass_ = 0;
}
inline float PlayerConfig::_internal_player_mass() const {
  return _impl_.player_mass_;
}
inline float PlayerConfig::player_mass() const {
  // @@protoc_insertion_point(field_get:physics.PlayerConfig.player_mass)
  return _internal_player_mass();
}
inline void PlayerConfig::_internal_set_player_mass(float value) {
  
  _impl_.player_mass_ = value;
}
inline void PlayerConfig::set_player_mass(float value) {
  _internal_set_player_mass(value);
  // @@protoc_insertion_point(field_set:physics.PlayerConfig.player_mass)
}

// float restitution = 2;
inline void PlayerConfig::clear_restitution() {
  _impl_.restitution_ = 0;
}
inline float PlayerConfig::_internal_restitution() const {
  return _impl_.restitution_;
}
inline float PlayerConfig::restitution() const {
  // @@protoc_insertion_point(field_get:physics.PlayerConfig.restitution)
  return _internal_restitution();
}
inline void PlayerConfig::_internal_set_restitution(float value) {
  
  _impl_.restitution_ = value;
}
inline void PlayerConfig::set_restitution(float value) {
  _internal_set_restitution(value);
  // @@protoc_insertion_point(field_set:physics.PlayerConfig.restitution)
}

// -------------------------------------------------------------------

// ControlConfig

// float base_impulse = 1;
inline void ControlConfig::clear_base_impulse() {
  _impl_.base_impulse_ = 0;
}
inline float ControlConfig::_internal_base_impulse() const {
  return _impl_.base_impulse_;
}
inline float ControlConfig::base_impulse() const {
  // @@protoc_insertion_point(field_get:physics.ControlConfig.base_impulse)
  return _internal_base_impulse();
}
inline void ControlConfig::_internal_set_base_impulse(float value) {
  
  _impl_.base_impulse_ = value;
}
inline void ControlConfig::set_base_impulse(float value) {
  _internal_set_base_impulse(value);
  // @@protoc_insertion_point(field_set:physics.ControlConfig.base_impulse)
}

// float max_impulse = 2;
inline void ControlConfig::clear_max_impulse() {
  _impl_.max_impulse_ = 0;
}
inline float ControlConfig::_internal_max_impulse() const {
  return _impl_.max_impulse_;
}
inline float ControlConfig::max_impulse() const {
  // @@protoc_insertion_point(field_get:physics.ControlConfig.max_impulse)
  return _internal_max_impulse();
}
inline void ControlConfig::_internal_set_max_impulse(float value) {
  
  _impl_.max_impulse_ = value;
}
inline void ControlConfig::set_max_impulse(float value) {
  _internal_set_max_impulse(value);
  // @@protoc_insertion_point(field_set:physics.ControlConfig.max_impulse)
}

// float distance_multiplier = 3;
inline void ControlConfig::clear_distance_multiplier() {
  _impl_.distance_multiplier_ = 0;
}
inline float ControlConfig::_internal_distance_multiplier() const {
  return _impl_.distance_multiplier_;
}
inline float ControlConfig::distance_multiplier() const {
  // @@protoc_insertion_point(field_get:physics.ControlConfig.distance_multiplier)
  return _internal_distance_multiplier();
}
inline void ControlConfig::_internal_set_distance_multiplier(float value) {
  
  _impl_.distance_multiplier_ = value;
}
inline void ControlConfig::set_distance_multiplier(float value) {
  _internal_set_distance_multiplier(value);
  // @@protoc_insertion_point(field_set:physics.ControlConfig.distance_multiplier)
}

// float impulse_multiplier = 4;
inline void ControlConfig::clear_impulse_multiplier() {
  _impl_.impulse_multiplier_ = 0;
}
inline float ControlConfig::_internal_impulse_multiplier() const {
  return _impl_.impulse_multiplier_;
}
inline float ControlConfig::impulse_multiplier() const {
  // @@protoc_insertion_point(field_get:physics.ControlConfig.impulse_multiplier)
  return _internal_impulse_multiplier();
}
inline void ControlConfig::_internal_set_impulse_multiplier(float value) {
  
  _impl_.impulse_multiplier_ = value;
}
inline void ControlConfig::set_impulse_multiplier(float value) {
  _internal_set_impulse_multiplier(value);
  // @@protoc_insertion_point(field_set:physics.ControlConfig.impulse_multiplier)
}

// -------------------------------------------------------------------

// PhysicsConfig

// .physics.WorldPhysicsConfig world = 1;
inline bool PhysicsConfig::_internal_has_world() const {
  return this != internal_default_instance() && _impl_.world_ != nullptr;
}
inline bool PhysicsConfig::has_world() const {
  return _internal_has_world();
}
inline void PhysicsConfig::clear_world() {
  if (GetArenaForAllocation() == nullptr && _impl_.world_ != nullptr) {
    delete _impl_.world_;
  }
  _impl_.world_ = nullptr;
}
inline const ::physics::WorldPhysicsConfig& PhysicsConfig::_internal_world() const {
  const ::physics::WorldPhysicsConfig* p = _impl_.world_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::WorldPhysicsConfig&>(
      ::physics::_WorldPhysicsConfig_default_instance_);
}
inline const ::physics::WorldPhysicsConfig& PhysicsConfig::world() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfig.world)
  return _internal_world();
}
inline void PhysicsConfig::unsafe_arena_set_allocated_world(
    ::physics::WorldPhysicsConfig* world) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_);
  }
  _impl_.world_ = world;
  if (world) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.PhysicsConfig.world)
}
inline ::physics::WorldPhysicsConfig* PhysicsConfig::release_world() {
  
  ::physics::WorldPhysicsConfig* temp = _impl_.world_;
  _impl_.world_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::WorldPhysicsConfig* PhysicsConfig::unsafe_arena_release_world() {
  // @@protoc_insertion_point(field_release:physics.PhysicsConfig.world)
  
  ::physics::WorldPhysicsConfig* temp = _impl_.world_;
  _impl_.world_ = nullptr;
  return temp;
}
inline ::physics::WorldPhysicsConfig* PhysicsConfig::_internal_mutable_world() {
  
  if (_impl_.world_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::WorldPhysicsConfig>(GetArenaForAllocation());
    _impl_.world_ = p;
  }
  return _impl_.world_;
}
inline ::physics::WorldPhysicsConfig* PhysicsConfig::mutable_world() {
  ::physics::WorldPhysicsConfig* _msg = _internal_mutable_world();
  // @@protoc_insertion_point(field_mutable:physics.PhysicsConfig.world)
  return _msg;
}
inline void PhysicsConfig::set_allocated_world(::physics::WorldPhysicsConfig* world) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.world_;
  }
  if (world) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(world);
    if (message_arena != submessage_arena) {
      world = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.world_ = world;
  // @@protoc_insertion_point(field_set_allocated:physics.PhysicsConfig.world)
}

// .physics.PlayerConfig player = 2;
inline bool PhysicsConfig::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PhysicsConfig::has_player() const {
  return _internal_has_player();
}
inline void PhysicsConfig::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::physics::PlayerConfig& PhysicsConfig::_internal_player() const {
  const ::physics::PlayerConfig* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::PlayerConfig&>(
      ::physics::_PlayerConfig_default_instance_);
}
inline const ::physics::PlayerConfig& PhysicsConfig::player() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfig.player)
  return _internal_player();
}
inline void PhysicsConfig::unsafe_arena_set_allocated_player(
    ::physics::PlayerConfig* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.PhysicsConfig.player)
}
inline ::physics::PlayerConfig* PhysicsConfig::release_player() {
  
  ::physics::PlayerConfig* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::PlayerConfig* PhysicsConfig::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:physics.PhysicsConfig.player)
  
  ::physics::PlayerConfig* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::physics::PlayerConfig* PhysicsConfig::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::PlayerConfig>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::physics::PlayerConfig* PhysicsConfig::mutable_player() {
  ::physics::PlayerConfig* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:physics.PhysicsConfig.player)
  return _msg;
}
inline void PhysicsConfig::set_allocated_player(::physics::PlayerConfig* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:physics.PhysicsConfig.player)
}

// .physics.ControlConfig control = 3;
inline bool PhysicsConfig::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool PhysicsConfig::has_control() const {
  return _internal_has_control();
}
inline void PhysicsConfig::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::physics::ControlConfig& PhysicsConfig::_internal_control() const {
  const ::physics::ControlConfig* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::ControlConfig&>(
      ::physics::_ControlConfig_default_instance_);
}
inline const ::physics::ControlConfig& PhysicsConfig::control() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfig.control)
  return _internal_control();
}
inline void PhysicsConfig::unsafe_arena_set_allocated_control(
    ::physics::ControlConfig* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.PhysicsConfig.control)
}
inline ::physics::ControlConfig* PhysicsConfig::release_control() {
  
  ::physics::ControlConfig* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::ControlConfig* PhysicsConfig::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:physics.PhysicsConfig.control)
  
  ::physics::ControlConfig* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::physics::ControlConfig* PhysicsConfig::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::ControlConfig>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::physics::ControlConfig* PhysicsConfig::mutable_control() {
  ::physics::ControlConfig* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:physics.PhysicsConfig.control)
  return _msg;
}
inline void PhysicsConfig::set_allocated_control(::physics::ControlConfig* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:physics.PhysicsConfig.control)
}

// -------------------------------------------------------------------

// SetPhysicsConfigRequest

// .physics.PhysicsConfig config = 1;
inline bool SetPhysicsConfigRequest::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool SetPhysicsConfigRequest::has_config() const {
  return _internal_has_config();
}
inline void SetPhysicsConfigRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::physics::PhysicsConfig& SetPhysicsConfigRequest::_internal_config() const {
  const ::physics::PhysicsConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::PhysicsConfig&>(
      ::physics::_PhysicsConfig_default_instance_);
}
inline const ::physics::PhysicsConfig& SetPhysicsConfigRequest::config() const {
  // @@protoc_insertion_point(field_get:physics.SetPhysicsConfigRequest.config)
  return _internal_config();
}
inline void SetPhysicsConfigRequest::unsafe_arena_set_allocated_config(
    ::physics::PhysicsConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.SetPhysicsConfigRequest.config)
}
inline ::physics::PhysicsConfig* SetPhysicsConfigRequest::release_config() {
  
  ::physics::PhysicsConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::PhysicsConfig* SetPhysicsConfigRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:physics.SetPhysicsConfigRequest.config)
  
  ::physics::PhysicsConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::physics::PhysicsConfig* SetPhysicsConfigRequest::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::PhysicsConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::physics::PhysicsConfig* SetPhysicsConfigRequest::mutable_config() {
  ::physics::PhysicsConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:physics.SetPhysicsConfigRequest.config)
  return _msg;
}
inline void SetPhysicsConfigRequest::set_allocated_config(::physics::PhysicsConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:physics.SetPhysicsConfigRequest.config)
}

// -------------------------------------------------------------------

// SetPhysicsConfigResponse

// string status = 1;
inline void SetPhysicsConfigResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SetPhysicsConfigResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.SetPhysicsConfigResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPhysicsConfigResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.SetPhysicsConfigResponse.status)
}
inline std::string* SetPhysicsConfigResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.SetPhysicsConfigResponse.status)
  return _s;
}
inline const std::string& SetPhysicsConfigResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SetPhysicsConfigResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.SetPhysicsConfigResponse.status)
  return _impl_.status_.Release();
}
inline void SetPhysicsConfigResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.SetPhysicsConfigResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace physics

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::physics::ShapeDescriptor_ShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physics::ShapeDescriptor_ShapeType>() {
  return ::physics::ShapeDescriptor_ShapeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_physics_2eproto
