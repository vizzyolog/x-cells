// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: physics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_physics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_physics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_physics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_physics_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_physics_2eproto;
namespace physics {
class ApplyImpulseRequest;
struct ApplyImpulseRequestDefaultTypeInternal;
extern ApplyImpulseRequestDefaultTypeInternal _ApplyImpulseRequest_default_instance_;
class ApplyImpulseResponse;
struct ApplyImpulseResponseDefaultTypeInternal;
extern ApplyImpulseResponseDefaultTypeInternal _ApplyImpulseResponse_default_instance_;
class ApplyTorqueRequest;
struct ApplyTorqueRequestDefaultTypeInternal;
extern ApplyTorqueRequestDefaultTypeInternal _ApplyTorqueRequest_default_instance_;
class ApplyTorqueResponse;
struct ApplyTorqueResponseDefaultTypeInternal;
extern ApplyTorqueResponseDefaultTypeInternal _ApplyTorqueResponse_default_instance_;
class BoxData;
struct BoxDataDefaultTypeInternal;
extern BoxDataDefaultTypeInternal _BoxData_default_instance_;
class CreateObjectRequest;
struct CreateObjectRequestDefaultTypeInternal;
extern CreateObjectRequestDefaultTypeInternal _CreateObjectRequest_default_instance_;
class CreateObjectResponse;
struct CreateObjectResponseDefaultTypeInternal;
extern CreateObjectResponseDefaultTypeInternal _CreateObjectResponse_default_instance_;
class GetObjectStateRequest;
struct GetObjectStateRequestDefaultTypeInternal;
extern GetObjectStateRequestDefaultTypeInternal _GetObjectStateRequest_default_instance_;
class GetObjectStateResponse;
struct GetObjectStateResponseDefaultTypeInternal;
extern GetObjectStateResponseDefaultTypeInternal _GetObjectStateResponse_default_instance_;
class GetPhysicsConfigRequest;
struct GetPhysicsConfigRequestDefaultTypeInternal;
extern GetPhysicsConfigRequestDefaultTypeInternal _GetPhysicsConfigRequest_default_instance_;
class GetPhysicsConfigResponse;
struct GetPhysicsConfigResponseDefaultTypeInternal;
extern GetPhysicsConfigResponseDefaultTypeInternal _GetPhysicsConfigResponse_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class ObjectRequest;
struct ObjectRequestDefaultTypeInternal;
extern ObjectRequestDefaultTypeInternal _ObjectRequest_default_instance_;
class ObjectResponse;
struct ObjectResponseDefaultTypeInternal;
extern ObjectResponseDefaultTypeInternal _ObjectResponse_default_instance_;
class ObjectState;
struct ObjectStateDefaultTypeInternal;
extern ObjectStateDefaultTypeInternal _ObjectState_default_instance_;
class PhysicsConfigData;
struct PhysicsConfigDataDefaultTypeInternal;
extern PhysicsConfigDataDefaultTypeInternal _PhysicsConfigData_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class SetPhysicsConfigRequest;
struct SetPhysicsConfigRequestDefaultTypeInternal;
extern SetPhysicsConfigRequestDefaultTypeInternal _SetPhysicsConfigRequest_default_instance_;
class SetPhysicsConfigResponse;
struct SetPhysicsConfigResponseDefaultTypeInternal;
extern SetPhysicsConfigResponseDefaultTypeInternal _SetPhysicsConfigResponse_default_instance_;
class ShapeDescriptor;
struct ShapeDescriptorDefaultTypeInternal;
extern ShapeDescriptorDefaultTypeInternal _ShapeDescriptor_default_instance_;
class SphereData;
struct SphereDataDefaultTypeInternal;
extern SphereDataDefaultTypeInternal _SphereData_default_instance_;
class StepSimulationRequest;
struct StepSimulationRequestDefaultTypeInternal;
extern StepSimulationRequestDefaultTypeInternal _StepSimulationRequest_default_instance_;
class StepSimulationResponse;
struct StepSimulationResponseDefaultTypeInternal;
extern StepSimulationResponseDefaultTypeInternal _StepSimulationResponse_default_instance_;
class TerrainData;
struct TerrainDataDefaultTypeInternal;
extern TerrainDataDefaultTypeInternal _TerrainData_default_instance_;
class UpdateObjectRequest;
struct UpdateObjectRequestDefaultTypeInternal;
extern UpdateObjectRequestDefaultTypeInternal _UpdateObjectRequest_default_instance_;
class UpdateObjectResponse;
struct UpdateObjectResponseDefaultTypeInternal;
extern UpdateObjectResponseDefaultTypeInternal _UpdateObjectResponse_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Velocity;
struct VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace physics
PROTOBUF_NAMESPACE_OPEN
template<> ::physics::ApplyImpulseRequest* Arena::CreateMaybeMessage<::physics::ApplyImpulseRequest>(Arena*);
template<> ::physics::ApplyImpulseResponse* Arena::CreateMaybeMessage<::physics::ApplyImpulseResponse>(Arena*);
template<> ::physics::ApplyTorqueRequest* Arena::CreateMaybeMessage<::physics::ApplyTorqueRequest>(Arena*);
template<> ::physics::ApplyTorqueResponse* Arena::CreateMaybeMessage<::physics::ApplyTorqueResponse>(Arena*);
template<> ::physics::BoxData* Arena::CreateMaybeMessage<::physics::BoxData>(Arena*);
template<> ::physics::CreateObjectRequest* Arena::CreateMaybeMessage<::physics::CreateObjectRequest>(Arena*);
template<> ::physics::CreateObjectResponse* Arena::CreateMaybeMessage<::physics::CreateObjectResponse>(Arena*);
template<> ::physics::GetObjectStateRequest* Arena::CreateMaybeMessage<::physics::GetObjectStateRequest>(Arena*);
template<> ::physics::GetObjectStateResponse* Arena::CreateMaybeMessage<::physics::GetObjectStateResponse>(Arena*);
template<> ::physics::GetPhysicsConfigRequest* Arena::CreateMaybeMessage<::physics::GetPhysicsConfigRequest>(Arena*);
template<> ::physics::GetPhysicsConfigResponse* Arena::CreateMaybeMessage<::physics::GetPhysicsConfigResponse>(Arena*);
template<> ::physics::Object* Arena::CreateMaybeMessage<::physics::Object>(Arena*);
template<> ::physics::ObjectRequest* Arena::CreateMaybeMessage<::physics::ObjectRequest>(Arena*);
template<> ::physics::ObjectResponse* Arena::CreateMaybeMessage<::physics::ObjectResponse>(Arena*);
template<> ::physics::ObjectState* Arena::CreateMaybeMessage<::physics::ObjectState>(Arena*);
template<> ::physics::PhysicsConfigData* Arena::CreateMaybeMessage<::physics::PhysicsConfigData>(Arena*);
template<> ::physics::Position* Arena::CreateMaybeMessage<::physics::Position>(Arena*);
template<> ::physics::Quaternion* Arena::CreateMaybeMessage<::physics::Quaternion>(Arena*);
template<> ::physics::Rotation* Arena::CreateMaybeMessage<::physics::Rotation>(Arena*);
template<> ::physics::SetPhysicsConfigRequest* Arena::CreateMaybeMessage<::physics::SetPhysicsConfigRequest>(Arena*);
template<> ::physics::SetPhysicsConfigResponse* Arena::CreateMaybeMessage<::physics::SetPhysicsConfigResponse>(Arena*);
template<> ::physics::ShapeDescriptor* Arena::CreateMaybeMessage<::physics::ShapeDescriptor>(Arena*);
template<> ::physics::SphereData* Arena::CreateMaybeMessage<::physics::SphereData>(Arena*);
template<> ::physics::StepSimulationRequest* Arena::CreateMaybeMessage<::physics::StepSimulationRequest>(Arena*);
template<> ::physics::StepSimulationResponse* Arena::CreateMaybeMessage<::physics::StepSimulationResponse>(Arena*);
template<> ::physics::TerrainData* Arena::CreateMaybeMessage<::physics::TerrainData>(Arena*);
template<> ::physics::UpdateObjectRequest* Arena::CreateMaybeMessage<::physics::UpdateObjectRequest>(Arena*);
template<> ::physics::UpdateObjectResponse* Arena::CreateMaybeMessage<::physics::UpdateObjectResponse>(Arena*);
template<> ::physics::Vector3* Arena::CreateMaybeMessage<::physics::Vector3>(Arena*);
template<> ::physics::Velocity* Arena::CreateMaybeMessage<::physics::Velocity>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace physics {

enum ShapeDescriptor_ShapeType : int {
  ShapeDescriptor_ShapeType_UNKNOWN = 0,
  ShapeDescriptor_ShapeType_SPHERE = 1,
  ShapeDescriptor_ShapeType_BOX = 2,
  ShapeDescriptor_ShapeType_TERRAIN = 3,
  ShapeDescriptor_ShapeType_ShapeDescriptor_ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeDescriptor_ShapeType_ShapeDescriptor_ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeDescriptor_ShapeType_IsValid(int value);
constexpr ShapeDescriptor_ShapeType ShapeDescriptor_ShapeType_ShapeType_MIN = ShapeDescriptor_ShapeType_UNKNOWN;
constexpr ShapeDescriptor_ShapeType ShapeDescriptor_ShapeType_ShapeType_MAX = ShapeDescriptor_ShapeType_TERRAIN;
constexpr int ShapeDescriptor_ShapeType_ShapeType_ARRAYSIZE = ShapeDescriptor_ShapeType_ShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeDescriptor_ShapeType_descriptor();
template<typename T>
inline const std::string& ShapeDescriptor_ShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeDescriptor_ShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeDescriptor_ShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeDescriptor_ShapeType_descriptor(), enum_t_value);
}
inline bool ShapeDescriptor_ShapeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeDescriptor_ShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeDescriptor_ShapeType>(
    ShapeDescriptor_ShapeType_descriptor(), name, value);
}
// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ShapeDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ShapeDescriptor) */ {
 public:
  inline ShapeDescriptor() : ShapeDescriptor(nullptr) {}
  ~ShapeDescriptor() override;
  explicit PROTOBUF_CONSTEXPR ShapeDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeDescriptor(const ShapeDescriptor& from);
  ShapeDescriptor(ShapeDescriptor&& from) noexcept
    : ShapeDescriptor() {
    *this = ::std::move(from);
  }

  inline ShapeDescriptor& operator=(const ShapeDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeDescriptor& operator=(ShapeDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeDescriptor& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeCase {
    kSphere = 10,
    kBox = 11,
    kTerrain = 12,
    SHAPE_NOT_SET = 0,
  };

  static inline const ShapeDescriptor* internal_default_instance() {
    return reinterpret_cast<const ShapeDescriptor*>(
               &_ShapeDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ShapeDescriptor& a, ShapeDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeDescriptor& from) {
    ShapeDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ShapeDescriptor";
  }
  protected:
  explicit ShapeDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShapeDescriptor_ShapeType ShapeType;
  static constexpr ShapeType UNKNOWN =
    ShapeDescriptor_ShapeType_UNKNOWN;
  static constexpr ShapeType SPHERE =
    ShapeDescriptor_ShapeType_SPHERE;
  static constexpr ShapeType BOX =
    ShapeDescriptor_ShapeType_BOX;
  static constexpr ShapeType TERRAIN =
    ShapeDescriptor_ShapeType_TERRAIN;
  static inline bool ShapeType_IsValid(int value) {
    return ShapeDescriptor_ShapeType_IsValid(value);
  }
  static constexpr ShapeType ShapeType_MIN =
    ShapeDescriptor_ShapeType_ShapeType_MIN;
  static constexpr ShapeType ShapeType_MAX =
    ShapeDescriptor_ShapeType_ShapeType_MAX;
  static constexpr int ShapeType_ARRAYSIZE =
    ShapeDescriptor_ShapeType_ShapeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShapeType_descriptor() {
    return ShapeDescriptor_ShapeType_descriptor();
  }
  template<typename T>
  static inline const std::string& ShapeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShapeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShapeType_Name.");
    return ShapeDescriptor_ShapeType_Name(enum_t_value);
  }
  static inline bool ShapeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShapeType* value) {
    return ShapeDescriptor_ShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSphereFieldNumber = 10,
    kBoxFieldNumber = 11,
    kTerrainFieldNumber = 12,
  };
  // .physics.ShapeDescriptor.ShapeType type = 1;
  void clear_type();
  ::physics::ShapeDescriptor_ShapeType type() const;
  void set_type(::physics::ShapeDescriptor_ShapeType value);
  private:
  ::physics::ShapeDescriptor_ShapeType _internal_type() const;
  void _internal_set_type(::physics::ShapeDescriptor_ShapeType value);
  public:

  // .physics.SphereData sphere = 10;
  bool has_sphere() const;
  private:
  bool _internal_has_sphere() const;
  public:
  void clear_sphere();
  const ::physics::SphereData& sphere() const;
  PROTOBUF_NODISCARD ::physics::SphereData* release_sphere();
  ::physics::SphereData* mutable_sphere();
  void set_allocated_sphere(::physics::SphereData* sphere);
  private:
  const ::physics::SphereData& _internal_sphere() const;
  ::physics::SphereData* _internal_mutable_sphere();
  public:
  void unsafe_arena_set_allocated_sphere(
      ::physics::SphereData* sphere);
  ::physics::SphereData* unsafe_arena_release_sphere();

  // .physics.BoxData box = 11;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::physics::BoxData& box() const;
  PROTOBUF_NODISCARD ::physics::BoxData* release_box();
  ::physics::BoxData* mutable_box();
  void set_allocated_box(::physics::BoxData* box);
  private:
  const ::physics::BoxData& _internal_box() const;
  ::physics::BoxData* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::physics::BoxData* box);
  ::physics::BoxData* unsafe_arena_release_box();

  // .physics.TerrainData terrain = 12;
  bool has_terrain() const;
  private:
  bool _internal_has_terrain() const;
  public:
  void clear_terrain();
  const ::physics::TerrainData& terrain() const;
  PROTOBUF_NODISCARD ::physics::TerrainData* release_terrain();
  ::physics::TerrainData* mutable_terrain();
  void set_allocated_terrain(::physics::TerrainData* terrain);
  private:
  const ::physics::TerrainData& _internal_terrain() const;
  ::physics::TerrainData* _internal_mutable_terrain();
  public:
  void unsafe_arena_set_allocated_terrain(
      ::physics::TerrainData* terrain);
  ::physics::TerrainData* unsafe_arena_release_terrain();

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:physics.ShapeDescriptor)
 private:
  class _Internal;
  void set_has_sphere();
  void set_has_box();
  void set_has_terrain();

  inline bool has_shape() const;
  inline void clear_has_shape();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union ShapeUnion {
      constexpr ShapeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::physics::SphereData* sphere_;
      ::physics::BoxData* box_;
      ::physics::TerrainData* terrain_;
    } shape_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SphereData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SphereData) */ {
 public:
  inline SphereData() : SphereData(nullptr) {}
  ~SphereData() override;
  explicit PROTOBUF_CONSTEXPR SphereData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SphereData(const SphereData& from);
  SphereData(SphereData&& from) noexcept
    : SphereData() {
    *this = ::std::move(from);
  }

  inline SphereData& operator=(const SphereData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SphereData& operator=(SphereData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SphereData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SphereData* internal_default_instance() {
    return reinterpret_cast<const SphereData*>(
               &_SphereData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SphereData& a, SphereData& b) {
    a.Swap(&b);
  }
  inline void Swap(SphereData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SphereData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SphereData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SphereData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SphereData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SphereData& from) {
    SphereData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SphereData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SphereData";
  }
  protected:
  explicit SphereData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 3,
    kRadiusFieldNumber = 1,
    kMassFieldNumber = 2,
  };
  // string color = 3;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float radius = 1;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float mass = 2;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.SphereData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float radius_;
    float mass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class BoxData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.BoxData) */ {
 public:
  inline BoxData() : BoxData(nullptr) {}
  ~BoxData() override;
  explicit PROTOBUF_CONSTEXPR BoxData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxData(const BoxData& from);
  BoxData(BoxData&& from) noexcept
    : BoxData() {
    *this = ::std::move(from);
  }

  inline BoxData& operator=(const BoxData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxData& operator=(BoxData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxData* internal_default_instance() {
    return reinterpret_cast<const BoxData*>(
               &_BoxData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BoxData& a, BoxData& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxData& from) {
    BoxData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.BoxData";
  }
  protected:
  explicit BoxData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
    kMassFieldNumber = 4,
  };
  // string color = 5;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float width = 1;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 2;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float depth = 3;
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // float mass = 4;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.BoxData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float width_;
    float height_;
    float depth_;
    float mass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class TerrainData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.TerrainData) */ {
 public:
  inline TerrainData() : TerrainData(nullptr) {}
  ~TerrainData() override;
  explicit PROTOBUF_CONSTEXPR TerrainData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerrainData(const TerrainData& from);
  TerrainData(TerrainData&& from) noexcept
    : TerrainData() {
    *this = ::std::move(from);
  }

  inline TerrainData& operator=(const TerrainData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerrainData& operator=(TerrainData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerrainData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerrainData* internal_default_instance() {
    return reinterpret_cast<const TerrainData*>(
               &_TerrainData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TerrainData& a, TerrainData& b) {
    a.Swap(&b);
  }
  inline void Swap(TerrainData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerrainData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerrainData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerrainData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerrainData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerrainData& from) {
    TerrainData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerrainData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.TerrainData";
  }
  protected:
  explicit TerrainData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightmapFieldNumber = 3,
    kWidthFieldNumber = 1,
    kDepthFieldNumber = 2,
    kScaleXFieldNumber = 4,
    kScaleYFieldNumber = 5,
    kScaleZFieldNumber = 6,
    kMinHeightFieldNumber = 7,
    kMaxHeightFieldNumber = 8,
  };
  // repeated float heightmap = 3;
  int heightmap_size() const;
  private:
  int _internal_heightmap_size() const;
  public:
  void clear_heightmap();
  private:
  float _internal_heightmap(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_heightmap() const;
  void _internal_add_heightmap(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_heightmap();
  public:
  float heightmap(int index) const;
  void set_heightmap(int index, float value);
  void add_heightmap(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      heightmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_heightmap();

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 depth = 2;
  void clear_depth();
  int32_t depth() const;
  void set_depth(int32_t value);
  private:
  int32_t _internal_depth() const;
  void _internal_set_depth(int32_t value);
  public:

  // float scale_x = 4;
  void clear_scale_x();
  float scale_x() const;
  void set_scale_x(float value);
  private:
  float _internal_scale_x() const;
  void _internal_set_scale_x(float value);
  public:

  // float scale_y = 5;
  void clear_scale_y();
  float scale_y() const;
  void set_scale_y(float value);
  private:
  float _internal_scale_y() const;
  void _internal_set_scale_y(float value);
  public:

  // float scale_z = 6;
  void clear_scale_z();
  float scale_z() const;
  void set_scale_z(float value);
  private:
  float _internal_scale_z() const;
  void _internal_set_scale_z(float value);
  public:

  // float min_height = 7;
  void clear_min_height();
  float min_height() const;
  void set_min_height(float value);
  private:
  float _internal_min_height() const;
  void _internal_set_min_height(float value);
  public:

  // float max_height = 8;
  void clear_max_height();
  float max_height() const;
  void set_max_height(float value);
  private:
  float _internal_max_height() const;
  void _internal_set_max_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.TerrainData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > heightmap_;
    int32_t width_;
    int32_t depth_;
    float scale_x_;
    float scale_y_;
    float scale_z_;
    float min_height_;
    float max_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class PhysicsConfigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.PhysicsConfigData) */ {
 public:
  inline PhysicsConfigData() : PhysicsConfigData(nullptr) {}
  ~PhysicsConfigData() override;
  explicit PROTOBUF_CONSTEXPR PhysicsConfigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicsConfigData(const PhysicsConfigData& from);
  PhysicsConfigData(PhysicsConfigData&& from) noexcept
    : PhysicsConfigData() {
    *this = ::std::move(from);
  }

  inline PhysicsConfigData& operator=(const PhysicsConfigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicsConfigData& operator=(PhysicsConfigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicsConfigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicsConfigData* internal_default_instance() {
    return reinterpret_cast<const PhysicsConfigData*>(
               &_PhysicsConfigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PhysicsConfigData& a, PhysicsConfigData& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicsConfigData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicsConfigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhysicsConfigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhysicsConfigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicsConfigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhysicsConfigData& from) {
    PhysicsConfigData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicsConfigData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.PhysicsConfigData";
  }
  protected:
  explicit PhysicsConfigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseImpulseFieldNumber = 1,
    kMaxImpulseFieldNumber = 2,
    kDistanceMultiplierFieldNumber = 3,
    kImpulseMultiplierFieldNumber = 4,
    kMaxSpeedFieldNumber = 5,
    kRestitutionFieldNumber = 6,
    kMaxImpulseMagnitudeFieldNumber = 7,
    kTerrainRestitutionFieldNumber = 8,
    kObjectRestitutionFieldNumber = 9,
    kFrictionFieldNumber = 10,
    kRollingFrictionFieldNumber = 11,
    kLinearDampingFieldNumber = 12,
    kAngularDampingFieldNumber = 13,
    kCcdMotionThresholdFactorFieldNumber = 14,
    kCcdSweptSphereRadiusFactorFieldNumber = 15,
    kMinSpeedFactorFieldNumber = 16,
    kStepSimulationRateFieldNumber = 17,
    kCcdMotionThresholdFieldNumber = 18,
    kCcdSweptSphereRadiusFieldNumber = 19,
  };
  // float base_impulse = 1;
  void clear_base_impulse();
  float base_impulse() const;
  void set_base_impulse(float value);
  private:
  float _internal_base_impulse() const;
  void _internal_set_base_impulse(float value);
  public:

  // float max_impulse = 2;
  void clear_max_impulse();
  float max_impulse() const;
  void set_max_impulse(float value);
  private:
  float _internal_max_impulse() const;
  void _internal_set_max_impulse(float value);
  public:

  // float distance_multiplier = 3;
  void clear_distance_multiplier();
  float distance_multiplier() const;
  void set_distance_multiplier(float value);
  private:
  float _internal_distance_multiplier() const;
  void _internal_set_distance_multiplier(float value);
  public:

  // float impulse_multiplier = 4;
  void clear_impulse_multiplier();
  float impulse_multiplier() const;
  void set_impulse_multiplier(float value);
  private:
  float _internal_impulse_multiplier() const;
  void _internal_set_impulse_multiplier(float value);
  public:

  // float max_speed = 5;
  void clear_max_speed();
  float max_speed() const;
  void set_max_speed(float value);
  private:
  float _internal_max_speed() const;
  void _internal_set_max_speed(float value);
  public:

  // float restitution = 6;
  void clear_restitution();
  float restitution() const;
  void set_restitution(float value);
  private:
  float _internal_restitution() const;
  void _internal_set_restitution(float value);
  public:

  // float max_impulse_magnitude = 7;
  void clear_max_impulse_magnitude();
  float max_impulse_magnitude() const;
  void set_max_impulse_magnitude(float value);
  private:
  float _internal_max_impulse_magnitude() const;
  void _internal_set_max_impulse_magnitude(float value);
  public:

  // float terrain_restitution = 8;
  void clear_terrain_restitution();
  float terrain_restitution() const;
  void set_terrain_restitution(float value);
  private:
  float _internal_terrain_restitution() const;
  void _internal_set_terrain_restitution(float value);
  public:

  // float object_restitution = 9;
  void clear_object_restitution();
  float object_restitution() const;
  void set_object_restitution(float value);
  private:
  float _internal_object_restitution() const;
  void _internal_set_object_restitution(float value);
  public:

  // float friction = 10;
  void clear_friction();
  float friction() const;
  void set_friction(float value);
  private:
  float _internal_friction() const;
  void _internal_set_friction(float value);
  public:

  // float rolling_friction = 11;
  void clear_rolling_friction();
  float rolling_friction() const;
  void set_rolling_friction(float value);
  private:
  float _internal_rolling_friction() const;
  void _internal_set_rolling_friction(float value);
  public:

  // float linear_damping = 12;
  void clear_linear_damping();
  float linear_damping() const;
  void set_linear_damping(float value);
  private:
  float _internal_linear_damping() const;
  void _internal_set_linear_damping(float value);
  public:

  // float angular_damping = 13;
  void clear_angular_damping();
  float angular_damping() const;
  void set_angular_damping(float value);
  private:
  float _internal_angular_damping() const;
  void _internal_set_angular_damping(float value);
  public:

  // float ccd_motion_threshold_factor = 14;
  void clear_ccd_motion_threshold_factor();
  float ccd_motion_threshold_factor() const;
  void set_ccd_motion_threshold_factor(float value);
  private:
  float _internal_ccd_motion_threshold_factor() const;
  void _internal_set_ccd_motion_threshold_factor(float value);
  public:

  // float ccd_swept_sphere_radius_factor = 15;
  void clear_ccd_swept_sphere_radius_factor();
  float ccd_swept_sphere_radius_factor() const;
  void set_ccd_swept_sphere_radius_factor(float value);
  private:
  float _internal_ccd_swept_sphere_radius_factor() const;
  void _internal_set_ccd_swept_sphere_radius_factor(float value);
  public:

  // float min_speed_factor = 16;
  void clear_min_speed_factor();
  float min_speed_factor() const;
  void set_min_speed_factor(float value);
  private:
  float _internal_min_speed_factor() const;
  void _internal_set_min_speed_factor(float value);
  public:

  // float step_simulation_rate = 17;
  void clear_step_simulation_rate();
  float step_simulation_rate() const;
  void set_step_simulation_rate(float value);
  private:
  float _internal_step_simulation_rate() const;
  void _internal_set_step_simulation_rate(float value);
  public:

  // float ccd_motion_threshold = 18;
  void clear_ccd_motion_threshold();
  float ccd_motion_threshold() const;
  void set_ccd_motion_threshold(float value);
  private:
  float _internal_ccd_motion_threshold() const;
  void _internal_set_ccd_motion_threshold(float value);
  public:

  // float ccd_swept_sphere_radius = 19;
  void clear_ccd_swept_sphere_radius();
  float ccd_swept_sphere_radius() const;
  void set_ccd_swept_sphere_radius(float value);
  private:
  float _internal_ccd_swept_sphere_radius() const;
  void _internal_set_ccd_swept_sphere_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.PhysicsConfigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float base_impulse_;
    float max_impulse_;
    float distance_multiplier_;
    float impulse_multiplier_;
    float max_speed_;
    float restitution_;
    float max_impulse_magnitude_;
    float terrain_restitution_;
    float object_restitution_;
    float friction_;
    float rolling_friction_;
    float linear_damping_;
    float angular_damping_;
    float ccd_motion_threshold_factor_;
    float ccd_swept_sphere_radius_factor_;
    float min_speed_factor_;
    float step_simulation_rate_;
    float ccd_motion_threshold_;
    float ccd_swept_sphere_radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.CreateObjectRequest) */ {
 public:
  inline CreateObjectRequest() : CreateObjectRequest(nullptr) {}
  ~CreateObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateObjectRequest(const CreateObjectRequest& from);
  CreateObjectRequest(CreateObjectRequest&& from) noexcept
    : CreateObjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateObjectRequest& operator=(const CreateObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectRequest& operator=(CreateObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateObjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateObjectRequest*>(
               &_CreateObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateObjectRequest& a, CreateObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateObjectRequest& from) {
    CreateObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.CreateObjectRequest";
  }
  protected:
  explicit CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kShapeFieldNumber = 4,
    kLinearVelocityFieldNumber = 6,
    kAngularVelocityFieldNumber = 7,
    kMassFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Vector3& position() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_position();
  ::physics::Vector3* mutable_position();
  void set_allocated_position(::physics::Vector3* position);
  private:
  const ::physics::Vector3& _internal_position() const;
  ::physics::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Vector3* position);
  ::physics::Vector3* unsafe_arena_release_position();

  // .physics.Quaternion rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::physics::Quaternion* release_rotation();
  ::physics::Quaternion* mutable_rotation();
  void set_allocated_rotation(::physics::Quaternion* rotation);
  private:
  const ::physics::Quaternion& _internal_rotation() const;
  ::physics::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Quaternion* rotation);
  ::physics::Quaternion* unsafe_arena_release_rotation();

  // .physics.ShapeDescriptor shape = 4;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::physics::ShapeDescriptor& shape() const;
  PROTOBUF_NODISCARD ::physics::ShapeDescriptor* release_shape();
  ::physics::ShapeDescriptor* mutable_shape();
  void set_allocated_shape(::physics::ShapeDescriptor* shape);
  private:
  const ::physics::ShapeDescriptor& _internal_shape() const;
  ::physics::ShapeDescriptor* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::physics::ShapeDescriptor* shape);
  ::physics::ShapeDescriptor* unsafe_arena_release_shape();

  // .physics.Vector3 linear_velocity = 6;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::physics::Vector3& linear_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_linear_velocity();
  ::physics::Vector3* mutable_linear_velocity();
  void set_allocated_linear_velocity(::physics::Vector3* linear_velocity);
  private:
  const ::physics::Vector3& _internal_linear_velocity() const;
  ::physics::Vector3* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::physics::Vector3* linear_velocity);
  ::physics::Vector3* unsafe_arena_release_linear_velocity();

  // .physics.Vector3 angular_velocity = 7;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::physics::Vector3& angular_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_angular_velocity();
  ::physics::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::physics::Vector3* angular_velocity);
  private:
  const ::physics::Vector3& _internal_angular_velocity() const;
  ::physics::Vector3* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::physics::Vector3* angular_velocity);
  ::physics::Vector3* unsafe_arena_release_angular_velocity();

  // float mass = 5;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.CreateObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* position_;
    ::physics::Quaternion* rotation_;
    ::physics::ShapeDescriptor* shape_;
    ::physics::Vector3* linear_velocity_;
    ::physics::Vector3* angular_velocity_;
    float mass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.CreateObjectResponse) */ {
 public:
  inline CreateObjectResponse() : CreateObjectResponse(nullptr) {}
  ~CreateObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateObjectResponse(const CreateObjectResponse& from);
  CreateObjectResponse(CreateObjectResponse&& from) noexcept
    : CreateObjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateObjectResponse& operator=(const CreateObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectResponse& operator=(CreateObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateObjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateObjectResponse*>(
               &_CreateObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateObjectResponse& a, CreateObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateObjectResponse& from) {
    CreateObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.CreateObjectResponse";
  }
  protected:
  explicit CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:physics.CreateObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyImpulseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyImpulseRequest) */ {
 public:
  inline ApplyImpulseRequest() : ApplyImpulseRequest(nullptr) {}
  ~ApplyImpulseRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyImpulseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyImpulseRequest(const ApplyImpulseRequest& from);
  ApplyImpulseRequest(ApplyImpulseRequest&& from) noexcept
    : ApplyImpulseRequest() {
    *this = ::std::move(from);
  }

  inline ApplyImpulseRequest& operator=(const ApplyImpulseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyImpulseRequest& operator=(ApplyImpulseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyImpulseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyImpulseRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyImpulseRequest*>(
               &_ApplyImpulseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ApplyImpulseRequest& a, ApplyImpulseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyImpulseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyImpulseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyImpulseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyImpulseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyImpulseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyImpulseRequest& from) {
    ApplyImpulseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyImpulseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyImpulseRequest";
  }
  protected:
  explicit ApplyImpulseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kImpulseFieldNumber = 2,
    kRelativePositionFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 impulse = 2;
  bool has_impulse() const;
  private:
  bool _internal_has_impulse() const;
  public:
  void clear_impulse();
  const ::physics::Vector3& impulse() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_impulse();
  ::physics::Vector3* mutable_impulse();
  void set_allocated_impulse(::physics::Vector3* impulse);
  private:
  const ::physics::Vector3& _internal_impulse() const;
  ::physics::Vector3* _internal_mutable_impulse();
  public:
  void unsafe_arena_set_allocated_impulse(
      ::physics::Vector3* impulse);
  ::physics::Vector3* unsafe_arena_release_impulse();

  // .physics.Vector3 relative_position = 3;
  bool has_relative_position() const;
  private:
  bool _internal_has_relative_position() const;
  public:
  void clear_relative_position();
  const ::physics::Vector3& relative_position() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_relative_position();
  ::physics::Vector3* mutable_relative_position();
  void set_allocated_relative_position(::physics::Vector3* relative_position);
  private:
  const ::physics::Vector3& _internal_relative_position() const;
  ::physics::Vector3* _internal_mutable_relative_position();
  public:
  void unsafe_arena_set_allocated_relative_position(
      ::physics::Vector3* relative_position);
  ::physics::Vector3* unsafe_arena_release_relative_position();

  // @@protoc_insertion_point(class_scope:physics.ApplyImpulseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* impulse_;
    ::physics::Vector3* relative_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyImpulseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyImpulseResponse) */ {
 public:
  inline ApplyImpulseResponse() : ApplyImpulseResponse(nullptr) {}
  ~ApplyImpulseResponse() override;
  explicit PROTOBUF_CONSTEXPR ApplyImpulseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyImpulseResponse(const ApplyImpulseResponse& from);
  ApplyImpulseResponse(ApplyImpulseResponse&& from) noexcept
    : ApplyImpulseResponse() {
    *this = ::std::move(from);
  }

  inline ApplyImpulseResponse& operator=(const ApplyImpulseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyImpulseResponse& operator=(ApplyImpulseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyImpulseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyImpulseResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyImpulseResponse*>(
               &_ApplyImpulseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApplyImpulseResponse& a, ApplyImpulseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyImpulseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyImpulseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyImpulseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyImpulseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyImpulseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyImpulseResponse& from) {
    ApplyImpulseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyImpulseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyImpulseResponse";
  }
  protected:
  explicit ApplyImpulseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:physics.ApplyImpulseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyTorqueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyTorqueRequest) */ {
 public:
  inline ApplyTorqueRequest() : ApplyTorqueRequest(nullptr) {}
  ~ApplyTorqueRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyTorqueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyTorqueRequest(const ApplyTorqueRequest& from);
  ApplyTorqueRequest(ApplyTorqueRequest&& from) noexcept
    : ApplyTorqueRequest() {
    *this = ::std::move(from);
  }

  inline ApplyTorqueRequest& operator=(const ApplyTorqueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyTorqueRequest& operator=(ApplyTorqueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyTorqueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyTorqueRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyTorqueRequest*>(
               &_ApplyTorqueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApplyTorqueRequest& a, ApplyTorqueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyTorqueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyTorqueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyTorqueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyTorqueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyTorqueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyTorqueRequest& from) {
    ApplyTorqueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyTorqueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyTorqueRequest";
  }
  protected:
  explicit ApplyTorqueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Vector3 torque = 2;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::physics::Vector3& torque() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_torque();
  ::physics::Vector3* mutable_torque();
  void set_allocated_torque(::physics::Vector3* torque);
  private:
  const ::physics::Vector3& _internal_torque() const;
  ::physics::Vector3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::physics::Vector3* torque);
  ::physics::Vector3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:physics.ApplyTorqueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Vector3* torque_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ApplyTorqueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ApplyTorqueResponse) */ {
 public:
  inline ApplyTorqueResponse() : ApplyTorqueResponse(nullptr) {}
  ~ApplyTorqueResponse() override;
  explicit PROTOBUF_CONSTEXPR ApplyTorqueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyTorqueResponse(const ApplyTorqueResponse& from);
  ApplyTorqueResponse(ApplyTorqueResponse&& from) noexcept
    : ApplyTorqueResponse() {
    *this = ::std::move(from);
  }

  inline ApplyTorqueResponse& operator=(const ApplyTorqueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyTorqueResponse& operator=(ApplyTorqueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyTorqueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyTorqueResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyTorqueResponse*>(
               &_ApplyTorqueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ApplyTorqueResponse& a, ApplyTorqueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyTorqueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyTorqueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyTorqueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyTorqueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyTorqueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyTorqueResponse& from) {
    ApplyTorqueResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyTorqueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ApplyTorqueResponse";
  }
  protected:
  explicit ApplyTorqueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:physics.ApplyTorqueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Rotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  explicit PROTOBUF_CONSTEXPR Rotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rotation(const Rotation& from);
  Rotation(Rotation&& from) noexcept
    : Rotation() {
    *this = ::std::move(from);
  }

  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
               &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Rotation& a, Rotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Rotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rotation& from) {
    Rotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Rotation";
  }
  protected:
  explicit Rotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
    kYawFieldNumber = 5,
    kPitchFieldNumber = 6,
    kRollFieldNumber = 7,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float yaw = 5;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 6;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 7;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Rotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float w_;
    float yaw_;
    float pitch_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Velocity) */ {
 public:
  inline Velocity() : Velocity(nullptr) {}
  ~Velocity() override;
  explicit PROTOBUF_CONSTEXPR Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Velocity(const Velocity& from);
  Velocity(Velocity&& from) noexcept
    : Velocity() {
    *this = ::std::move(from);
  }

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Velocity& operator=(Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
               &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Velocity& a, Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(Velocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Velocity& from) {
    Velocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Velocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Velocity";
  }
  protected:
  explicit Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit PROTOBUF_CONSTEXPR Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kLinearVelocityFieldNumber = 4,
    kAngularVelocityFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Position& position() const;
  PROTOBUF_NODISCARD ::physics::Position* release_position();
  ::physics::Position* mutable_position();
  void set_allocated_position(::physics::Position* position);
  private:
  const ::physics::Position& _internal_position() const;
  ::physics::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Position* position);
  ::physics::Position* unsafe_arena_release_position();

  // .physics.Rotation rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::physics::Rotation* release_rotation();
  ::physics::Rotation* mutable_rotation();
  void set_allocated_rotation(::physics::Rotation* rotation);
  private:
  const ::physics::Rotation& _internal_rotation() const;
  ::physics::Rotation* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Rotation* rotation);
  ::physics::Rotation* unsafe_arena_release_rotation();

  // .physics.Velocity linear_velocity = 4;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::physics::Velocity& linear_velocity() const;
  PROTOBUF_NODISCARD ::physics::Velocity* release_linear_velocity();
  ::physics::Velocity* mutable_linear_velocity();
  void set_allocated_linear_velocity(::physics::Velocity* linear_velocity);
  private:
  const ::physics::Velocity& _internal_linear_velocity() const;
  ::physics::Velocity* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::physics::Velocity* linear_velocity);
  ::physics::Velocity* unsafe_arena_release_linear_velocity();

  // .physics.Velocity angular_velocity = 5;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::physics::Velocity& angular_velocity() const;
  PROTOBUF_NODISCARD ::physics::Velocity* release_angular_velocity();
  ::physics::Velocity* mutable_angular_velocity();
  void set_allocated_angular_velocity(::physics::Velocity* angular_velocity);
  private:
  const ::physics::Velocity& _internal_angular_velocity() const;
  ::physics::Velocity* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::physics::Velocity* angular_velocity);
  ::physics::Velocity* unsafe_arena_release_angular_velocity();

  // @@protoc_insertion_point(class_scope:physics.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Position* position_;
    ::physics::Rotation* rotation_;
    ::physics::Velocity* linear_velocity_;
    ::physics::Velocity* angular_velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectRequest) */ {
 public:
  inline UpdateObjectRequest() : UpdateObjectRequest(nullptr) {}
  ~UpdateObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectRequest(const UpdateObjectRequest& from);
  UpdateObjectRequest(UpdateObjectRequest&& from) noexcept
    : UpdateObjectRequest() {
    *this = ::std::move(from);
  }

  inline UpdateObjectRequest& operator=(const UpdateObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectRequest& operator=(UpdateObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectRequest*>(
               &_UpdateObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateObjectRequest& a, UpdateObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectRequest& from) {
    UpdateObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectRequest";
  }
  protected:
  explicit UpdateObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kLinearVelocityFieldNumber = 4,
    kAngularVelocityFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .physics.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Position& position() const;
  PROTOBUF_NODISCARD ::physics::Position* release_position();
  ::physics::Position* mutable_position();
  void set_allocated_position(::physics::Position* position);
  private:
  const ::physics::Position& _internal_position() const;
  ::physics::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Position* position);
  ::physics::Position* unsafe_arena_release_position();

  // .physics.Rotation rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::physics::Rotation* release_rotation();
  ::physics::Rotation* mutable_rotation();
  void set_allocated_rotation(::physics::Rotation* rotation);
  private:
  const ::physics::Rotation& _internal_rotation() const;
  ::physics::Rotation* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Rotation* rotation);
  ::physics::Rotation* unsafe_arena_release_rotation();

  // .physics.Vector3 linear_velocity = 4;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::physics::Vector3& linear_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_linear_velocity();
  ::physics::Vector3* mutable_linear_velocity();
  void set_allocated_linear_velocity(::physics::Vector3* linear_velocity);
  private:
  const ::physics::Vector3& _internal_linear_velocity() const;
  ::physics::Vector3* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::physics::Vector3* linear_velocity);
  ::physics::Vector3* unsafe_arena_release_linear_velocity();

  // .physics.Vector3 angular_velocity = 5;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::physics::Vector3& angular_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_angular_velocity();
  ::physics::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::physics::Vector3* angular_velocity);
  private:
  const ::physics::Vector3& _internal_angular_velocity() const;
  ::physics::Vector3* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::physics::Vector3* angular_velocity);
  ::physics::Vector3* unsafe_arena_release_angular_velocity();

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::physics::Position* position_;
    ::physics::Rotation* rotation_;
    ::physics::Vector3* linear_velocity_;
    ::physics::Vector3* angular_velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class UpdateObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.UpdateObjectResponse) */ {
 public:
  inline UpdateObjectResponse() : UpdateObjectResponse(nullptr) {}
  ~UpdateObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateObjectResponse(const UpdateObjectResponse& from);
  UpdateObjectResponse(UpdateObjectResponse&& from) noexcept
    : UpdateObjectResponse() {
    *this = ::std::move(from);
  }

  inline UpdateObjectResponse& operator=(const UpdateObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateObjectResponse& operator=(UpdateObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateObjectResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateObjectResponse*>(
               &_UpdateObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateObjectResponse& a, UpdateObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateObjectResponse& from) {
    UpdateObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.UpdateObjectResponse";
  }
  protected:
  explicit UpdateObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:physics.UpdateObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class StepSimulationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.StepSimulationRequest) */ {
 public:
  inline StepSimulationRequest() : StepSimulationRequest(nullptr) {}
  ~StepSimulationRequest() override;
  explicit PROTOBUF_CONSTEXPR StepSimulationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepSimulationRequest(const StepSimulationRequest& from);
  StepSimulationRequest(StepSimulationRequest&& from) noexcept
    : StepSimulationRequest() {
    *this = ::std::move(from);
  }

  inline StepSimulationRequest& operator=(const StepSimulationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepSimulationRequest& operator=(StepSimulationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepSimulationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepSimulationRequest* internal_default_instance() {
    return reinterpret_cast<const StepSimulationRequest*>(
               &_StepSimulationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StepSimulationRequest& a, StepSimulationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StepSimulationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepSimulationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepSimulationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepSimulationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepSimulationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepSimulationRequest& from) {
    StepSimulationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepSimulationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.StepSimulationRequest";
  }
  protected:
  explicit StepSimulationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStepFieldNumber = 1,
  };
  // float time_step = 1;
  void clear_time_step();
  float time_step() const;
  void set_time_step(float value);
  private:
  float _internal_time_step() const;
  void _internal_set_time_step(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.StepSimulationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float time_step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class StepSimulationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.StepSimulationResponse) */ {
 public:
  inline StepSimulationResponse() : StepSimulationResponse(nullptr) {}
  ~StepSimulationResponse() override;
  explicit PROTOBUF_CONSTEXPR StepSimulationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepSimulationResponse(const StepSimulationResponse& from);
  StepSimulationResponse(StepSimulationResponse&& from) noexcept
    : StepSimulationResponse() {
    *this = ::std::move(from);
  }

  inline StepSimulationResponse& operator=(const StepSimulationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepSimulationResponse& operator=(StepSimulationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepSimulationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepSimulationResponse* internal_default_instance() {
    return reinterpret_cast<const StepSimulationResponse*>(
               &_StepSimulationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StepSimulationResponse& a, StepSimulationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StepSimulationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepSimulationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepSimulationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepSimulationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepSimulationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepSimulationResponse& from) {
    StepSimulationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepSimulationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.StepSimulationResponse";
  }
  protected:
  explicit StepSimulationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 3,
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // repeated .physics.Object objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::physics::Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::physics::Object >*
      mutable_objects();
  private:
  const ::physics::Object& _internal_objects(int index) const;
  ::physics::Object* _internal_add_objects();
  public:
  const ::physics::Object& objects(int index) const;
  ::physics::Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::physics::Object >&
      objects() const;

  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:physics.StepSimulationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::physics::Object > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ObjectRequest) */ {
 public:
  inline ObjectRequest() : ObjectRequest(nullptr) {}
  ~ObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR ObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectRequest(const ObjectRequest& from);
  ObjectRequest(ObjectRequest&& from) noexcept
    : ObjectRequest() {
    *this = ::std::move(from);
  }

  inline ObjectRequest& operator=(const ObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectRequest& operator=(ObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectRequest* internal_default_instance() {
    return reinterpret_cast<const ObjectRequest*>(
               &_ObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ObjectRequest& a, ObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectRequest& from) {
    ObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ObjectRequest";
  }
  protected:
  explicit ObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:physics.ObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ObjectResponse) */ {
 public:
  inline ObjectResponse() : ObjectResponse(nullptr) {}
  ~ObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR ObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectResponse(const ObjectResponse& from);
  ObjectResponse(ObjectResponse&& from) noexcept
    : ObjectResponse() {
    *this = ::std::move(from);
  }

  inline ObjectResponse& operator=(const ObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectResponse& operator=(ObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectResponse* internal_default_instance() {
    return reinterpret_cast<const ObjectResponse*>(
               &_ObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ObjectResponse& a, ObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectResponse& from) {
    ObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ObjectResponse";
  }
  protected:
  explicit ObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kQxFieldNumber = 5,
    kQyFieldNumber = 6,
    kQzFieldNumber = 7,
    kQwFieldNumber = 8,
    kVxFieldNumber = 9,
    kVyFieldNumber = 10,
    kVzFieldNumber = 11,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float qx = 5;
  void clear_qx();
  float qx() const;
  void set_qx(float value);
  private:
  float _internal_qx() const;
  void _internal_set_qx(float value);
  public:

  // float qy = 6;
  void clear_qy();
  float qy() const;
  void set_qy(float value);
  private:
  float _internal_qy() const;
  void _internal_set_qy(float value);
  public:

  // float qz = 7;
  void clear_qz();
  float qz() const;
  void set_qz(float value);
  private:
  float _internal_qz() const;
  void _internal_set_qz(float value);
  public:

  // float qw = 8;
  void clear_qw();
  float qw() const;
  void set_qw(float value);
  private:
  float _internal_qw() const;
  void _internal_set_qw(float value);
  public:

  // float vx = 9;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 10;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float vz = 11;
  void clear_vz();
  float vz() const;
  void set_vz(float value);
  private:
  float _internal_vz() const;
  void _internal_set_vz(float value);
  public:

  // @@protoc_insertion_point(class_scope:physics.ObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    float x_;
    float y_;
    float z_;
    float qx_;
    float qy_;
    float qz_;
    float qw_;
    float vx_;
    float vy_;
    float vz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetObjectStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.GetObjectStateRequest) */ {
 public:
  inline GetObjectStateRequest() : GetObjectStateRequest(nullptr) {}
  ~GetObjectStateRequest() override;
  explicit PROTOBUF_CONSTEXPR GetObjectStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectStateRequest(const GetObjectStateRequest& from);
  GetObjectStateRequest(GetObjectStateRequest&& from) noexcept
    : GetObjectStateRequest() {
    *this = ::std::move(from);
  }

  inline GetObjectStateRequest& operator=(const GetObjectStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectStateRequest& operator=(GetObjectStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetObjectStateRequest*>(
               &_GetObjectStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetObjectStateRequest& a, GetObjectStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectStateRequest& from) {
    GetObjectStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetObjectStateRequest";
  }
  protected:
  explicit GetObjectStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:physics.GetObjectStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class ObjectState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.ObjectState) */ {
 public:
  inline ObjectState() : ObjectState(nullptr) {}
  ~ObjectState() override;
  explicit PROTOBUF_CONSTEXPR ObjectState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectState(const ObjectState& from);
  ObjectState(ObjectState&& from) noexcept
    : ObjectState() {
    *this = ::std::move(from);
  }

  inline ObjectState& operator=(const ObjectState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectState& operator=(ObjectState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectState* internal_default_instance() {
    return reinterpret_cast<const ObjectState*>(
               &_ObjectState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ObjectState& a, ObjectState& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectState& from) {
    ObjectState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.ObjectState";
  }
  protected:
  explicit ObjectState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kLinearVelocityFieldNumber = 3,
    kAngularVelocityFieldNumber = 4,
  };
  // .physics.Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::physics::Vector3& position() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_position();
  ::physics::Vector3* mutable_position();
  void set_allocated_position(::physics::Vector3* position);
  private:
  const ::physics::Vector3& _internal_position() const;
  ::physics::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::physics::Vector3* position);
  ::physics::Vector3* unsafe_arena_release_position();

  // .physics.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::physics::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::physics::Quaternion* release_rotation();
  ::physics::Quaternion* mutable_rotation();
  void set_allocated_rotation(::physics::Quaternion* rotation);
  private:
  const ::physics::Quaternion& _internal_rotation() const;
  ::physics::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::physics::Quaternion* rotation);
  ::physics::Quaternion* unsafe_arena_release_rotation();

  // .physics.Vector3 linear_velocity = 3;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::physics::Vector3& linear_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_linear_velocity();
  ::physics::Vector3* mutable_linear_velocity();
  void set_allocated_linear_velocity(::physics::Vector3* linear_velocity);
  private:
  const ::physics::Vector3& _internal_linear_velocity() const;
  ::physics::Vector3* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::physics::Vector3* linear_velocity);
  ::physics::Vector3* unsafe_arena_release_linear_velocity();

  // .physics.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::physics::Vector3& angular_velocity() const;
  PROTOBUF_NODISCARD ::physics::Vector3* release_angular_velocity();
  ::physics::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::physics::Vector3* angular_velocity);
  private:
  const ::physics::Vector3& _internal_angular_velocity() const;
  ::physics::Vector3* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::physics::Vector3* angular_velocity);
  ::physics::Vector3* unsafe_arena_release_angular_velocity();

  // @@protoc_insertion_point(class_scope:physics.ObjectState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::physics::Vector3* position_;
    ::physics::Quaternion* rotation_;
    ::physics::Vector3* linear_velocity_;
    ::physics::Vector3* angular_velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetObjectStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.GetObjectStateResponse) */ {
 public:
  inline GetObjectStateResponse() : GetObjectStateResponse(nullptr) {}
  ~GetObjectStateResponse() override;
  explicit PROTOBUF_CONSTEXPR GetObjectStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectStateResponse(const GetObjectStateResponse& from);
  GetObjectStateResponse(GetObjectStateResponse&& from) noexcept
    : GetObjectStateResponse() {
    *this = ::std::move(from);
  }

  inline GetObjectStateResponse& operator=(const GetObjectStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectStateResponse& operator=(GetObjectStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetObjectStateResponse*>(
               &_GetObjectStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetObjectStateResponse& a, GetObjectStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectStateResponse& from) {
    GetObjectStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetObjectStateResponse";
  }
  protected:
  explicit GetObjectStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .physics.ObjectState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::physics::ObjectState& state() const;
  PROTOBUF_NODISCARD ::physics::ObjectState* release_state();
  ::physics::ObjectState* mutable_state();
  void set_allocated_state(::physics::ObjectState* state);
  private:
  const ::physics::ObjectState& _internal_state() const;
  ::physics::ObjectState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::physics::ObjectState* state);
  ::physics::ObjectState* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:physics.GetObjectStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::physics::ObjectState* state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetPhysicsConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:physics.GetPhysicsConfigRequest) */ {
 public:
  inline GetPhysicsConfigRequest() : GetPhysicsConfigRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPhysicsConfigRequest(const GetPhysicsConfigRequest& from);
  GetPhysicsConfigRequest(GetPhysicsConfigRequest&& from) noexcept
    : GetPhysicsConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetPhysicsConfigRequest& operator=(const GetPhysicsConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPhysicsConfigRequest& operator=(GetPhysicsConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPhysicsConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPhysicsConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetPhysicsConfigRequest*>(
               &_GetPhysicsConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetPhysicsConfigRequest& a, GetPhysicsConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPhysicsConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPhysicsConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPhysicsConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPhysicsConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPhysicsConfigRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPhysicsConfigRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetPhysicsConfigRequest";
  }
  protected:
  explicit GetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:physics.GetPhysicsConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class GetPhysicsConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.GetPhysicsConfigResponse) */ {
 public:
  inline GetPhysicsConfigResponse() : GetPhysicsConfigResponse(nullptr) {}
  ~GetPhysicsConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPhysicsConfigResponse(const GetPhysicsConfigResponse& from);
  GetPhysicsConfigResponse(GetPhysicsConfigResponse&& from) noexcept
    : GetPhysicsConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetPhysicsConfigResponse& operator=(const GetPhysicsConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPhysicsConfigResponse& operator=(GetPhysicsConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPhysicsConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPhysicsConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetPhysicsConfigResponse*>(
               &_GetPhysicsConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetPhysicsConfigResponse& a, GetPhysicsConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPhysicsConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPhysicsConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPhysicsConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPhysicsConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPhysicsConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPhysicsConfigResponse& from) {
    GetPhysicsConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPhysicsConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.GetPhysicsConfigResponse";
  }
  protected:
  explicit GetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .physics.PhysicsConfigData config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::physics::PhysicsConfigData& config() const;
  PROTOBUF_NODISCARD ::physics::PhysicsConfigData* release_config();
  ::physics::PhysicsConfigData* mutable_config();
  void set_allocated_config(::physics::PhysicsConfigData* config);
  private:
  const ::physics::PhysicsConfigData& _internal_config() const;
  ::physics::PhysicsConfigData* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::physics::PhysicsConfigData* config);
  ::physics::PhysicsConfigData* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:physics.GetPhysicsConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::physics::PhysicsConfigData* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SetPhysicsConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SetPhysicsConfigRequest) */ {
 public:
  inline SetPhysicsConfigRequest() : SetPhysicsConfigRequest(nullptr) {}
  ~SetPhysicsConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPhysicsConfigRequest(const SetPhysicsConfigRequest& from);
  SetPhysicsConfigRequest(SetPhysicsConfigRequest&& from) noexcept
    : SetPhysicsConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetPhysicsConfigRequest& operator=(const SetPhysicsConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPhysicsConfigRequest& operator=(SetPhysicsConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPhysicsConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPhysicsConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetPhysicsConfigRequest*>(
               &_SetPhysicsConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetPhysicsConfigRequest& a, SetPhysicsConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPhysicsConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPhysicsConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPhysicsConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPhysicsConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPhysicsConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPhysicsConfigRequest& from) {
    SetPhysicsConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPhysicsConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SetPhysicsConfigRequest";
  }
  protected:
  explicit SetPhysicsConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .physics.PhysicsConfigData config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::physics::PhysicsConfigData& config() const;
  PROTOBUF_NODISCARD ::physics::PhysicsConfigData* release_config();
  ::physics::PhysicsConfigData* mutable_config();
  void set_allocated_config(::physics::PhysicsConfigData* config);
  private:
  const ::physics::PhysicsConfigData& _internal_config() const;
  ::physics::PhysicsConfigData* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::physics::PhysicsConfigData* config);
  ::physics::PhysicsConfigData* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:physics.SetPhysicsConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::physics::PhysicsConfigData* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// -------------------------------------------------------------------

class SetPhysicsConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:physics.SetPhysicsConfigResponse) */ {
 public:
  inline SetPhysicsConfigResponse() : SetPhysicsConfigResponse(nullptr) {}
  ~SetPhysicsConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR SetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPhysicsConfigResponse(const SetPhysicsConfigResponse& from);
  SetPhysicsConfigResponse(SetPhysicsConfigResponse&& from) noexcept
    : SetPhysicsConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetPhysicsConfigResponse& operator=(const SetPhysicsConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPhysicsConfigResponse& operator=(SetPhysicsConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPhysicsConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPhysicsConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetPhysicsConfigResponse*>(
               &_SetPhysicsConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SetPhysicsConfigResponse& a, SetPhysicsConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPhysicsConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPhysicsConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPhysicsConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPhysicsConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPhysicsConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPhysicsConfigResponse& from) {
    SetPhysicsConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPhysicsConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "physics.SetPhysicsConfigResponse";
  }
  protected:
  explicit SetPhysicsConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:physics.SetPhysicsConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_physics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:physics.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Vector3.z)
}

// -------------------------------------------------------------------

// Quaternion

// float x = 1;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline float Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.x)
}

// float y = 2;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline float Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.y)
}

// float z = 3;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline float Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.z)
}

// float w = 4;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline float Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:physics.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void Quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:physics.Quaternion.w)
}

// -------------------------------------------------------------------

// ShapeDescriptor

// .physics.ShapeDescriptor.ShapeType type = 1;
inline void ShapeDescriptor::clear_type() {
  _impl_.type_ = 0;
}
inline ::physics::ShapeDescriptor_ShapeType ShapeDescriptor::_internal_type() const {
  return static_cast< ::physics::ShapeDescriptor_ShapeType >(_impl_.type_);
}
inline ::physics::ShapeDescriptor_ShapeType ShapeDescriptor::type() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.type)
  return _internal_type();
}
inline void ShapeDescriptor::_internal_set_type(::physics::ShapeDescriptor_ShapeType value) {
  
  _impl_.type_ = value;
}
inline void ShapeDescriptor::set_type(::physics::ShapeDescriptor_ShapeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:physics.ShapeDescriptor.type)
}

// .physics.SphereData sphere = 10;
inline bool ShapeDescriptor::_internal_has_sphere() const {
  return shape_case() == kSphere;
}
inline bool ShapeDescriptor::has_sphere() const {
  return _internal_has_sphere();
}
inline void ShapeDescriptor::set_has_sphere() {
  _impl_._oneof_case_[0] = kSphere;
}
inline void ShapeDescriptor::clear_sphere() {
  if (_internal_has_sphere()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.sphere_;
    }
    clear_has_shape();
  }
}
inline ::physics::SphereData* ShapeDescriptor::release_sphere() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.sphere)
  if (_internal_has_sphere()) {
    clear_has_shape();
    ::physics::SphereData* temp = _impl_.shape_.sphere_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::SphereData& ShapeDescriptor::_internal_sphere() const {
  return _internal_has_sphere()
      ? *_impl_.shape_.sphere_
      : reinterpret_cast< ::physics::SphereData&>(::physics::_SphereData_default_instance_);
}
inline const ::physics::SphereData& ShapeDescriptor::sphere() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.sphere)
  return _internal_sphere();
}
inline ::physics::SphereData* ShapeDescriptor::unsafe_arena_release_sphere() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.sphere)
  if (_internal_has_sphere()) {
    clear_has_shape();
    ::physics::SphereData* temp = _impl_.shape_.sphere_;
    _impl_.shape_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_sphere(::physics::SphereData* sphere) {
  clear_shape();
  if (sphere) {
    set_has_sphere();
    _impl_.shape_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.sphere)
}
inline ::physics::SphereData* ShapeDescriptor::_internal_mutable_sphere() {
  if (!_internal_has_sphere()) {
    clear_shape();
    set_has_sphere();
    _impl_.shape_.sphere_ = CreateMaybeMessage< ::physics::SphereData >(GetArenaForAllocation());
  }
  return _impl_.shape_.sphere_;
}
inline ::physics::SphereData* ShapeDescriptor::mutable_sphere() {
  ::physics::SphereData* _msg = _internal_mutable_sphere();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.sphere)
  return _msg;
}

// .physics.BoxData box = 11;
inline bool ShapeDescriptor::_internal_has_box() const {
  return shape_case() == kBox;
}
inline bool ShapeDescriptor::has_box() const {
  return _internal_has_box();
}
inline void ShapeDescriptor::set_has_box() {
  _impl_._oneof_case_[0] = kBox;
}
inline void ShapeDescriptor::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.box_;
    }
    clear_has_shape();
  }
}
inline ::physics::BoxData* ShapeDescriptor::release_box() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.box)
  if (_internal_has_box()) {
    clear_has_shape();
    ::physics::BoxData* temp = _impl_.shape_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::BoxData& ShapeDescriptor::_internal_box() const {
  return _internal_has_box()
      ? *_impl_.shape_.box_
      : reinterpret_cast< ::physics::BoxData&>(::physics::_BoxData_default_instance_);
}
inline const ::physics::BoxData& ShapeDescriptor::box() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.box)
  return _internal_box();
}
inline ::physics::BoxData* ShapeDescriptor::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.box)
  if (_internal_has_box()) {
    clear_has_shape();
    ::physics::BoxData* temp = _impl_.shape_.box_;
    _impl_.shape_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_box(::physics::BoxData* box) {
  clear_shape();
  if (box) {
    set_has_box();
    _impl_.shape_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.box)
}
inline ::physics::BoxData* ShapeDescriptor::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_shape();
    set_has_box();
    _impl_.shape_.box_ = CreateMaybeMessage< ::physics::BoxData >(GetArenaForAllocation());
  }
  return _impl_.shape_.box_;
}
inline ::physics::BoxData* ShapeDescriptor::mutable_box() {
  ::physics::BoxData* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.box)
  return _msg;
}

// .physics.TerrainData terrain = 12;
inline bool ShapeDescriptor::_internal_has_terrain() const {
  return shape_case() == kTerrain;
}
inline bool ShapeDescriptor::has_terrain() const {
  return _internal_has_terrain();
}
inline void ShapeDescriptor::set_has_terrain() {
  _impl_._oneof_case_[0] = kTerrain;
}
inline void ShapeDescriptor::clear_terrain() {
  if (_internal_has_terrain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_.terrain_;
    }
    clear_has_shape();
  }
}
inline ::physics::TerrainData* ShapeDescriptor::release_terrain() {
  // @@protoc_insertion_point(field_release:physics.ShapeDescriptor.terrain)
  if (_internal_has_terrain()) {
    clear_has_shape();
    ::physics::TerrainData* temp = _impl_.shape_.terrain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::physics::TerrainData& ShapeDescriptor::_internal_terrain() const {
  return _internal_has_terrain()
      ? *_impl_.shape_.terrain_
      : reinterpret_cast< ::physics::TerrainData&>(::physics::_TerrainData_default_instance_);
}
inline const ::physics::TerrainData& ShapeDescriptor::terrain() const {
  // @@protoc_insertion_point(field_get:physics.ShapeDescriptor.terrain)
  return _internal_terrain();
}
inline ::physics::TerrainData* ShapeDescriptor::unsafe_arena_release_terrain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:physics.ShapeDescriptor.terrain)
  if (_internal_has_terrain()) {
    clear_has_shape();
    ::physics::TerrainData* temp = _impl_.shape_.terrain_;
    _impl_.shape_.terrain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDescriptor::unsafe_arena_set_allocated_terrain(::physics::TerrainData* terrain) {
  clear_shape();
  if (terrain) {
    set_has_terrain();
    _impl_.shape_.terrain_ = terrain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ShapeDescriptor.terrain)
}
inline ::physics::TerrainData* ShapeDescriptor::_internal_mutable_terrain() {
  if (!_internal_has_terrain()) {
    clear_shape();
    set_has_terrain();
    _impl_.shape_.terrain_ = CreateMaybeMessage< ::physics::TerrainData >(GetArenaForAllocation());
  }
  return _impl_.shape_.terrain_;
}
inline ::physics::TerrainData* ShapeDescriptor::mutable_terrain() {
  ::physics::TerrainData* _msg = _internal_mutable_terrain();
  // @@protoc_insertion_point(field_mutable:physics.ShapeDescriptor.terrain)
  return _msg;
}

inline bool ShapeDescriptor::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void ShapeDescriptor::clear_has_shape() {
  _impl_._oneof_case_[0] = SHAPE_NOT_SET;
}
inline ShapeDescriptor::ShapeCase ShapeDescriptor::shape_case() const {
  return ShapeDescriptor::ShapeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SphereData

// float radius = 1;
inline void SphereData::clear_radius() {
  _impl_.radius_ = 0;
}
inline float SphereData::_internal_radius() const {
  return _impl_.radius_;
}
inline float SphereData::radius() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.radius)
  return _internal_radius();
}
inline void SphereData::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void SphereData::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.radius)
}

// float mass = 2;
inline void SphereData::clear_mass() {
  _impl_.mass_ = 0;
}
inline float SphereData::_internal_mass() const {
  return _impl_.mass_;
}
inline float SphereData::mass() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.mass)
  return _internal_mass();
}
inline void SphereData::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void SphereData::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.SphereData.mass)
}

// string color = 3;
inline void SphereData::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& SphereData::color() const {
  // @@protoc_insertion_point(field_get:physics.SphereData.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SphereData::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.SphereData.color)
}
inline std::string* SphereData::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:physics.SphereData.color)
  return _s;
}
inline const std::string& SphereData::_internal_color() const {
  return _impl_.color_.Get();
}
inline void SphereData::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* SphereData::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* SphereData::release_color() {
  // @@protoc_insertion_point(field_release:physics.SphereData.color)
  return _impl_.color_.Release();
}
inline void SphereData::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.SphereData.color)
}

// -------------------------------------------------------------------

// BoxData

// float width = 1;
inline void BoxData::clear_width() {
  _impl_.width_ = 0;
}
inline float BoxData::_internal_width() const {
  return _impl_.width_;
}
inline float BoxData::width() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.width)
  return _internal_width();
}
inline void BoxData::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void BoxData::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.width)
}

// float height = 2;
inline void BoxData::clear_height() {
  _impl_.height_ = 0;
}
inline float BoxData::_internal_height() const {
  return _impl_.height_;
}
inline float BoxData::height() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.height)
  return _internal_height();
}
inline void BoxData::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void BoxData::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.height)
}

// float depth = 3;
inline void BoxData::clear_depth() {
  _impl_.depth_ = 0;
}
inline float BoxData::_internal_depth() const {
  return _impl_.depth_;
}
inline float BoxData::depth() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.depth)
  return _internal_depth();
}
inline void BoxData::_internal_set_depth(float value) {
  
  _impl_.depth_ = value;
}
inline void BoxData::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.depth)
}

// float mass = 4;
inline void BoxData::clear_mass() {
  _impl_.mass_ = 0;
}
inline float BoxData::_internal_mass() const {
  return _impl_.mass_;
}
inline float BoxData::mass() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.mass)
  return _internal_mass();
}
inline void BoxData::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void BoxData::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.BoxData.mass)
}

// string color = 5;
inline void BoxData::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& BoxData::color() const {
  // @@protoc_insertion_point(field_get:physics.BoxData.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BoxData::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.BoxData.color)
}
inline std::string* BoxData::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:physics.BoxData.color)
  return _s;
}
inline const std::string& BoxData::_internal_color() const {
  return _impl_.color_.Get();
}
inline void BoxData::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* BoxData::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* BoxData::release_color() {
  // @@protoc_insertion_point(field_release:physics.BoxData.color)
  return _impl_.color_.Release();
}
inline void BoxData::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.BoxData.color)
}

// -------------------------------------------------------------------

// TerrainData

// int32 width = 1;
inline void TerrainData::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t TerrainData::_internal_width() const {
  return _impl_.width_;
}
inline int32_t TerrainData::width() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.width)
  return _internal_width();
}
inline void TerrainData::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void TerrainData::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.width)
}

// int32 depth = 2;
inline void TerrainData::clear_depth() {
  _impl_.depth_ = 0;
}
inline int32_t TerrainData::_internal_depth() const {
  return _impl_.depth_;
}
inline int32_t TerrainData::depth() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.depth)
  return _internal_depth();
}
inline void TerrainData::_internal_set_depth(int32_t value) {
  
  _impl_.depth_ = value;
}
inline void TerrainData::set_depth(int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.depth)
}

// repeated float heightmap = 3;
inline int TerrainData::_internal_heightmap_size() const {
  return _impl_.heightmap_.size();
}
inline int TerrainData::heightmap_size() const {
  return _internal_heightmap_size();
}
inline void TerrainData::clear_heightmap() {
  _impl_.heightmap_.Clear();
}
inline float TerrainData::_internal_heightmap(int index) const {
  return _impl_.heightmap_.Get(index);
}
inline float TerrainData::heightmap(int index) const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.heightmap)
  return _internal_heightmap(index);
}
inline void TerrainData::set_heightmap(int index, float value) {
  _impl_.heightmap_.Set(index, value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.heightmap)
}
inline void TerrainData::_internal_add_heightmap(float value) {
  _impl_.heightmap_.Add(value);
}
inline void TerrainData::add_heightmap(float value) {
  _internal_add_heightmap(value);
  // @@protoc_insertion_point(field_add:physics.TerrainData.heightmap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TerrainData::_internal_heightmap() const {
  return _impl_.heightmap_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TerrainData::heightmap() const {
  // @@protoc_insertion_point(field_list:physics.TerrainData.heightmap)
  return _internal_heightmap();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TerrainData::_internal_mutable_heightmap() {
  return &_impl_.heightmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TerrainData::mutable_heightmap() {
  // @@protoc_insertion_point(field_mutable_list:physics.TerrainData.heightmap)
  return _internal_mutable_heightmap();
}

// float scale_x = 4;
inline void TerrainData::clear_scale_x() {
  _impl_.scale_x_ = 0;
}
inline float TerrainData::_internal_scale_x() const {
  return _impl_.scale_x_;
}
inline float TerrainData::scale_x() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_x)
  return _internal_scale_x();
}
inline void TerrainData::_internal_set_scale_x(float value) {
  
  _impl_.scale_x_ = value;
}
inline void TerrainData::set_scale_x(float value) {
  _internal_set_scale_x(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_x)
}

// float scale_y = 5;
inline void TerrainData::clear_scale_y() {
  _impl_.scale_y_ = 0;
}
inline float TerrainData::_internal_scale_y() const {
  return _impl_.scale_y_;
}
inline float TerrainData::scale_y() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_y)
  return _internal_scale_y();
}
inline void TerrainData::_internal_set_scale_y(float value) {
  
  _impl_.scale_y_ = value;
}
inline void TerrainData::set_scale_y(float value) {
  _internal_set_scale_y(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_y)
}

// float scale_z = 6;
inline void TerrainData::clear_scale_z() {
  _impl_.scale_z_ = 0;
}
inline float TerrainData::_internal_scale_z() const {
  return _impl_.scale_z_;
}
inline float TerrainData::scale_z() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.scale_z)
  return _internal_scale_z();
}
inline void TerrainData::_internal_set_scale_z(float value) {
  
  _impl_.scale_z_ = value;
}
inline void TerrainData::set_scale_z(float value) {
  _internal_set_scale_z(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.scale_z)
}

// float min_height = 7;
inline void TerrainData::clear_min_height() {
  _impl_.min_height_ = 0;
}
inline float TerrainData::_internal_min_height() const {
  return _impl_.min_height_;
}
inline float TerrainData::min_height() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.min_height)
  return _internal_min_height();
}
inline void TerrainData::_internal_set_min_height(float value) {
  
  _impl_.min_height_ = value;
}
inline void TerrainData::set_min_height(float value) {
  _internal_set_min_height(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.min_height)
}

// float max_height = 8;
inline void TerrainData::clear_max_height() {
  _impl_.max_height_ = 0;
}
inline float TerrainData::_internal_max_height() const {
  return _impl_.max_height_;
}
inline float TerrainData::max_height() const {
  // @@protoc_insertion_point(field_get:physics.TerrainData.max_height)
  return _internal_max_height();
}
inline void TerrainData::_internal_set_max_height(float value) {
  
  _impl_.max_height_ = value;
}
inline void TerrainData::set_max_height(float value) {
  _internal_set_max_height(value);
  // @@protoc_insertion_point(field_set:physics.TerrainData.max_height)
}

// -------------------------------------------------------------------

// PhysicsConfigData

// float base_impulse = 1;
inline void PhysicsConfigData::clear_base_impulse() {
  _impl_.base_impulse_ = 0;
}
inline float PhysicsConfigData::_internal_base_impulse() const {
  return _impl_.base_impulse_;
}
inline float PhysicsConfigData::base_impulse() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.base_impulse)
  return _internal_base_impulse();
}
inline void PhysicsConfigData::_internal_set_base_impulse(float value) {
  
  _impl_.base_impulse_ = value;
}
inline void PhysicsConfigData::set_base_impulse(float value) {
  _internal_set_base_impulse(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.base_impulse)
}

// float max_impulse = 2;
inline void PhysicsConfigData::clear_max_impulse() {
  _impl_.max_impulse_ = 0;
}
inline float PhysicsConfigData::_internal_max_impulse() const {
  return _impl_.max_impulse_;
}
inline float PhysicsConfigData::max_impulse() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.max_impulse)
  return _internal_max_impulse();
}
inline void PhysicsConfigData::_internal_set_max_impulse(float value) {
  
  _impl_.max_impulse_ = value;
}
inline void PhysicsConfigData::set_max_impulse(float value) {
  _internal_set_max_impulse(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.max_impulse)
}

// float distance_multiplier = 3;
inline void PhysicsConfigData::clear_distance_multiplier() {
  _impl_.distance_multiplier_ = 0;
}
inline float PhysicsConfigData::_internal_distance_multiplier() const {
  return _impl_.distance_multiplier_;
}
inline float PhysicsConfigData::distance_multiplier() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.distance_multiplier)
  return _internal_distance_multiplier();
}
inline void PhysicsConfigData::_internal_set_distance_multiplier(float value) {
  
  _impl_.distance_multiplier_ = value;
}
inline void PhysicsConfigData::set_distance_multiplier(float value) {
  _internal_set_distance_multiplier(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.distance_multiplier)
}

// float impulse_multiplier = 4;
inline void PhysicsConfigData::clear_impulse_multiplier() {
  _impl_.impulse_multiplier_ = 0;
}
inline float PhysicsConfigData::_internal_impulse_multiplier() const {
  return _impl_.impulse_multiplier_;
}
inline float PhysicsConfigData::impulse_multiplier() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.impulse_multiplier)
  return _internal_impulse_multiplier();
}
inline void PhysicsConfigData::_internal_set_impulse_multiplier(float value) {
  
  _impl_.impulse_multiplier_ = value;
}
inline void PhysicsConfigData::set_impulse_multiplier(float value) {
  _internal_set_impulse_multiplier(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.impulse_multiplier)
}

// float max_speed = 5;
inline void PhysicsConfigData::clear_max_speed() {
  _impl_.max_speed_ = 0;
}
inline float PhysicsConfigData::_internal_max_speed() const {
  return _impl_.max_speed_;
}
inline float PhysicsConfigData::max_speed() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.max_speed)
  return _internal_max_speed();
}
inline void PhysicsConfigData::_internal_set_max_speed(float value) {
  
  _impl_.max_speed_ = value;
}
inline void PhysicsConfigData::set_max_speed(float value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.max_speed)
}

// float restitution = 6;
inline void PhysicsConfigData::clear_restitution() {
  _impl_.restitution_ = 0;
}
inline float PhysicsConfigData::_internal_restitution() const {
  return _impl_.restitution_;
}
inline float PhysicsConfigData::restitution() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.restitution)
  return _internal_restitution();
}
inline void PhysicsConfigData::_internal_set_restitution(float value) {
  
  _impl_.restitution_ = value;
}
inline void PhysicsConfigData::set_restitution(float value) {
  _internal_set_restitution(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.restitution)
}

// float max_impulse_magnitude = 7;
inline void PhysicsConfigData::clear_max_impulse_magnitude() {
  _impl_.max_impulse_magnitude_ = 0;
}
inline float PhysicsConfigData::_internal_max_impulse_magnitude() const {
  return _impl_.max_impulse_magnitude_;
}
inline float PhysicsConfigData::max_impulse_magnitude() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.max_impulse_magnitude)
  return _internal_max_impulse_magnitude();
}
inline void PhysicsConfigData::_internal_set_max_impulse_magnitude(float value) {
  
  _impl_.max_impulse_magnitude_ = value;
}
inline void PhysicsConfigData::set_max_impulse_magnitude(float value) {
  _internal_set_max_impulse_magnitude(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.max_impulse_magnitude)
}

// float terrain_restitution = 8;
inline void PhysicsConfigData::clear_terrain_restitution() {
  _impl_.terrain_restitution_ = 0;
}
inline float PhysicsConfigData::_internal_terrain_restitution() const {
  return _impl_.terrain_restitution_;
}
inline float PhysicsConfigData::terrain_restitution() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.terrain_restitution)
  return _internal_terrain_restitution();
}
inline void PhysicsConfigData::_internal_set_terrain_restitution(float value) {
  
  _impl_.terrain_restitution_ = value;
}
inline void PhysicsConfigData::set_terrain_restitution(float value) {
  _internal_set_terrain_restitution(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.terrain_restitution)
}

// float object_restitution = 9;
inline void PhysicsConfigData::clear_object_restitution() {
  _impl_.object_restitution_ = 0;
}
inline float PhysicsConfigData::_internal_object_restitution() const {
  return _impl_.object_restitution_;
}
inline float PhysicsConfigData::object_restitution() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.object_restitution)
  return _internal_object_restitution();
}
inline void PhysicsConfigData::_internal_set_object_restitution(float value) {
  
  _impl_.object_restitution_ = value;
}
inline void PhysicsConfigData::set_object_restitution(float value) {
  _internal_set_object_restitution(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.object_restitution)
}

// float friction = 10;
inline void PhysicsConfigData::clear_friction() {
  _impl_.friction_ = 0;
}
inline float PhysicsConfigData::_internal_friction() const {
  return _impl_.friction_;
}
inline float PhysicsConfigData::friction() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.friction)
  return _internal_friction();
}
inline void PhysicsConfigData::_internal_set_friction(float value) {
  
  _impl_.friction_ = value;
}
inline void PhysicsConfigData::set_friction(float value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.friction)
}

// float rolling_friction = 11;
inline void PhysicsConfigData::clear_rolling_friction() {
  _impl_.rolling_friction_ = 0;
}
inline float PhysicsConfigData::_internal_rolling_friction() const {
  return _impl_.rolling_friction_;
}
inline float PhysicsConfigData::rolling_friction() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.rolling_friction)
  return _internal_rolling_friction();
}
inline void PhysicsConfigData::_internal_set_rolling_friction(float value) {
  
  _impl_.rolling_friction_ = value;
}
inline void PhysicsConfigData::set_rolling_friction(float value) {
  _internal_set_rolling_friction(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.rolling_friction)
}

// float linear_damping = 12;
inline void PhysicsConfigData::clear_linear_damping() {
  _impl_.linear_damping_ = 0;
}
inline float PhysicsConfigData::_internal_linear_damping() const {
  return _impl_.linear_damping_;
}
inline float PhysicsConfigData::linear_damping() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.linear_damping)
  return _internal_linear_damping();
}
inline void PhysicsConfigData::_internal_set_linear_damping(float value) {
  
  _impl_.linear_damping_ = value;
}
inline void PhysicsConfigData::set_linear_damping(float value) {
  _internal_set_linear_damping(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.linear_damping)
}

// float angular_damping = 13;
inline void PhysicsConfigData::clear_angular_damping() {
  _impl_.angular_damping_ = 0;
}
inline float PhysicsConfigData::_internal_angular_damping() const {
  return _impl_.angular_damping_;
}
inline float PhysicsConfigData::angular_damping() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.angular_damping)
  return _internal_angular_damping();
}
inline void PhysicsConfigData::_internal_set_angular_damping(float value) {
  
  _impl_.angular_damping_ = value;
}
inline void PhysicsConfigData::set_angular_damping(float value) {
  _internal_set_angular_damping(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.angular_damping)
}

// float ccd_motion_threshold_factor = 14;
inline void PhysicsConfigData::clear_ccd_motion_threshold_factor() {
  _impl_.ccd_motion_threshold_factor_ = 0;
}
inline float PhysicsConfigData::_internal_ccd_motion_threshold_factor() const {
  return _impl_.ccd_motion_threshold_factor_;
}
inline float PhysicsConfigData::ccd_motion_threshold_factor() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.ccd_motion_threshold_factor)
  return _internal_ccd_motion_threshold_factor();
}
inline void PhysicsConfigData::_internal_set_ccd_motion_threshold_factor(float value) {
  
  _impl_.ccd_motion_threshold_factor_ = value;
}
inline void PhysicsConfigData::set_ccd_motion_threshold_factor(float value) {
  _internal_set_ccd_motion_threshold_factor(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.ccd_motion_threshold_factor)
}

// float ccd_swept_sphere_radius_factor = 15;
inline void PhysicsConfigData::clear_ccd_swept_sphere_radius_factor() {
  _impl_.ccd_swept_sphere_radius_factor_ = 0;
}
inline float PhysicsConfigData::_internal_ccd_swept_sphere_radius_factor() const {
  return _impl_.ccd_swept_sphere_radius_factor_;
}
inline float PhysicsConfigData::ccd_swept_sphere_radius_factor() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.ccd_swept_sphere_radius_factor)
  return _internal_ccd_swept_sphere_radius_factor();
}
inline void PhysicsConfigData::_internal_set_ccd_swept_sphere_radius_factor(float value) {
  
  _impl_.ccd_swept_sphere_radius_factor_ = value;
}
inline void PhysicsConfigData::set_ccd_swept_sphere_radius_factor(float value) {
  _internal_set_ccd_swept_sphere_radius_factor(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.ccd_swept_sphere_radius_factor)
}

// float min_speed_factor = 16;
inline void PhysicsConfigData::clear_min_speed_factor() {
  _impl_.min_speed_factor_ = 0;
}
inline float PhysicsConfigData::_internal_min_speed_factor() const {
  return _impl_.min_speed_factor_;
}
inline float PhysicsConfigData::min_speed_factor() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.min_speed_factor)
  return _internal_min_speed_factor();
}
inline void PhysicsConfigData::_internal_set_min_speed_factor(float value) {
  
  _impl_.min_speed_factor_ = value;
}
inline void PhysicsConfigData::set_min_speed_factor(float value) {
  _internal_set_min_speed_factor(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.min_speed_factor)
}

// float step_simulation_rate = 17;
inline void PhysicsConfigData::clear_step_simulation_rate() {
  _impl_.step_simulation_rate_ = 0;
}
inline float PhysicsConfigData::_internal_step_simulation_rate() const {
  return _impl_.step_simulation_rate_;
}
inline float PhysicsConfigData::step_simulation_rate() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.step_simulation_rate)
  return _internal_step_simulation_rate();
}
inline void PhysicsConfigData::_internal_set_step_simulation_rate(float value) {
  
  _impl_.step_simulation_rate_ = value;
}
inline void PhysicsConfigData::set_step_simulation_rate(float value) {
  _internal_set_step_simulation_rate(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.step_simulation_rate)
}

// float ccd_motion_threshold = 18;
inline void PhysicsConfigData::clear_ccd_motion_threshold() {
  _impl_.ccd_motion_threshold_ = 0;
}
inline float PhysicsConfigData::_internal_ccd_motion_threshold() const {
  return _impl_.ccd_motion_threshold_;
}
inline float PhysicsConfigData::ccd_motion_threshold() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.ccd_motion_threshold)
  return _internal_ccd_motion_threshold();
}
inline void PhysicsConfigData::_internal_set_ccd_motion_threshold(float value) {
  
  _impl_.ccd_motion_threshold_ = value;
}
inline void PhysicsConfigData::set_ccd_motion_threshold(float value) {
  _internal_set_ccd_motion_threshold(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.ccd_motion_threshold)
}

// float ccd_swept_sphere_radius = 19;
inline void PhysicsConfigData::clear_ccd_swept_sphere_radius() {
  _impl_.ccd_swept_sphere_radius_ = 0;
}
inline float PhysicsConfigData::_internal_ccd_swept_sphere_radius() const {
  return _impl_.ccd_swept_sphere_radius_;
}
inline float PhysicsConfigData::ccd_swept_sphere_radius() const {
  // @@protoc_insertion_point(field_get:physics.PhysicsConfigData.ccd_swept_sphere_radius)
  return _internal_ccd_swept_sphere_radius();
}
inline void PhysicsConfigData::_internal_set_ccd_swept_sphere_radius(float value) {
  
  _impl_.ccd_swept_sphere_radius_ = value;
}
inline void PhysicsConfigData::set_ccd_swept_sphere_radius(float value) {
  _internal_set_ccd_swept_sphere_radius(value);
  // @@protoc_insertion_point(field_set:physics.PhysicsConfigData.ccd_swept_sphere_radius)
}

// -------------------------------------------------------------------

// CreateObjectRequest

// string id = 1;
inline void CreateObjectRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CreateObjectRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateObjectRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.CreateObjectRequest.id)
}
inline std::string* CreateObjectRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.id)
  return _s;
}
inline const std::string& CreateObjectRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CreateObjectRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateObjectRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateObjectRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.id)
  return _impl_.id_.Release();
}
inline void CreateObjectRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.id)
}

// .physics.Vector3 position = 2;
inline bool CreateObjectRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool CreateObjectRequest::has_position() const {
  return _internal_has_position();
}
inline void CreateObjectRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Vector3& CreateObjectRequest::_internal_position() const {
  const ::physics::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& CreateObjectRequest::position() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.position)
  return _internal_position();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_position(
    ::physics::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.position)
}
inline ::physics::Vector3* CreateObjectRequest::release_position() {
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.position)
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Vector3* CreateObjectRequest::mutable_position() {
  ::physics::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.position)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_position(::physics::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.position)
}

// .physics.Quaternion rotation = 3;
inline bool CreateObjectRequest::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool CreateObjectRequest::has_rotation() const {
  return _internal_has_rotation();
}
inline void CreateObjectRequest::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Quaternion& CreateObjectRequest::_internal_rotation() const {
  const ::physics::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Quaternion&>(
      ::physics::_Quaternion_default_instance_);
}
inline const ::physics::Quaternion& CreateObjectRequest::rotation() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.rotation)
  return _internal_rotation();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_rotation(
    ::physics::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.rotation)
}
inline ::physics::Quaternion* CreateObjectRequest::release_rotation() {
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Quaternion* CreateObjectRequest::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.rotation)
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Quaternion* CreateObjectRequest::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Quaternion* CreateObjectRequest::mutable_rotation() {
  ::physics::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.rotation)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_rotation(::physics::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.rotation)
}

// .physics.ShapeDescriptor shape = 4;
inline bool CreateObjectRequest::_internal_has_shape() const {
  return this != internal_default_instance() && _impl_.shape_ != nullptr;
}
inline bool CreateObjectRequest::has_shape() const {
  return _internal_has_shape();
}
inline void CreateObjectRequest::clear_shape() {
  if (GetArenaForAllocation() == nullptr && _impl_.shape_ != nullptr) {
    delete _impl_.shape_;
  }
  _impl_.shape_ = nullptr;
}
inline const ::physics::ShapeDescriptor& CreateObjectRequest::_internal_shape() const {
  const ::physics::ShapeDescriptor* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::ShapeDescriptor&>(
      ::physics::_ShapeDescriptor_default_instance_);
}
inline const ::physics::ShapeDescriptor& CreateObjectRequest::shape() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.shape)
  return _internal_shape();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_shape(
    ::physics::ShapeDescriptor* shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.shape)
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::release_shape() {
  
  ::physics::ShapeDescriptor* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.shape)
  
  ::physics::ShapeDescriptor* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::_internal_mutable_shape() {
  
  if (_impl_.shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::ShapeDescriptor>(GetArenaForAllocation());
    _impl_.shape_ = p;
  }
  return _impl_.shape_;
}
inline ::physics::ShapeDescriptor* CreateObjectRequest::mutable_shape() {
  ::physics::ShapeDescriptor* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.shape)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_shape(::physics::ShapeDescriptor* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_;
  }
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape);
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.shape)
}

// float mass = 5;
inline void CreateObjectRequest::clear_mass() {
  _impl_.mass_ = 0;
}
inline float CreateObjectRequest::_internal_mass() const {
  return _impl_.mass_;
}
inline float CreateObjectRequest::mass() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.mass)
  return _internal_mass();
}
inline void CreateObjectRequest::_internal_set_mass(float value) {
  
  _impl_.mass_ = value;
}
inline void CreateObjectRequest::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:physics.CreateObjectRequest.mass)
}

// .physics.Vector3 linear_velocity = 6;
inline bool CreateObjectRequest::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && _impl_.linear_velocity_ != nullptr;
}
inline bool CreateObjectRequest::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void CreateObjectRequest::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
}
inline const ::physics::Vector3& CreateObjectRequest::_internal_linear_velocity() const {
  const ::physics::Vector3* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& CreateObjectRequest::linear_velocity() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.linear_velocity)
  return _internal_linear_velocity();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_linear_velocity(
    ::physics::Vector3* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.linear_velocity)
}
inline ::physics::Vector3* CreateObjectRequest::release_linear_velocity() {
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.linear_velocity)
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::_internal_mutable_linear_velocity() {
  
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::physics::Vector3* CreateObjectRequest::mutable_linear_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.linear_velocity)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_linear_velocity(::physics::Vector3* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.linear_velocity)
}

// .physics.Vector3 angular_velocity = 7;
inline bool CreateObjectRequest::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && _impl_.angular_velocity_ != nullptr;
}
inline bool CreateObjectRequest::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void CreateObjectRequest::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
}
inline const ::physics::Vector3& CreateObjectRequest::_internal_angular_velocity() const {
  const ::physics::Vector3* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& CreateObjectRequest::angular_velocity() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectRequest.angular_velocity)
  return _internal_angular_velocity();
}
inline void CreateObjectRequest::unsafe_arena_set_allocated_angular_velocity(
    ::physics::Vector3* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.CreateObjectRequest.angular_velocity)
}
inline ::physics::Vector3* CreateObjectRequest::release_angular_velocity() {
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectRequest.angular_velocity)
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* CreateObjectRequest::_internal_mutable_angular_velocity() {
  
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::physics::Vector3* CreateObjectRequest::mutable_angular_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectRequest.angular_velocity)
  return _msg;
}
inline void CreateObjectRequest::set_allocated_angular_velocity(::physics::Vector3* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectRequest.angular_velocity)
}

// -------------------------------------------------------------------

// CreateObjectResponse

// string status = 1;
inline void CreateObjectResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& CreateObjectResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateObjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.CreateObjectResponse.status)
}
inline std::string* CreateObjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectResponse.status)
  return _s;
}
inline const std::string& CreateObjectResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void CreateObjectResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectResponse.status)
  return _impl_.status_.Release();
}
inline void CreateObjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectResponse.status)
}

// string message = 2;
inline void CreateObjectResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CreateObjectResponse::message() const {
  // @@protoc_insertion_point(field_get:physics.CreateObjectResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateObjectResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.CreateObjectResponse.message)
}
inline std::string* CreateObjectResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:physics.CreateObjectResponse.message)
  return _s;
}
inline const std::string& CreateObjectResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CreateObjectResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateObjectResponse::release_message() {
  // @@protoc_insertion_point(field_release:physics.CreateObjectResponse.message)
  return _impl_.message_.Release();
}
inline void CreateObjectResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.CreateObjectResponse.message)
}

// -------------------------------------------------------------------

// ApplyImpulseRequest

// string id = 1;
inline void ApplyImpulseRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ApplyImpulseRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyImpulseRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyImpulseRequest.id)
}
inline std::string* ApplyImpulseRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseRequest.id)
  return _s;
}
inline const std::string& ApplyImpulseRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ApplyImpulseRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyImpulseRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyImpulseRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseRequest.id)
  return _impl_.id_.Release();
}
inline void ApplyImpulseRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseRequest.id)
}

// .physics.Vector3 impulse = 2;
inline bool ApplyImpulseRequest::_internal_has_impulse() const {
  return this != internal_default_instance() && _impl_.impulse_ != nullptr;
}
inline bool ApplyImpulseRequest::has_impulse() const {
  return _internal_has_impulse();
}
inline void ApplyImpulseRequest::clear_impulse() {
  if (GetArenaForAllocation() == nullptr && _impl_.impulse_ != nullptr) {
    delete _impl_.impulse_;
  }
  _impl_.impulse_ = nullptr;
}
inline const ::physics::Vector3& ApplyImpulseRequest::_internal_impulse() const {
  const ::physics::Vector3* p = _impl_.impulse_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ApplyImpulseRequest::impulse() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseRequest.impulse)
  return _internal_impulse();
}
inline void ApplyImpulseRequest::unsafe_arena_set_allocated_impulse(
    ::physics::Vector3* impulse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impulse_);
  }
  _impl_.impulse_ = impulse;
  if (impulse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ApplyImpulseRequest.impulse)
}
inline ::physics::Vector3* ApplyImpulseRequest::release_impulse() {
  
  ::physics::Vector3* temp = _impl_.impulse_;
  _impl_.impulse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::unsafe_arena_release_impulse() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseRequest.impulse)
  
  ::physics::Vector3* temp = _impl_.impulse_;
  _impl_.impulse_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::_internal_mutable_impulse() {
  
  if (_impl_.impulse_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.impulse_ = p;
  }
  return _impl_.impulse_;
}
inline ::physics::Vector3* ApplyImpulseRequest::mutable_impulse() {
  ::physics::Vector3* _msg = _internal_mutable_impulse();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseRequest.impulse)
  return _msg;
}
inline void ApplyImpulseRequest::set_allocated_impulse(::physics::Vector3* impulse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.impulse_;
  }
  if (impulse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(impulse);
    if (message_arena != submessage_arena) {
      impulse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impulse, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impulse_ = impulse;
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseRequest.impulse)
}

// .physics.Vector3 relative_position = 3;
inline bool ApplyImpulseRequest::_internal_has_relative_position() const {
  return this != internal_default_instance() && _impl_.relative_position_ != nullptr;
}
inline bool ApplyImpulseRequest::has_relative_position() const {
  return _internal_has_relative_position();
}
inline void ApplyImpulseRequest::clear_relative_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.relative_position_ != nullptr) {
    delete _impl_.relative_position_;
  }
  _impl_.relative_position_ = nullptr;
}
inline const ::physics::Vector3& ApplyImpulseRequest::_internal_relative_position() const {
  const ::physics::Vector3* p = _impl_.relative_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ApplyImpulseRequest::relative_position() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseRequest.relative_position)
  return _internal_relative_position();
}
inline void ApplyImpulseRequest::unsafe_arena_set_allocated_relative_position(
    ::physics::Vector3* relative_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relative_position_);
  }
  _impl_.relative_position_ = relative_position;
  if (relative_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ApplyImpulseRequest.relative_position)
}
inline ::physics::Vector3* ApplyImpulseRequest::release_relative_position() {
  
  ::physics::Vector3* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::unsafe_arena_release_relative_position() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseRequest.relative_position)
  
  ::physics::Vector3* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ApplyImpulseRequest::_internal_mutable_relative_position() {
  
  if (_impl_.relative_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.relative_position_ = p;
  }
  return _impl_.relative_position_;
}
inline ::physics::Vector3* ApplyImpulseRequest::mutable_relative_position() {
  ::physics::Vector3* _msg = _internal_mutable_relative_position();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseRequest.relative_position)
  return _msg;
}
inline void ApplyImpulseRequest::set_allocated_relative_position(::physics::Vector3* relative_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relative_position_;
  }
  if (relative_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relative_position);
    if (message_arena != submessage_arena) {
      relative_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relative_position_ = relative_position;
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseRequest.relative_position)
}

// -------------------------------------------------------------------

// ApplyImpulseResponse

// string status = 1;
inline void ApplyImpulseResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ApplyImpulseResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyImpulseResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyImpulseResponse.status)
}
inline std::string* ApplyImpulseResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseResponse.status)
  return _s;
}
inline const std::string& ApplyImpulseResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ApplyImpulseResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseResponse.status)
  return _impl_.status_.Release();
}
inline void ApplyImpulseResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseResponse.status)
}

// string message = 2;
inline void ApplyImpulseResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ApplyImpulseResponse::message() const {
  // @@protoc_insertion_point(field_get:physics.ApplyImpulseResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyImpulseResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyImpulseResponse.message)
}
inline std::string* ApplyImpulseResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:physics.ApplyImpulseResponse.message)
  return _s;
}
inline const std::string& ApplyImpulseResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ApplyImpulseResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyImpulseResponse::release_message() {
  // @@protoc_insertion_point(field_release:physics.ApplyImpulseResponse.message)
  return _impl_.message_.Release();
}
inline void ApplyImpulseResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyImpulseResponse.message)
}

// -------------------------------------------------------------------

// ApplyTorqueRequest

// string id = 1;
inline void ApplyTorqueRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ApplyTorqueRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyTorqueRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyTorqueRequest.id)
}
inline std::string* ApplyTorqueRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueRequest.id)
  return _s;
}
inline const std::string& ApplyTorqueRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ApplyTorqueRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyTorqueRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyTorqueRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueRequest.id)
  return _impl_.id_.Release();
}
inline void ApplyTorqueRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueRequest.id)
}

// .physics.Vector3 torque = 2;
inline bool ApplyTorqueRequest::_internal_has_torque() const {
  return this != internal_default_instance() && _impl_.torque_ != nullptr;
}
inline bool ApplyTorqueRequest::has_torque() const {
  return _internal_has_torque();
}
inline void ApplyTorqueRequest::clear_torque() {
  if (GetArenaForAllocation() == nullptr && _impl_.torque_ != nullptr) {
    delete _impl_.torque_;
  }
  _impl_.torque_ = nullptr;
}
inline const ::physics::Vector3& ApplyTorqueRequest::_internal_torque() const {
  const ::physics::Vector3* p = _impl_.torque_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ApplyTorqueRequest::torque() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueRequest.torque)
  return _internal_torque();
}
inline void ApplyTorqueRequest::unsafe_arena_set_allocated_torque(
    ::physics::Vector3* torque) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.torque_);
  }
  _impl_.torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ApplyTorqueRequest.torque)
}
inline ::physics::Vector3* ApplyTorqueRequest::release_torque() {
  
  ::physics::Vector3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ApplyTorqueRequest::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueRequest.torque)
  
  ::physics::Vector3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ApplyTorqueRequest::_internal_mutable_torque() {
  
  if (_impl_.torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.torque_ = p;
  }
  return _impl_.torque_;
}
inline ::physics::Vector3* ApplyTorqueRequest::mutable_torque() {
  ::physics::Vector3* _msg = _internal_mutable_torque();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueRequest.torque)
  return _msg;
}
inline void ApplyTorqueRequest::set_allocated_torque(::physics::Vector3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueRequest.torque)
}

// -------------------------------------------------------------------

// ApplyTorqueResponse

// string status = 1;
inline void ApplyTorqueResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ApplyTorqueResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.ApplyTorqueResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyTorqueResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ApplyTorqueResponse.status)
}
inline std::string* ApplyTorqueResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.ApplyTorqueResponse.status)
  return _s;
}
inline const std::string& ApplyTorqueResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ApplyTorqueResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyTorqueResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyTorqueResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.ApplyTorqueResponse.status)
  return _impl_.status_.Release();
}
inline void ApplyTorqueResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ApplyTorqueResponse.status)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  _impl_.x_ = 0;
}
inline float Position::_internal_x() const {
  return _impl_.x_;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:physics.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  _impl_.y_ = 0;
}
inline float Position::_internal_y() const {
  return _impl_.y_;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:physics.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Position.y)
}

// float z = 3;
inline void Position::clear_z() {
  _impl_.z_ = 0;
}
inline float Position::_internal_z() const {
  return _impl_.z_;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:physics.Position.z)
  return _internal_z();
}
inline void Position::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Position::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Position.z)
}

// -------------------------------------------------------------------

// Rotation

// float x = 1;
inline void Rotation::clear_x() {
  _impl_.x_ = 0;
}
inline float Rotation::_internal_x() const {
  return _impl_.x_;
}
inline float Rotation::x() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.x)
  return _internal_x();
}
inline void Rotation::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Rotation::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.x)
}

// float y = 2;
inline void Rotation::clear_y() {
  _impl_.y_ = 0;
}
inline float Rotation::_internal_y() const {
  return _impl_.y_;
}
inline float Rotation::y() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.y)
  return _internal_y();
}
inline void Rotation::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Rotation::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.y)
}

// float z = 3;
inline void Rotation::clear_z() {
  _impl_.z_ = 0;
}
inline float Rotation::_internal_z() const {
  return _impl_.z_;
}
inline float Rotation::z() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.z)
  return _internal_z();
}
inline void Rotation::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Rotation::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.z)
}

// float w = 4;
inline void Rotation::clear_w() {
  _impl_.w_ = 0;
}
inline float Rotation::_internal_w() const {
  return _impl_.w_;
}
inline float Rotation::w() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.w)
  return _internal_w();
}
inline void Rotation::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void Rotation::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.w)
}

// float yaw = 5;
inline void Rotation::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Rotation::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.yaw)
  return _internal_yaw();
}
inline void Rotation::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void Rotation::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.yaw)
}

// float pitch = 6;
inline void Rotation::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Rotation::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.pitch)
  return _internal_pitch();
}
inline void Rotation::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void Rotation::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.pitch)
}

// float roll = 7;
inline void Rotation::clear_roll() {
  _impl_.roll_ = 0;
}
inline float Rotation::_internal_roll() const {
  return _impl_.roll_;
}
inline float Rotation::roll() const {
  // @@protoc_insertion_point(field_get:physics.Rotation.roll)
  return _internal_roll();
}
inline void Rotation::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void Rotation::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:physics.Rotation.roll)
}

// -------------------------------------------------------------------

// Velocity

// float x = 1;
inline void Velocity::clear_x() {
  _impl_.x_ = 0;
}
inline float Velocity::_internal_x() const {
  return _impl_.x_;
}
inline float Velocity::x() const {
  // @@protoc_insertion_point(field_get:physics.Velocity.x)
  return _internal_x();
}
inline void Velocity::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Velocity::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.Velocity.x)
}

// float y = 2;
inline void Velocity::clear_y() {
  _impl_.y_ = 0;
}
inline float Velocity::_internal_y() const {
  return _impl_.y_;
}
inline float Velocity::y() const {
  // @@protoc_insertion_point(field_get:physics.Velocity.y)
  return _internal_y();
}
inline void Velocity::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Velocity::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.Velocity.y)
}

// float z = 3;
inline void Velocity::clear_z() {
  _impl_.z_ = 0;
}
inline float Velocity::_internal_z() const {
  return _impl_.z_;
}
inline float Velocity::z() const {
  // @@protoc_insertion_point(field_get:physics.Velocity.z)
  return _internal_z();
}
inline void Velocity::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Velocity::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.Velocity.z)
}

// -------------------------------------------------------------------

// Object

// string id = 1;
inline void Object::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:physics.Object.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.Object.id)
}
inline std::string* Object::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:physics.Object.id)
  return _impl_.id_.Release();
}
inline void Object::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.Object.id)
}

// .physics.Position position = 2;
inline bool Object::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Object::has_position() const {
  return _internal_has_position();
}
inline void Object::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Position& Object::_internal_position() const {
  const ::physics::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Position&>(
      ::physics::_Position_default_instance_);
}
inline const ::physics::Position& Object::position() const {
  // @@protoc_insertion_point(field_get:physics.Object.position)
  return _internal_position();
}
inline void Object::unsafe_arena_set_allocated_position(
    ::physics::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.Object.position)
}
inline ::physics::Position* Object::release_position() {
  
  ::physics::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Position* Object::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.Object.position)
  
  ::physics::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Position* Object::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Position* Object::mutable_position() {
  ::physics::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.Object.position)
  return _msg;
}
inline void Object::set_allocated_position(::physics::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.Object.position)
}

// .physics.Rotation rotation = 3;
inline bool Object::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool Object::has_rotation() const {
  return _internal_has_rotation();
}
inline void Object::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Rotation& Object::_internal_rotation() const {
  const ::physics::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Rotation&>(
      ::physics::_Rotation_default_instance_);
}
inline const ::physics::Rotation& Object::rotation() const {
  // @@protoc_insertion_point(field_get:physics.Object.rotation)
  return _internal_rotation();
}
inline void Object::unsafe_arena_set_allocated_rotation(
    ::physics::Rotation* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.Object.rotation)
}
inline ::physics::Rotation* Object::release_rotation() {
  
  ::physics::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Rotation* Object::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.Object.rotation)
  
  ::physics::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Rotation* Object::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Rotation>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Rotation* Object::mutable_rotation() {
  ::physics::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.Object.rotation)
  return _msg;
}
inline void Object::set_allocated_rotation(::physics::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.Object.rotation)
}

// .physics.Velocity linear_velocity = 4;
inline bool Object::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && _impl_.linear_velocity_ != nullptr;
}
inline bool Object::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void Object::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
}
inline const ::physics::Velocity& Object::_internal_linear_velocity() const {
  const ::physics::Velocity* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Velocity&>(
      ::physics::_Velocity_default_instance_);
}
inline const ::physics::Velocity& Object::linear_velocity() const {
  // @@protoc_insertion_point(field_get:physics.Object.linear_velocity)
  return _internal_linear_velocity();
}
inline void Object::unsafe_arena_set_allocated_linear_velocity(
    ::physics::Velocity* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.Object.linear_velocity)
}
inline ::physics::Velocity* Object::release_linear_velocity() {
  
  ::physics::Velocity* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Velocity* Object::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:physics.Object.linear_velocity)
  
  ::physics::Velocity* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::physics::Velocity* Object::_internal_mutable_linear_velocity() {
  
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Velocity>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::physics::Velocity* Object::mutable_linear_velocity() {
  ::physics::Velocity* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:physics.Object.linear_velocity)
  return _msg;
}
inline void Object::set_allocated_linear_velocity(::physics::Velocity* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.Object.linear_velocity)
}

// .physics.Velocity angular_velocity = 5;
inline bool Object::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && _impl_.angular_velocity_ != nullptr;
}
inline bool Object::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void Object::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
}
inline const ::physics::Velocity& Object::_internal_angular_velocity() const {
  const ::physics::Velocity* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Velocity&>(
      ::physics::_Velocity_default_instance_);
}
inline const ::physics::Velocity& Object::angular_velocity() const {
  // @@protoc_insertion_point(field_get:physics.Object.angular_velocity)
  return _internal_angular_velocity();
}
inline void Object::unsafe_arena_set_allocated_angular_velocity(
    ::physics::Velocity* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.Object.angular_velocity)
}
inline ::physics::Velocity* Object::release_angular_velocity() {
  
  ::physics::Velocity* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Velocity* Object::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:physics.Object.angular_velocity)
  
  ::physics::Velocity* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::physics::Velocity* Object::_internal_mutable_angular_velocity() {
  
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Velocity>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::physics::Velocity* Object::mutable_angular_velocity() {
  ::physics::Velocity* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:physics.Object.angular_velocity)
  return _msg;
}
inline void Object::set_allocated_angular_velocity(::physics::Velocity* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.Object.angular_velocity)
}

// -------------------------------------------------------------------

// UpdateObjectRequest

// string id = 1;
inline void UpdateObjectRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateObjectRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectRequest.id)
}
inline std::string* UpdateObjectRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRequest.id)
  return _s;
}
inline const std::string& UpdateObjectRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateObjectRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateObjectRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRequest.id)
}

// .physics.Position position = 2;
inline bool UpdateObjectRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool UpdateObjectRequest::has_position() const {
  return _internal_has_position();
}
inline void UpdateObjectRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Position& UpdateObjectRequest::_internal_position() const {
  const ::physics::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Position&>(
      ::physics::_Position_default_instance_);
}
inline const ::physics::Position& UpdateObjectRequest::position() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRequest.position)
  return _internal_position();
}
inline void UpdateObjectRequest::unsafe_arena_set_allocated_position(
    ::physics::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.UpdateObjectRequest.position)
}
inline ::physics::Position* UpdateObjectRequest::release_position() {
  
  ::physics::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Position* UpdateObjectRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRequest.position)
  
  ::physics::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Position* UpdateObjectRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Position* UpdateObjectRequest::mutable_position() {
  ::physics::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRequest.position)
  return _msg;
}
inline void UpdateObjectRequest::set_allocated_position(::physics::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRequest.position)
}

// .physics.Rotation rotation = 3;
inline bool UpdateObjectRequest::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool UpdateObjectRequest::has_rotation() const {
  return _internal_has_rotation();
}
inline void UpdateObjectRequest::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Rotation& UpdateObjectRequest::_internal_rotation() const {
  const ::physics::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Rotation&>(
      ::physics::_Rotation_default_instance_);
}
inline const ::physics::Rotation& UpdateObjectRequest::rotation() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRequest.rotation)
  return _internal_rotation();
}
inline void UpdateObjectRequest::unsafe_arena_set_allocated_rotation(
    ::physics::Rotation* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.UpdateObjectRequest.rotation)
}
inline ::physics::Rotation* UpdateObjectRequest::release_rotation() {
  
  ::physics::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Rotation* UpdateObjectRequest::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRequest.rotation)
  
  ::physics::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Rotation* UpdateObjectRequest::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Rotation>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Rotation* UpdateObjectRequest::mutable_rotation() {
  ::physics::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRequest.rotation)
  return _msg;
}
inline void UpdateObjectRequest::set_allocated_rotation(::physics::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRequest.rotation)
}

// .physics.Vector3 linear_velocity = 4;
inline bool UpdateObjectRequest::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && _impl_.linear_velocity_ != nullptr;
}
inline bool UpdateObjectRequest::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void UpdateObjectRequest::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
}
inline const ::physics::Vector3& UpdateObjectRequest::_internal_linear_velocity() const {
  const ::physics::Vector3* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& UpdateObjectRequest::linear_velocity() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRequest.linear_velocity)
  return _internal_linear_velocity();
}
inline void UpdateObjectRequest::unsafe_arena_set_allocated_linear_velocity(
    ::physics::Vector3* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.UpdateObjectRequest.linear_velocity)
}
inline ::physics::Vector3* UpdateObjectRequest::release_linear_velocity() {
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* UpdateObjectRequest::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRequest.linear_velocity)
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* UpdateObjectRequest::_internal_mutable_linear_velocity() {
  
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::physics::Vector3* UpdateObjectRequest::mutable_linear_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRequest.linear_velocity)
  return _msg;
}
inline void UpdateObjectRequest::set_allocated_linear_velocity(::physics::Vector3* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRequest.linear_velocity)
}

// .physics.Vector3 angular_velocity = 5;
inline bool UpdateObjectRequest::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && _impl_.angular_velocity_ != nullptr;
}
inline bool UpdateObjectRequest::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void UpdateObjectRequest::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
}
inline const ::physics::Vector3& UpdateObjectRequest::_internal_angular_velocity() const {
  const ::physics::Vector3* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& UpdateObjectRequest::angular_velocity() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectRequest.angular_velocity)
  return _internal_angular_velocity();
}
inline void UpdateObjectRequest::unsafe_arena_set_allocated_angular_velocity(
    ::physics::Vector3* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.UpdateObjectRequest.angular_velocity)
}
inline ::physics::Vector3* UpdateObjectRequest::release_angular_velocity() {
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* UpdateObjectRequest::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectRequest.angular_velocity)
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* UpdateObjectRequest::_internal_mutable_angular_velocity() {
  
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::physics::Vector3* UpdateObjectRequest::mutable_angular_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectRequest.angular_velocity)
  return _msg;
}
inline void UpdateObjectRequest::set_allocated_angular_velocity(::physics::Vector3* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectRequest.angular_velocity)
}

// -------------------------------------------------------------------

// UpdateObjectResponse

// string status = 1;
inline void UpdateObjectResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& UpdateObjectResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectResponse.status)
}
inline std::string* UpdateObjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectResponse.status)
  return _s;
}
inline const std::string& UpdateObjectResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void UpdateObjectResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectResponse.status)
  return _impl_.status_.Release();
}
inline void UpdateObjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectResponse.status)
}

// string message = 2;
inline void UpdateObjectResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateObjectResponse::message() const {
  // @@protoc_insertion_point(field_get:physics.UpdateObjectResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateObjectResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.UpdateObjectResponse.message)
}
inline std::string* UpdateObjectResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:physics.UpdateObjectResponse.message)
  return _s;
}
inline const std::string& UpdateObjectResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UpdateObjectResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateObjectResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateObjectResponse::release_message() {
  // @@protoc_insertion_point(field_release:physics.UpdateObjectResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateObjectResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.UpdateObjectResponse.message)
}

// -------------------------------------------------------------------

// StepSimulationRequest

// float time_step = 1;
inline void StepSimulationRequest::clear_time_step() {
  _impl_.time_step_ = 0;
}
inline float StepSimulationRequest::_internal_time_step() const {
  return _impl_.time_step_;
}
inline float StepSimulationRequest::time_step() const {
  // @@protoc_insertion_point(field_get:physics.StepSimulationRequest.time_step)
  return _internal_time_step();
}
inline void StepSimulationRequest::_internal_set_time_step(float value) {
  
  _impl_.time_step_ = value;
}
inline void StepSimulationRequest::set_time_step(float value) {
  _internal_set_time_step(value);
  // @@protoc_insertion_point(field_set:physics.StepSimulationRequest.time_step)
}

// -------------------------------------------------------------------

// StepSimulationResponse

// string status = 1;
inline void StepSimulationResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& StepSimulationResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.StepSimulationResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepSimulationResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.StepSimulationResponse.status)
}
inline std::string* StepSimulationResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.StepSimulationResponse.status)
  return _s;
}
inline const std::string& StepSimulationResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void StepSimulationResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* StepSimulationResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* StepSimulationResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.StepSimulationResponse.status)
  return _impl_.status_.Release();
}
inline void StepSimulationResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.StepSimulationResponse.status)
}

// string message = 2;
inline void StepSimulationResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StepSimulationResponse::message() const {
  // @@protoc_insertion_point(field_get:physics.StepSimulationResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepSimulationResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.StepSimulationResponse.message)
}
inline std::string* StepSimulationResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:physics.StepSimulationResponse.message)
  return _s;
}
inline const std::string& StepSimulationResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void StepSimulationResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* StepSimulationResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* StepSimulationResponse::release_message() {
  // @@protoc_insertion_point(field_release:physics.StepSimulationResponse.message)
  return _impl_.message_.Release();
}
inline void StepSimulationResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.StepSimulationResponse.message)
}

// repeated .physics.Object objects = 3;
inline int StepSimulationResponse::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int StepSimulationResponse::objects_size() const {
  return _internal_objects_size();
}
inline void StepSimulationResponse::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::physics::Object* StepSimulationResponse::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:physics.StepSimulationResponse.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::physics::Object >*
StepSimulationResponse::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:physics.StepSimulationResponse.objects)
  return &_impl_.objects_;
}
inline const ::physics::Object& StepSimulationResponse::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::physics::Object& StepSimulationResponse::objects(int index) const {
  // @@protoc_insertion_point(field_get:physics.StepSimulationResponse.objects)
  return _internal_objects(index);
}
inline ::physics::Object* StepSimulationResponse::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::physics::Object* StepSimulationResponse::add_objects() {
  ::physics::Object* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:physics.StepSimulationResponse.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::physics::Object >&
StepSimulationResponse::objects() const {
  // @@protoc_insertion_point(field_list:physics.StepSimulationResponse.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// ObjectRequest

// string id = 1;
inline void ObjectRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ObjectRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.ObjectRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ObjectRequest.id)
}
inline std::string* ObjectRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.ObjectRequest.id)
  return _s;
}
inline const std::string& ObjectRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ObjectRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.ObjectRequest.id)
  return _impl_.id_.Release();
}
inline void ObjectRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectRequest.id)
}

// -------------------------------------------------------------------

// ObjectResponse

// string status = 1;
inline void ObjectResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ObjectResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.status)
}
inline std::string* ObjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.ObjectResponse.status)
  return _s;
}
inline const std::string& ObjectResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ObjectResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.ObjectResponse.status)
  return _impl_.status_.Release();
}
inline void ObjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectResponse.status)
}

// float x = 2;
inline void ObjectResponse::clear_x() {
  _impl_.x_ = 0;
}
inline float ObjectResponse::_internal_x() const {
  return _impl_.x_;
}
inline float ObjectResponse::x() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.x)
  return _internal_x();
}
inline void ObjectResponse::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void ObjectResponse::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.x)
}

// float y = 3;
inline void ObjectResponse::clear_y() {
  _impl_.y_ = 0;
}
inline float ObjectResponse::_internal_y() const {
  return _impl_.y_;
}
inline float ObjectResponse::y() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.y)
  return _internal_y();
}
inline void ObjectResponse::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void ObjectResponse::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.y)
}

// float z = 4;
inline void ObjectResponse::clear_z() {
  _impl_.z_ = 0;
}
inline float ObjectResponse::_internal_z() const {
  return _impl_.z_;
}
inline float ObjectResponse::z() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.z)
  return _internal_z();
}
inline void ObjectResponse::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void ObjectResponse::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.z)
}

// float qx = 5;
inline void ObjectResponse::clear_qx() {
  _impl_.qx_ = 0;
}
inline float ObjectResponse::_internal_qx() const {
  return _impl_.qx_;
}
inline float ObjectResponse::qx() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.qx)
  return _internal_qx();
}
inline void ObjectResponse::_internal_set_qx(float value) {
  
  _impl_.qx_ = value;
}
inline void ObjectResponse::set_qx(float value) {
  _internal_set_qx(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.qx)
}

// float qy = 6;
inline void ObjectResponse::clear_qy() {
  _impl_.qy_ = 0;
}
inline float ObjectResponse::_internal_qy() const {
  return _impl_.qy_;
}
inline float ObjectResponse::qy() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.qy)
  return _internal_qy();
}
inline void ObjectResponse::_internal_set_qy(float value) {
  
  _impl_.qy_ = value;
}
inline void ObjectResponse::set_qy(float value) {
  _internal_set_qy(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.qy)
}

// float qz = 7;
inline void ObjectResponse::clear_qz() {
  _impl_.qz_ = 0;
}
inline float ObjectResponse::_internal_qz() const {
  return _impl_.qz_;
}
inline float ObjectResponse::qz() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.qz)
  return _internal_qz();
}
inline void ObjectResponse::_internal_set_qz(float value) {
  
  _impl_.qz_ = value;
}
inline void ObjectResponse::set_qz(float value) {
  _internal_set_qz(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.qz)
}

// float qw = 8;
inline void ObjectResponse::clear_qw() {
  _impl_.qw_ = 0;
}
inline float ObjectResponse::_internal_qw() const {
  return _impl_.qw_;
}
inline float ObjectResponse::qw() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.qw)
  return _internal_qw();
}
inline void ObjectResponse::_internal_set_qw(float value) {
  
  _impl_.qw_ = value;
}
inline void ObjectResponse::set_qw(float value) {
  _internal_set_qw(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.qw)
}

// float vx = 9;
inline void ObjectResponse::clear_vx() {
  _impl_.vx_ = 0;
}
inline float ObjectResponse::_internal_vx() const {
  return _impl_.vx_;
}
inline float ObjectResponse::vx() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.vx)
  return _internal_vx();
}
inline void ObjectResponse::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void ObjectResponse::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.vx)
}

// float vy = 10;
inline void ObjectResponse::clear_vy() {
  _impl_.vy_ = 0;
}
inline float ObjectResponse::_internal_vy() const {
  return _impl_.vy_;
}
inline float ObjectResponse::vy() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.vy)
  return _internal_vy();
}
inline void ObjectResponse::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void ObjectResponse::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.vy)
}

// float vz = 11;
inline void ObjectResponse::clear_vz() {
  _impl_.vz_ = 0;
}
inline float ObjectResponse::_internal_vz() const {
  return _impl_.vz_;
}
inline float ObjectResponse::vz() const {
  // @@protoc_insertion_point(field_get:physics.ObjectResponse.vz)
  return _internal_vz();
}
inline void ObjectResponse::_internal_set_vz(float value) {
  
  _impl_.vz_ = value;
}
inline void ObjectResponse::set_vz(float value) {
  _internal_set_vz(value);
  // @@protoc_insertion_point(field_set:physics.ObjectResponse.vz)
}

// -------------------------------------------------------------------

// GetObjectStateRequest

// string id = 1;
inline void GetObjectStateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetObjectStateRequest::id() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectStateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.GetObjectStateRequest.id)
}
inline std::string* GetObjectStateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateRequest.id)
  return _s;
}
inline const std::string& GetObjectStateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetObjectStateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectStateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectStateRequest::release_id() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateRequest.id)
  return _impl_.id_.Release();
}
inline void GetObjectStateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateRequest.id)
}

// -------------------------------------------------------------------

// ObjectState

// .physics.Vector3 position = 1;
inline bool ObjectState::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool ObjectState::has_position() const {
  return _internal_has_position();
}
inline void ObjectState::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_position() const {
  const ::physics::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::position() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.position)
  return _internal_position();
}
inline void ObjectState::unsafe_arena_set_allocated_position(
    ::physics::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.position)
}
inline ::physics::Vector3* ObjectState::release_position() {
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.position)
  
  ::physics::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::physics::Vector3* ObjectState::mutable_position() {
  ::physics::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.position)
  return _msg;
}
inline void ObjectState::set_allocated_position(::physics::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.position)
}

// .physics.Quaternion rotation = 2;
inline bool ObjectState::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool ObjectState::has_rotation() const {
  return _internal_has_rotation();
}
inline void ObjectState::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::physics::Quaternion& ObjectState::_internal_rotation() const {
  const ::physics::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Quaternion&>(
      ::physics::_Quaternion_default_instance_);
}
inline const ::physics::Quaternion& ObjectState::rotation() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.rotation)
  return _internal_rotation();
}
inline void ObjectState::unsafe_arena_set_allocated_rotation(
    ::physics::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.rotation)
}
inline ::physics::Quaternion* ObjectState::release_rotation() {
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Quaternion* ObjectState::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.rotation)
  
  ::physics::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::physics::Quaternion* ObjectState::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::physics::Quaternion* ObjectState::mutable_rotation() {
  ::physics::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.rotation)
  return _msg;
}
inline void ObjectState::set_allocated_rotation(::physics::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.rotation)
}

// .physics.Vector3 linear_velocity = 3;
inline bool ObjectState::_internal_has_linear_velocity() const {
  return this != internal_default_instance() && _impl_.linear_velocity_ != nullptr;
}
inline bool ObjectState::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline void ObjectState::clear_linear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_velocity_ != nullptr) {
    delete _impl_.linear_velocity_;
  }
  _impl_.linear_velocity_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_linear_velocity() const {
  const ::physics::Vector3* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::linear_velocity() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.linear_velocity)
  return _internal_linear_velocity();
}
inline void ObjectState::unsafe_arena_set_allocated_linear_velocity(
    ::physics::Vector3* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.linear_velocity)
}
inline ::physics::Vector3* ObjectState::release_linear_velocity() {
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.linear_velocity)
  
  ::physics::Vector3* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_linear_velocity() {
  
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::physics::Vector3* ObjectState::mutable_linear_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.linear_velocity)
  return _msg;
}
inline void ObjectState::set_allocated_linear_velocity(::physics::Vector3* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_velocity_;
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_velocity);
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.linear_velocity)
}

// .physics.Vector3 angular_velocity = 4;
inline bool ObjectState::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && _impl_.angular_velocity_ != nullptr;
}
inline bool ObjectState::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void ObjectState::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_velocity_ != nullptr) {
    delete _impl_.angular_velocity_;
  }
  _impl_.angular_velocity_ = nullptr;
}
inline const ::physics::Vector3& ObjectState::_internal_angular_velocity() const {
  const ::physics::Vector3* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::Vector3&>(
      ::physics::_Vector3_default_instance_);
}
inline const ::physics::Vector3& ObjectState::angular_velocity() const {
  // @@protoc_insertion_point(field_get:physics.ObjectState.angular_velocity)
  return _internal_angular_velocity();
}
inline void ObjectState::unsafe_arena_set_allocated_angular_velocity(
    ::physics::Vector3* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.ObjectState.angular_velocity)
}
inline ::physics::Vector3* ObjectState::release_angular_velocity() {
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::Vector3* ObjectState::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:physics.ObjectState.angular_velocity)
  
  ::physics::Vector3* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::physics::Vector3* ObjectState::_internal_mutable_angular_velocity() {
  
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::Vector3>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::physics::Vector3* ObjectState::mutable_angular_velocity() {
  ::physics::Vector3* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:physics.ObjectState.angular_velocity)
  return _msg;
}
inline void ObjectState::set_allocated_angular_velocity(::physics::Vector3* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:physics.ObjectState.angular_velocity)
}

// -------------------------------------------------------------------

// GetObjectStateResponse

// string status = 1;
inline void GetObjectStateResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GetObjectStateResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectStateResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.GetObjectStateResponse.status)
}
inline std::string* GetObjectStateResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateResponse.status)
  return _s;
}
inline const std::string& GetObjectStateResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void GetObjectStateResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectStateResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectStateResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateResponse.status)
  return _impl_.status_.Release();
}
inline void GetObjectStateResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateResponse.status)
}

// .physics.ObjectState state = 2;
inline bool GetObjectStateResponse::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool GetObjectStateResponse::has_state() const {
  return _internal_has_state();
}
inline void GetObjectStateResponse::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::physics::ObjectState& GetObjectStateResponse::_internal_state() const {
  const ::physics::ObjectState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::ObjectState&>(
      ::physics::_ObjectState_default_instance_);
}
inline const ::physics::ObjectState& GetObjectStateResponse::state() const {
  // @@protoc_insertion_point(field_get:physics.GetObjectStateResponse.state)
  return _internal_state();
}
inline void GetObjectStateResponse::unsafe_arena_set_allocated_state(
    ::physics::ObjectState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.GetObjectStateResponse.state)
}
inline ::physics::ObjectState* GetObjectStateResponse::release_state() {
  
  ::physics::ObjectState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::ObjectState* GetObjectStateResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:physics.GetObjectStateResponse.state)
  
  ::physics::ObjectState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::physics::ObjectState* GetObjectStateResponse::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::ObjectState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::physics::ObjectState* GetObjectStateResponse::mutable_state() {
  ::physics::ObjectState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:physics.GetObjectStateResponse.state)
  return _msg;
}
inline void GetObjectStateResponse::set_allocated_state(::physics::ObjectState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:physics.GetObjectStateResponse.state)
}

// -------------------------------------------------------------------

// GetPhysicsConfigRequest

// -------------------------------------------------------------------

// GetPhysicsConfigResponse

// string status = 1;
inline void GetPhysicsConfigResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GetPhysicsConfigResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.GetPhysicsConfigResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPhysicsConfigResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.GetPhysicsConfigResponse.status)
}
inline std::string* GetPhysicsConfigResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.GetPhysicsConfigResponse.status)
  return _s;
}
inline const std::string& GetPhysicsConfigResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void GetPhysicsConfigResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPhysicsConfigResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPhysicsConfigResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.GetPhysicsConfigResponse.status)
  return _impl_.status_.Release();
}
inline void GetPhysicsConfigResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.GetPhysicsConfigResponse.status)
}

// .physics.PhysicsConfigData config = 2;
inline bool GetPhysicsConfigResponse::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool GetPhysicsConfigResponse::has_config() const {
  return _internal_has_config();
}
inline void GetPhysicsConfigResponse::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::physics::PhysicsConfigData& GetPhysicsConfigResponse::_internal_config() const {
  const ::physics::PhysicsConfigData* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::PhysicsConfigData&>(
      ::physics::_PhysicsConfigData_default_instance_);
}
inline const ::physics::PhysicsConfigData& GetPhysicsConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:physics.GetPhysicsConfigResponse.config)
  return _internal_config();
}
inline void GetPhysicsConfigResponse::unsafe_arena_set_allocated_config(
    ::physics::PhysicsConfigData* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.GetPhysicsConfigResponse.config)
}
inline ::physics::PhysicsConfigData* GetPhysicsConfigResponse::release_config() {
  
  ::physics::PhysicsConfigData* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::PhysicsConfigData* GetPhysicsConfigResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:physics.GetPhysicsConfigResponse.config)
  
  ::physics::PhysicsConfigData* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::physics::PhysicsConfigData* GetPhysicsConfigResponse::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::PhysicsConfigData>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::physics::PhysicsConfigData* GetPhysicsConfigResponse::mutable_config() {
  ::physics::PhysicsConfigData* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:physics.GetPhysicsConfigResponse.config)
  return _msg;
}
inline void GetPhysicsConfigResponse::set_allocated_config(::physics::PhysicsConfigData* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:physics.GetPhysicsConfigResponse.config)
}

// -------------------------------------------------------------------

// SetPhysicsConfigRequest

// .physics.PhysicsConfigData config = 1;
inline bool SetPhysicsConfigRequest::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool SetPhysicsConfigRequest::has_config() const {
  return _internal_has_config();
}
inline void SetPhysicsConfigRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::physics::PhysicsConfigData& SetPhysicsConfigRequest::_internal_config() const {
  const ::physics::PhysicsConfigData* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::physics::PhysicsConfigData&>(
      ::physics::_PhysicsConfigData_default_instance_);
}
inline const ::physics::PhysicsConfigData& SetPhysicsConfigRequest::config() const {
  // @@protoc_insertion_point(field_get:physics.SetPhysicsConfigRequest.config)
  return _internal_config();
}
inline void SetPhysicsConfigRequest::unsafe_arena_set_allocated_config(
    ::physics::PhysicsConfigData* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:physics.SetPhysicsConfigRequest.config)
}
inline ::physics::PhysicsConfigData* SetPhysicsConfigRequest::release_config() {
  
  ::physics::PhysicsConfigData* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::physics::PhysicsConfigData* SetPhysicsConfigRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:physics.SetPhysicsConfigRequest.config)
  
  ::physics::PhysicsConfigData* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::physics::PhysicsConfigData* SetPhysicsConfigRequest::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::physics::PhysicsConfigData>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::physics::PhysicsConfigData* SetPhysicsConfigRequest::mutable_config() {
  ::physics::PhysicsConfigData* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:physics.SetPhysicsConfigRequest.config)
  return _msg;
}
inline void SetPhysicsConfigRequest::set_allocated_config(::physics::PhysicsConfigData* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:physics.SetPhysicsConfigRequest.config)
}

// -------------------------------------------------------------------

// SetPhysicsConfigResponse

// string status = 1;
inline void SetPhysicsConfigResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SetPhysicsConfigResponse::status() const {
  // @@protoc_insertion_point(field_get:physics.SetPhysicsConfigResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPhysicsConfigResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.SetPhysicsConfigResponse.status)
}
inline std::string* SetPhysicsConfigResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:physics.SetPhysicsConfigResponse.status)
  return _s;
}
inline const std::string& SetPhysicsConfigResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SetPhysicsConfigResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::release_status() {
  // @@protoc_insertion_point(field_release:physics.SetPhysicsConfigResponse.status)
  return _impl_.status_.Release();
}
inline void SetPhysicsConfigResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.SetPhysicsConfigResponse.status)
}

// string message = 2;
inline void SetPhysicsConfigResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SetPhysicsConfigResponse::message() const {
  // @@protoc_insertion_point(field_get:physics.SetPhysicsConfigResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPhysicsConfigResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:physics.SetPhysicsConfigResponse.message)
}
inline std::string* SetPhysicsConfigResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:physics.SetPhysicsConfigResponse.message)
  return _s;
}
inline const std::string& SetPhysicsConfigResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SetPhysicsConfigResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPhysicsConfigResponse::release_message() {
  // @@protoc_insertion_point(field_release:physics.SetPhysicsConfigResponse.message)
  return _impl_.message_.Release();
}
inline void SetPhysicsConfigResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:physics.SetPhysicsConfigResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace physics

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::physics::ShapeDescriptor_ShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physics::ShapeDescriptor_ShapeType>() {
  return ::physics::ShapeDescriptor_ShapeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_physics_2eproto
